<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CodeSmith.Engine</name>
    </assembly>
    <members>
        <member name="T:CodeSmith.Engine.CommandLine.ArgumentAttribute">
            <summary>
            Allows control of command line parsing.
            Attach this attribute to instance fields of types used
            as the destination of command line argument parsing.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.ArgumentAttribute.#ctor(CodeSmith.Engine.CommandLine.ArgumentType)">
            <summary>
            Allows control of command line parsing.
            </summary>
            <param name="type"> Specifies the error checking to be done on the argument. </param>
        </member>
        <member name="P:CodeSmith.Engine.CommandLine.ArgumentAttribute.Type">
            <summary>
            The error checking to be done on the argument.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.CommandLine.ArgumentAttribute.DefaultShortName">
            <summary>
            Returns true if the argument did not have an explicit short name specified.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.CommandLine.ArgumentAttribute.ShortName">
            <summary>
            The short name of the argument.
            Set to null means use the default short name if it does not
            conflict with any other parameter name.
            Set to String.Empty for no short name.
            This property should not be set for DefaultArgumentAttributes.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.CommandLine.ArgumentAttribute.DefaultLongName">
            <summary>
            Returns true if the argument did not have an explicit long name specified.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.CommandLine.ArgumentAttribute.LongName">
            <summary>
            The long name of the argument.
            Set to null means use the default long name.
            The long name for every argument must be unique.
            It is an error to specify a long name of String.Empty.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.CommandLine.ArgumentAttribute.DefaultValue">
            <summary>
            The default value of the argument.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.CommandLine.ArgumentAttribute.HasDefaultValue">
            <summary>
            Returns true if the argument has a default value.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.CommandLine.ArgumentAttribute.HasHelpText">
            <summary>
            Returns true if the argument has help text specified.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.CommandLine.ArgumentAttribute.HelpText">
            <summary>
            The help text for the argument.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.CommandLine.ArgumentAttribute.IsToggle">
            <summary>
            Show optional boolean toggle syntax options for the arguments.  
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.CommandLine.ArgumentType">
            <summary>
            Used to control parsing of command line arguments.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.CommandLine.ArgumentType.Required">
            <summary>
            Indicates that this field is required. An error will be displayed
            if it is not present when parsing arguments.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.CommandLine.ArgumentType.Unique">
            <summary>
            Only valid in conjunction with Multiple.
            Duplicate values will result in an error.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.CommandLine.ArgumentType.Multiple">
            <summary>
            Inidicates that the argument may be specified more than once.
            Only valid if the argument is a collection
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.CommandLine.ArgumentType.AtMostOnce">
            <summary>
            The default type for non-collection arguments.
            The argument is not required, but an error will be reported if it is specified more than once.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.CommandLine.ArgumentType.LastOccurenceWins">
            <summary>
            For non-collection arguments, when the argument is specified more than
            once no error is reported and the value of the argument is the last
            value which occurs in the argument list.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.CommandLine.ArgumentType.MultipleUnique">
            <summary>
            The default type for collection arguments.
            The argument is permitted to occur multiple times, but duplicate 
            values will cause an error to be reported.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.CommandLine.DefaultArgumentAttribute">
            <summary>
            Indicates that this argument is the default argument.
            '/' or '-' prefix only the argument value is specified.
            The ShortName property should not be set for DefaultArgumentAttribute
            instances. The LongName property is used for usage text only and
            does not affect the usage of the argument.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.DefaultArgumentAttribute.#ctor(CodeSmith.Engine.CommandLine.ArgumentType)">
            <summary>
            Indicates that this argument is the default argument.
            </summary>
            <param name="type"> Specifies the error checking to be done on the argument. </param>
        </member>
        <member name="T:CodeSmith.Engine.CommandLine.ErrorReporter">
            <summary>
            A delegate used in error reporting.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.CommandLine.Parser">
             <summary>
             Parser for command line arguments.
            
             The parser specification is infered from the instance fields of the object
             specified as the destination of the parse.
             Valid argument types are: int, uint, string, bool, enums
             Also argument types of Array of the above types are also valid.
             
             Error checking options can be controlled by adding a ArgumentAttribute
             to the instance fields of the destination object.
            
             At most one field may be marked with the DefaultArgumentAttribute
             indicating that arguments without a '-' or '/' prefix will be parsed as that argument.
            
             If not specified then the parser will infer default options for parsing each
             instance field. The default long name of the argument is the field name. The
             default short name is the first character of the long name. Long names and explicitly
             specified short names must be unique. Default short names will be used provided that
             the default short name does not conflict with a long name or an explicitly
             specified short name.
            
             Arguments which are array types are collection arguments. Collection
             arguments can be specified multiple times.
             </summary>
        </member>
        <member name="F:CodeSmith.Engine.CommandLine.Parser.NewLine">
            <summary>
            The System Defined new line string.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.Parser.#ctor">
            <summary>
            Don't ever call this.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.Parser.ParseArgumentsWithUsage(System.String[],System.Object)">
            <summary>
            Parses Command Line Arguments. Displays usage message to Console.Out
            if /?, /help or invalid arguments are encounterd.
            Errors are output on Console.Error.
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.Parser.ParseArguments(System.String[],System.Object)">
            <summary>
            Parses Command Line Arguments. 
            Errors are output on Console.Error.
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.Parser.ParseArguments(System.String[],System.Object,CodeSmith.Engine.CommandLine.ErrorReporter)">
            <summary>
            Parses Command Line Arguments. 
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <param name="reporter"> The destination for parse errors. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.Parser.ParseHelp(System.String[])">
            <summary>
            Checks if a set of arguments asks for help.
            </summary>
            <param name="args"> Args to check for help. </param>
            <returns> Returns true if args contains /? or /help. </returns>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.Parser.ArgumentsUsage(System.Type)">
            <summary>
            Returns a Usage string for command line argument parsing.
            Use ArgumentAttributes to control parsing behaviour.
            Formats the output to the width of the current console window.
            </summary>
            <param name="argumentType"> The type of the arguments to display usage for. </param>
            <returns> Printable string containing a user friendly description of command line arguments. </returns>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.Parser.ArgumentsUsage(System.Type,System.Int32)">
            <summary>
            Returns a Usage string for command line argument parsing.
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="argumentType"> The type of the arguments to display usage for. </param>
            <param name="columns"> The number of columns to format the output to. </param>
            <returns> Printable string containing a user friendly description of command line arguments. </returns>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.Parser.GetConsoleWindowWidth">
            <summary>
            Returns the number of columns in the current console window
            </summary>
            <returns>Returns the number of columns in the current console window</returns>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.Parser.IndexOf(System.Text.StringBuilder,System.Char,System.Int32)">
            <summary>
            Searches a StringBuilder for a character
            </summary>
            <param name="text"> The text to search. </param>
            <param name="value"> The character value to search for. </param>
            <param name="startIndex"> The index to stat searching at. </param>
            <returns> The index of the first occurence of value or -1 if it is not found. </returns>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.Parser.LastIndexOf(System.Text.StringBuilder,System.Char,System.Int32)">
            <summary>
            Searches a StringBuilder for a character in reverse
            </summary>
            <param name="text"> The text to search. </param>
            <param name="value"> The character to search for. </param>
            <param name="startIndex"> The index to start the search at. </param>
            <returns>The index of the last occurence of value in text or -1 if it is not found. </returns>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.Parser.#ctor(System.Type,CodeSmith.Engine.CommandLine.ErrorReporter)">
            <summary>
            Creates a new command line argument parser.
            </summary>
            <param name="argumentSpecification"> The type of object to  parse. </param>
            <param name="reporter"> The destination for parse errors. </param>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.Parser.ParseArgumentList(System.String[],System.Object)">
            <summary>
            Parses an argument list into an object
            </summary>
            <param name="args"></param>
            <param name="destination"></param>
            <returns> true if an error occurred </returns>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.Parser.Parse(System.String[],System.Object)">
            <summary>
            Parses an argument list.
            </summary>
            <param name="args"> The arguments to parse. </param>
            <param name="destination"> The destination of the parsed arguments. </param>
            <returns> true if no parse errors were encountered. </returns>
        </member>
        <member name="M:CodeSmith.Engine.CommandLine.Parser.GetUsageString(System.Int32)">
            <summary>
            A user firendly usage string describing the command line argument syntax.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.CommandLine.Parser.HasDefaultArgument">
            <summary>
            Does this parser have a default argument.
            </summary>
            <value> Does this parser have a default argument. </value>
        </member>
        <member name="M:CodeSmith.Engine.ActiveSnippetGenerator.GenerateSnippet(System.String,System.String,System.String@)">
            <summary>
            Generates the snippet.
            </summary>
            <param name="rawLine">The raw line.</param>
            <param name="targetExtension">The target extension.</param>
            <param name="output">The snippet output.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.ActiveSnippetGenerator.OutputUsage(System.String,System.String)">
            <summary>
            Outputs the usage.
            </summary>
            <param name="rawLine">The raw line.</param>
            <param name="targetExtension">The target extension.</param>
        </member>
        <member name="T:CodeSmith.Engine.DisposableBase">
            <summary>
            A base class that implements <see cref="T:System.IDisposable"/>
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.DisposableBase.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.DisposableBase.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:CodeSmith.Engine.DisposableBase.DisposeManagedResources">
            <summary>
            Disposes the managed resources.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.DisposableBase.DisposeUnmanagedResources">
            <summary>
            Disposes the unmanaged resources.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.DisposableBase.Finalize">
            <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:CodeSmith.Engine.DisposableBase"/> is reclaimed by garbage collection.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.AssemblyResolver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.AssemblyResolver"/> class.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.AssemblyResolver.StartAppDomainResolving">
            <summary>
            Starts listening to the AppDomain.AssemblyResolve event.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.AssemblyResolver.StopAppDomainResolving">
            <summary>
            Stops listening to the AppDomain.AssemblyResolve event.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.AssemblyResolver.IsSatelliteResourceAssembly(System.String)">
            <summary>
            Checks to see if an assembly is a resourced satellite assembly.
            </summary>
            <param name="assembly">the name of the assembly to be checked.</param>
            <returns>True if the Assembly is a Satellite assembly</returns>
        </member>
        <member name="P:CodeSmith.Engine.AssemblyResolver.Current">
            <summary>
            Gets the current instance of FeedbackManager.
            </summary>
            <value>The current instance.</value>
        </member>
        <member name="P:CodeSmith.Engine.AssemblyResolver.UseManagedAssemblyResolver">
            <summary>
            By wrapping this property inside Using block this will turn on and off the assembly resolver to the previous state.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.AssemblyResolver.IsResolving">
            <summary>
            Returns the state of the assembly resolver.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.AssemblyResolver.ResolveItem.op_Implicit(System.String)~CodeSmith.Engine.AssemblyResolver.ResolveItem">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:CodeSmith.Engine.AssemblyResolver.ResolveItem"/>.
            </summary>
            <param name="directory">The directory</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:CodeSmith.Engine.AssemblyResolver.ResolveItem.op_Implicit(CodeSmith.Engine.AssemblyResolver.ResolveItem)~System.String">
            <summary>
            Performs an implicit conversion from <see cref="T:CodeSmith.Engine.AssemblyResolver.ResolveItem"/> to <see cref="T:System.String"/>.
            </summary>
            <param name="item">The ResolveItem object.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCache.GetTemplateCacheDirectory">
            <summary>
            Directory where the template cache files are located.
            </summary>
            <value></value>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCache.GetTemplateCacheDirectory(System.Int32)">
            <summary>
            Directory where the template cache files are located.
            </summary>
            <value></value>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCache.GetTemplateCacheDirectory(System.Int32,System.Boolean)">
            <summary>
            Directory where the template cache files are located.
            </summary>
            <value></value>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCache.Cleanup">
            <summary>
            Cleanup the template cache folder.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCache.Add(CodeSmith.Engine.CodeTemplateCacheItem)">
            <summary>
            Adds the specified item.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCache.Delete(CodeSmith.Engine.CodeTemplateCacheItem)">
            <summary>
            Deletes the specified item.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCache.Get(System.String)">
            <summary>
            Gets the specified template path.
            </summary>
            <param name="templatePath">The template path.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCache.GetCacheItems">
            <summary>
            Gets the cache items.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCache.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.CodeTemplateCache"/> class.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateCache.Instance">
            <summary>
            Gets the current singleton instance of CodeTemplateCache.
            </summary>
            <value>The current singleton instance.</value>
            <remarks>
            An instance of CodeTemplateCache wont be created until the very first
            call to the sealed class. This is a CLR optimization that
            provides a properly lazy-loading singleton.
            </remarks>
        </member>
        <member name="T:CodeSmith.Engine.CodeTemplateCache.Nested">
            <summary>
            Nested class to lazy-load singleton.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCache.Nested.#cctor">
            <summary>
            Initializes the Nested class.
            </summary>
            <remarks>
            Explicit static constructor to tell C# compiler not to mark type as beforefieldinit.
            </remarks>
        </member>
        <member name="F:CodeSmith.Engine.CodeTemplateCache.Nested.Current">
            <summary>
            Current singleton instance.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.CodeTemplateCompiler">
            <summary>
            This class can be used to compile templates.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCompiler.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:CodeSmith.Engine.CodeTemplateCompiler"/> instance.
            </summary>
            <param name="path">Path.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCompiler.#ctor(CodeSmith.Engine.ICodeTemplateInfo)">
            <summary>
            Creates a new <see cref="T:CodeSmith.Engine.CodeTemplateCompiler"/> instance.
            </summary>
            <param name="codeTemplateInfo">Code template info.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCompiler.Compile">
            <summary>
            Compiles the specified template and outputs an assembly to the output path.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCompiler.Compile(System.Boolean)">
            <summary>
            Compiles the specified template and outputs an assembly to the output path.
            </summary>
            <param name="forceRecompile">Force recompile.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCompiler.Compile(System.String)">
            <summary>
            Compiles the specified template and outputs an assembly to the output path.
            </summary>
            <param name="outputPath">Output path.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCompiler.Compile(System.String,System.Boolean)">
            <summary>
            Compiles the specified template and outputs an assembly to the output path.
            </summary>
            <param name="outputPath">Output path.</param>
            <param name="forceRecompile">Force recompile.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCompiler.Compile(System.String,System.Boolean,System.Boolean)">
            <summary>
            Compiles the specified template and outputs an assembly to the output path.
            </summary>
            <param name="outputPath">Output path.</param>
            <param name="forceRecompile">Force recompile.</param>
            <param name="inMemory"></param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCompiler.LoadedTemplateFromCache(System.String)">
            <summary>
            Tries to load a template from the template cache.
            </summary>
            <param name="outputPath">The location of the outputted assembly.</param>
            <returns>True only if the template was loaded from cache.</returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateCompiler.CreateInstance">
            <summary>
            Creates an instance of the compiled template.  You must compile the template first.
            </summary>
            <returns></returns>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateCompiler.CodeTemplateInfo">
            <summary>
            Gets the code template information.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateCompiler.Debug">
            <summary>
            Gets or sets a value indicating whether the template should be compiled in debug mode or not.
            </summary>
            <value>
            	<c>true</c> if debug; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateCompiler.LinePragmas">
            <summary>
            Gets or sets a value indicating whether line pragmas should be output in the compiled source code.
            </summary>
            <value>
            	<c>true</c> if line pragmas should be generated; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateCompiler.KeepTempFiles">
            <summary>
            Gets or sets a value indicating whether the temp files should be kept.
            </summary>
            <value>
            	<c>true</c> if you want to keep the temp files; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateCompiler.Namespace">
            <summary>
            Namespace that the compiled template should be a member of.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateCompiler.TypeName">
            <summary>
            Gets or sets the type name of the compiled template.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateCompiler.CompiledAssembly">
            <summary>
            Provides access to the compiled assembly.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateCompiler.GeneratedAssemblySourceCode">
            <summary>
            Provides access to the generated source code.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateCompiler.Errors">
            <summary>
            Gets the errors.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateCompiler.CompilerOutputWriter">
            <summary>
            Gets or sets the compiler output writer.
            </summary>
            <value></value>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateInfo.GetHashCode">
            <summary>
            Gets the hash code based on the template dependencies.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateInfo.FullPath">
            <summary>
            Gets the full path to the template.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateInfo.FileName">
            <summary>
            Gets the name of the template file.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateInfo.DirectoryName">
            <summary>
            Gets the name of the directory the template is located in.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateInfo.Language">
            <summary>
            Gets the template language.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateInfo.TargetLanguage">
            <summary>
            Gets the target language.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateInfo.TemplateEncoding">
            <summary>
            Gets the response encoding.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateInfo.Description">
            <summary>
            Gets the description.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateInfo.DateCreated">
            <summary>
            Gets the date the template was created.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateInfo.DateModified">
            <summary>
            Gets the date the template was modified.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateInfo.ContentHashCode">
            <summary>
            Gets the hash code based on the template content and all template Dependencies.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateInfo.OutputType">
            <summary>
            Gets the type of the output for this template.
            </summary>
            <value>The type of the output.</value>
        </member>
        <member name="M:CodeSmith.Engine.DirectoryLock.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.DirectoryLock"/> class.
            </summary>
            <param name="directory">The directory.</param>
        </member>
        <member name="M:CodeSmith.Engine.DirectoryLock.AcquireWriterLock(System.Int32)">
            <summary>
            Acquires the writer lock on <see cref="P:CodeSmith.Engine.DirectoryLock.Directory"/>.
            </summary>
            <param name="millisecondsTimeout">The milliseconds timeout.</param>
        </member>
        <member name="M:CodeSmith.Engine.DirectoryLock.AcquireWriterLock(System.TimeSpan)">
            <summary>
            Acquires the writer lock on <see cref="P:CodeSmith.Engine.DirectoryLock.Directory"/>.
            </summary>
            <param name="timeout">The timeout timespan.</param>
        </member>
        <member name="M:CodeSmith.Engine.DirectoryLock.ReleaseWriterLock">
            <summary>
            Releases the writer lock.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.DirectoryLock.Directory">
            <summary>
            Gets the directory.
            </summary>
            <value>The directory.</value>
        </member>
        <member name="T:CodeSmith.Engine.Compiler.ManagedAssemblyResolver">
            <summary>
            Class that allows setting of property values on 
            current business object
            without raising PropertyChanged events
            and checking user rights.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Compiler.ManagedAssemblyResolver.Dispose">
            <summary>
            Disposes the object.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Compiler.ManagedAssemblyResolver.Dispose(System.Boolean)">
            <summary>
            Disposes the object.
            </summary>
            <param name="dispose">Dispose flag.</param>
        </member>
        <member name="M:CodeSmith.Engine.ProjectCodeGenerator.GenerateCodeAsync(System.String)">
            <summary>
            Begin generating code acynronous
            </summary>
            <param name="xmlFilePath">The project file to generate</param>
        </member>
        <member name="M:CodeSmith.Engine.ProjectCodeGenerator.GenerateCode(System.String)">
            <summary>
            Generates a CodeSmith Project file based on the file path to the csp.
            </summary>
            <param name="xmlFilePath">File path to the csp file.</param>
            <returns>true if the csp was generated.</returns>
        </member>
        <member name="M:CodeSmith.Engine.ConfigurationBase.UpgradeFile``1(System.String)">
            <summary>
            Attempts to update configuration from a config file. The version of CodeSmith must be older than CodeSmith 5.1.
            </summary>
            <typeparam name="T">Type of the configuration class.</typeparam>
            <param name="fileName">The config filename.</param>
            <returns>Updated Configuration file if a config file was found.</returns>
        </member>
        <member name="M:CodeSmith.Engine.ConfigurationBase.FindVersions(System.String)">
            <summary>
            Finds all configuration files with a specified name.
            </summary>
            <param name="fileName">Configuration file name.</param>
            <returns>A List of configuration files with the specified file name.</returns>
        </member>
        <member name="M:CodeSmith.Engine.ConfigurationBase.EnsureInitialize">
            <summary>
            This method is here purely to make sure that we don't make a double call to the Initialize method while initializing configuration.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.ActiveSnippetConfiguration.Find(System.String,System.String)">
            <summary>
            Finds the specified alias.
            </summary>
            <param name="alias">The alias.</param>
            <param name="targetExtension">The target extension.</param>
            <returns>The <see cref="T:CodeSmith.Engine.ActiveSnippetMapping"/> instance that match closest to the alias, extension pair.</returns>
        </member>
        <member name="M:CodeSmith.Engine.ActiveSnippetConfiguration.FindSimilar(System.String,System.String)">
            <summary>
            Finds the <see cref="T:CodeSmith.Engine.ActiveSnippetMapping"/> instance that match closest to the alias.
            </summary>
            <param name="partialAlias">The partial alias.</param>
            <param name="targetExtension">The target extension.</param>
            <returns>
            The <see cref="T:CodeSmith.Engine.ActiveSnippetMapping"/> instance that match closest to the alias.
            </returns>
        </member>
        <member name="P:CodeSmith.Engine.ActiveSnippetConfiguration.SnippetMappings">
            <summary>
            A collection of Active Snippet maps.
            </summary>
            <remarks>
            The key for the collection is the alias of the template map.
            </remarks>
        </member>
        <member name="P:CodeSmith.Engine.ActiveSnippetConfiguration.Instance">
            <summary>
            Gets the current singleton instance of Configuration.
            </summary>
            <value>The current singleton instance.</value>
            <remarks>
            An instance of Configuration wont be created until the very first 
            call to the sealed class. This is a CLR optimization that
            provides a properly lazy-loading singleton. 
            </remarks>
        </member>
        <member name="T:CodeSmith.Engine.ActiveSnippetConfiguration.Nested">
            <summary>
            Nested class to lazy-load singleton.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.ActiveSnippetConfiguration.Nested.#cctor">
            <summary>
            Initializes the Nested class.
            </summary>
            <remarks>
            Explicit static constructor to tell C# compiler not to mark type as beforefieldinit.
            </remarks>
        </member>
        <member name="F:CodeSmith.Engine.ActiveSnippetConfiguration.Nested.Current">
            <summary>
            Current singleton instance.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.IIndexed">
            <summary>
            Interface defining an indexed object.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.IIndexed.Index">
            <summary>
            Gets or sets the index.
            </summary>
            <value>The index.</value>
        </member>
        <member name="P:CodeSmith.Engine.ActiveSnippetMapping.Alias">
            <summary>
            Gets or sets the alias.
            </summary>
            <value>The alias.</value>
        </member>
        <member name="P:CodeSmith.Engine.ActiveSnippetMapping.TargetLanguage">
            <summary>
            Gets or sets the target language.
            </summary>
            <value>The target language.</value>
        </member>
        <member name="P:CodeSmith.Engine.ActiveSnippetMapping.TemplateFile">
            <summary>
            Gets or sets the template file.
            </summary>
            <value>The template file.</value>
        </member>
        <member name="P:CodeSmith.Engine.ActiveSnippetMapping.TemplateName">
            <summary>
            Gets or sets the name of the template.
            </summary>
            <value>The name of the template.</value>
        </member>
        <member name="P:CodeSmith.Engine.ActiveSnippetMapping.DisplayName">
            <summary>
            Gets the name of the display.
            </summary>
            <value>The name of the display.</value>
        </member>
        <member name="P:CodeSmith.Engine.ActiveSnippetMapping.Arguments">
            <summary>
            Gets or sets the arguments.
            </summary>
            <value>The arguments.</value>
        </member>
        <member name="P:CodeSmith.Engine.ActiveSnippetMapping.TargetExtensions">
            <summary>
            Gets or sets the target file extensions.
            </summary>
            <value>The target extensions.</value>
        </member>
        <member name="P:CodeSmith.Engine.ActiveSnippetMapping.PropertySet">
            <summary>
            Gets or sets the property set.
            </summary>
            <value>The property set.</value>
        </member>
        <member name="T:CodeSmith.Engine.VirtualCollectionBase`1">
            <summary>
            A base Collection used to load data on depand from database.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
            	<paramref name="array"/> is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is less than zero.
            </exception>
            <exception cref="T:System.ArgumentException">
            	<paramref name="array"/> is multidimensional.
            -or-
            <paramref name="index"/> is equal to or greater than the length of <paramref name="array"/>.
            -or-
            The number of elements in the source <see cref="T:System.Collections.ICollection"/> is greater than the available space from <paramref name="index"/> to the end of the destination <paramref name="array"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            The type of the source <see cref="T:System.Collections.ICollection"/> cannot be cast automatically to the type of the destination <paramref name="array"/>.
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.System#Collections#IList#Add(System.Object)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.IList"/>.
            </summary>
            <param name="value">The <see cref="T:System.Object"/> to add to the <see cref="T:System.Collections.IList"/>.</param>
            <returns>
            The position into which the new element was inserted.
            </returns>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.IList"/> is read-only.
            -or-
            The <see cref="T:System.Collections.IList"/> has a fixed size.
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.System#Collections#IList#Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:System.Collections.IList"/> contains a specific value.
            </summary>
            <param name="value">The <see cref="T:System.Object"/> to locate in the <see cref="T:System.Collections.IList"/>.</param>
            <returns>
            true if the <see cref="T:System.Object"/> is found in the <see cref="T:System.Collections.IList"/>; otherwise, false.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.IList"/>.
            </summary>
            <param name="value">The <see cref="T:System.Object"/> to locate in the <see cref="T:System.Collections.IList"/>.</param>
            <returns>
            The index of <paramref name="value"/> if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.IList"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="value"/> should be inserted.</param>
            <param name="value">The <see cref="T:System.Object"/> to insert into the <see cref="T:System.Collections.IList"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.IList"/>.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.IList"/> is read-only.
            -or-
            The <see cref="T:System.Collections.IList"/> has a fixed size.
            </exception>
            <exception cref="T:System.NullReferenceException">
            	<paramref name="value"/> is null reference in the <see cref="T:System.Collections.IList"/>.
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.IList"/>.
            </summary>
            <param name="value">The <see cref="T:System.Object"/> to remove from the <see cref="T:System.Collections.IList"/>.</param>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.IList"/> is read-only.
            -or-
            The <see cref="T:System.Collections.IList"/> has a fixed size.
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.Add(`0)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <returns>
            true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <returns>
            The index of <paramref name="item"/> if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <returns>
            true if <paramref name="item"/> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1"/> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.GetCount">
            <summary>
            Gets the count.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.GetIndex(`0)">
            <summary>
            Gets the index.
            </summary>
            <param name="item">The item.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.GetItem(System.Int32)">
            <summary>
            Gets the item.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.GetItems">
            <summary>
            Gets the items.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.ClearItems">
            <summary>
            Clears the items.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.AddItem(`0)">
            <summary>
            Adds the item.
            </summary>
            <param name="item">The item.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.InsertItem(System.Int32,`0)">
            <summary>
            Inserts an element into the Collection at the specified index. 
            </summary>
            <param name="index">The zero-based index at which item should be inserted. </param>
            <param name="item">The object to insert. The value can be null (Nothing in Visual Basic) for reference types.</param>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.RemoveItem(System.Int32)">
            <summary>
            Removes the element at the specified index of the Collection. 
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.SetItem(System.Int32,`0)">
            <summary>
            Replaces the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to replace.</param>
            <param name="item">The new value for the element at the specified index. The value can be null (Nothing in Visual Basic) for reference types.</param>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.IsCompatibleObject(System.Object)">
            <summary>
            Determines whether the specified value is compatible with Collection.
            </summary>
            <param name="value">The value to check.</param>
            <returns>
            	<c>true</c> if is a compatible object; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.VirtualCollectionBase`1.VerifyValueType(System.Object)">
            <summary>
            Verifies the type of the value.
            </summary>
            <param name="value">The value to check.</param>
        </member>
        <member name="P:CodeSmith.Engine.VirtualCollectionBase`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is synchronized (thread safe).
            </summary>
            <value></value>
            <returns>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized (thread safe); otherwise, false.
            </returns>
        </member>
        <member name="P:CodeSmith.Engine.VirtualCollectionBase`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <value></value>
            <returns>
            An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"/>.
            </returns>
        </member>
        <member name="P:CodeSmith.Engine.VirtualCollectionBase`1.System#Collections#IList#Item(System.Int32)">
            <summary>
            Gets or sets the <see cref="T:System.Object"/> at the specified index.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.VirtualCollectionBase`1.System#Collections#IList#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </summary>
            <value></value>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.
            </returns>
        </member>
        <member name="P:CodeSmith.Engine.VirtualCollectionBase`1.System#Collections#IList#IsFixedSize">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IList"/> has a fixed size.
            </summary>
            <value></value>
            <returns>true if the <see cref="T:System.Collections.IList"/> has a fixed size; otherwise, false.
            </returns>
        </member>
        <member name="P:CodeSmith.Engine.VirtualCollectionBase`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <value></value>
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:CodeSmith.Engine.VirtualCollectionBase`1.Item(System.Int32)">
            <summary>
            Gets or sets the type T at the specified index.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.VirtualCollectionBase`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </summary>
            <value></value>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.
            </returns>
        </member>
        <member name="P:CodeSmith.Engine.CachedConfiguration.CachedData.UpdateCache">
             <summary>
            
             </summary>
        </member>
        <member name="P:CodeSmith.Engine.CachedConfiguration.CachedData.Value">
            <summary>
            Value to be cached.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Configuration"/> class.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.LoadDefaults">
            <summary>
            This method will safely upgrade the default values for collections and overwrite any directory settings.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.UpgradeRegistry">
            <summary>
            The following method will check the registry and see if an upgrade is needed.
            </summary>
            <returns>Returns true if the registry is up to date; returns false if there is no previous registry version.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.UpdateLinesGenerated(System.String)">
            <summary>
            Updates Lines Generated based off of the passed in string containing source code.
            </summary>
            <param name="generatedCode">Source code.</param>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.GetHoursSaved">
            <summary>
            Returns the numbers of hours saved by using CodeSmith.
            </summary>
            <returns>Returns the numbers of hours saved by using CodeSmith.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.GetMoneySaved">
            <summary>
            Returns the amount of money saved by using CodeSmith.
            </summary>
            <returns>Returns the amount of money saved by using CodeSmith.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.ExtractEmbeddedLicense(System.String,System.Reflection.Assembly)">
            <summary>
            Extracts an embedded license if it was found.
            </summary>
            <param name="filePath">The full path to store the license file.</param>
            <param name="assembly">The assembly that contains the license file.</param>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.SetLicenseAssembly(System.Reflection.Assembly)">
            <summary>
            Checks an assembly for an embedded license.
            </summary>
            <param name="assembly">The assembly with the embedded license.</param>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.ShouldCreateSamples">
            <summary>
            Checks if <see cref="P:CodeSmith.Engine.Configuration.CodeSmithSampleDirectory"/> or <see cref="P:CodeSmith.Engine.Configuration.CodeSmithMapsDirectory"/> are missing.
            </summary>
            <returns>Returns true if the samples need to be extracted</returns>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.CreateDocumentDirectories">
            <summary>
            Creates the document directories by extracting the sample zip files.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.CreateSamplesAsync">
            <summary>
            Extracts the samples on a separate thread.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.CreateMaps">
            <summary>
            Extracts the map files.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.CreateMaps(System.Boolean)">
            <summary>
            Extracts the map files to the My Documents folder.
            </summary>
            <param name="overwrite">If true, it will overwrite preexisting map files.</param>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.ExtractFile(System.String,System.String)">
            <summary>
            Attempts to extract a zip archive.
            </summary>
            <param name="targetDirectory">The directory the zip file should be extracted to.</param>
            <param name="zipFile">The full path to the zip file.</param>
            <returns>true, if the file could be extracted.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.ExtractFile(System.String,System.String,System.Boolean)">
            <summary>
            Attempts to extract a file to the target directory.
            </summary>
            <param name="targetDirectory">Path that the zip file should be extracted to.</param>
            <param name="zipFile">The zip file.</param>
            <param name="overwrite">If true, all files previously existing in the target directory will be overwritten by those in the zip file.</param>
            <returns>true, if the zip file could be extracted to the target directory</returns>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.TrackLinesGenerated">
            <summary>
            Gets or sets a value indicating whether to track lines generated.
            </summary>
            <value><c>true</c> to track lines generated; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.LinesGenerated">
            <summary>
            Gets or sets the number of lines generated.
            </summary>
            <value>The number of lines generated.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.AverageLinesPerHour">
            <summary>
            Gets or sets the average lines per hour.
            </summary>
            <value>The average lines per hour.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.AverageCostPerHour">
            <summary>
            Gets or sets the average cost per hour.
            </summary>
            <value>The average cost per hour.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.ApplicationDirectory">
            <summary>
            Gets or sets the application directory.
            </summary>
            <value>The application directory.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.MergeStrategyAliases">
            <summary>
            Gets the merge strategy aliases.
            </summary>
            <value>The merge strategy aliases.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.LanguageRegionDefinitions">
            <summary>
            Gets the language region definitions.
            </summary>
            <value>The language region definitions.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.PropertyDesignerMaps">
            <summary>
            Gets the property designer maps.
            </summary>
            <value>The property designer maps.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.ConditionalCompilation">
            <summary>
            Gets the conditional compilation statements for the compiler.
            </summary>
            <value>The conditional compilation.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.CodeSmithBaseSampleDirectory">
            <summary>
            Gets or sets the base CodeSmith sample directory.
            </summary>
            <value>The CodeSmith sample directory.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.CodeSmithSampleDirectory">
            <summary>
            Gets or sets the CodeSmith sample directory.
            </summary>
            <value>The CodeSmith sample directory.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.CodeSmithMapsDirectory">
            <summary>
            Gets or sets the CodeSmith maps directory.
            </summary>
            <value>The CodeSmith maps directory.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.CodeSmithTemplatesDirectory">
            <summary>
            Gets or sets the CodeSmith templates directory.
            </summary>
            <value>The CodeSmith templates directory.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.CodeSmithDataDirectory">
            <summary>
            Gets or sets the CodeSmith data directory.
            </summary>
            <value>The CodeSmith data directory.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.TemplateCacheDirectory">
            <summary>
            Gets or sets the template cache directory.
            </summary>
            <value>The template cache directory.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.PropertySetCacheDirectory">
            <summary>
            Gets or sets the property set cache directory.
            </summary>
            <value>The property set cache directory.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.PluralOverridesMapFile">
            <summary>
            Gets or sets the plural overrides map file.
            </summary>
            <value>The plural overrides map file.</value>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.CustomerExperienceImprovementProgramEnabled">
            <summary>
            Controls whether the Customer Experience Improvement Program is enabled.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.IsEmbeddedEntryAssembly">
            <summary>
            Returns true if CodeSmith Explorer, CodeSmith Studio, or Console was not the entry assembly.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.EntryAssemblyName">
            <summary>
            Returns the name of the current Entry Assembly.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.IsExtractingSamples">
            <summary>
            Returns true if files are currently being extracted.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Configuration.Instance">
            <summary>
            Gets the current singleton instance of Configuration.
            </summary>
            <value>The current singleton instance.</value>
            <remarks>
            An instance of Configuration wont be created until the very first
            call to the sealed class. This is a CLR optimization that
            provides a properly lazy-loading singleton.
            </remarks>
        </member>
        <member name="T:CodeSmith.Engine.Configuration.Nested">
            <summary>
            Nested class to lazy-load singleton.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Configuration.Nested.#cctor">
            <summary>
            Initializes the Nested class.
            </summary>
            <remarks>
            Explicit static constructor to tell C# compiler not to mark type as beforefieldinit.
            </remarks>
        </member>
        <member name="F:CodeSmith.Engine.Configuration.Nested.Current">
            <summary>
            Current singleton instance.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.ConfigurationBase`1.LoadSettings">
            <summary>
            Loads this instance.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.ConfigurationBase`1.SaveSettings">
            <summary>
            Saves this instance.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.ConfigurationBase`1.Instance">
            <summary>
            Gets the singleton instance.
            </summary>
            <value>The singleton instance.</value>
        </member>
        <member name="M:CodeSmith.Engine.ConfigurationItemBase.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.ConfigurationItemBase"/> class.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.ConfigurationItemBase.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.ConfigurationItemBase"/> class.
            </summary>
            <param name="index">The index.</param>
        </member>
        <member name="P:CodeSmith.Engine.ConfigurationItemBase.Index">
            <summary>
            Gets or sets the index.
            </summary>
            <value>The index.</value>
        </member>
        <member name="E:CodeSmith.Engine.ConfigurationItemBase.PropertyChanged">
            <summary>
            Occurs when a property value changes.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.Diagnostics.CodeSmithTraceSwitch">
            <summary>
            
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Diagnostics.CodeSmithTraceSwitch.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Diagnostics.CodeSmithTraceSwitch"/> class.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Diagnostics.CodeSmithTraceSwitch.Current">
            <summary>
            Gets the current singleton instance of CodeSmithTraceSwitch.
            </summary>
            <value>The current singleton instance.</value>
            <remarks>
            An instance of CodeSmithTraceSwitch wont be created until the very first 
            call to the sealed class. This is a CLR optimization that
            provides a properly lazy-loading singleton. 
            </remarks>
        </member>
        <member name="T:CodeSmith.Engine.Diagnostics.CodeSmithTraceSwitch.Nested">
            <summary>
            Nested class to lazy-load singleton.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.Diagnostics.CodeSmithTraceSwitch.Nested.Current">
            <summary>
            Current singleton instance.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Insight.MonitorUnhandledExceptions(System.String,System.Boolean)">
            <summary>
            Monitors unhandled exceptions.
            </summary>
            <param name="entryPoint">Adds a tag to the CaseReport with the name of the EntryPoint (E.G. CodeSmithStudio).</param>
            <param name="showDialog">If true, this will show the submit feedback dialog box to the end user. This should always be false for console applications.</param>
        </member>
        <member name="M:CodeSmith.Engine.Insight.Disable">
            <summary>
            Disable's CodeSmith's Error Reporting
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Insight.Register(System.AppDomain)">
            <summary>
            Monitors Unhandled Exceptions for a specific AppDomain.
            </summary>
            <param name="domain">The AppDomain.</param>
        </member>
        <member name="M:CodeSmith.Engine.Insight.Unregister(System.AppDomain)">
            <summary>
            Stops monitoring unhandled exceptions for a specific AppDomain.
            </summary>
            <param name="domain">The AppDomain.</param>
        </member>
        <member name="M:CodeSmith.Engine.Insight.ShowReportDialog(System.Windows.Forms.IWin32Window)">
            <summary>
            Shows a feedback dialog where user can enter in Product feedback.
            </summary>
            <param name="owner"></param>
            <returns>Returns the result of the users decision.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Insight.ShowCrashReportDialog(System.Windows.Forms.IWin32Window,System.Exception)">
            <summary>
            Shows a crash report dialog.
            </summary>
            <param name="owner"></param>
            <param name="ex">The exception.</param>
            <returns>Returns the result of the users decision.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Insight.ShowCrashReportDialog(System.Windows.Forms.IWin32Window,System.Exception,System.Collections.Generic.List{System.String})">
            <summary>
            Shows a crash report dialog.
            </summary>
            <param name="owner"></param>
            <param name="ex">The exception.</param>
            <param name="tags">List of tags to add to the case.</param>
            <returns>Returns the result of the users decision.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Insight.ShowCrashReportDialog(System.Exception)">
            <summary>
            Shows a crash report dialog.
            </summary>
            <param name="ex">The exception.</param>
            <returns>Returns the result of the users decision.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Insight.ShowCrashReportDialog(System.Exception,System.Collections.Generic.List{System.String})">
            <summary>
            Shows a crash report dialog.
            </summary>
            <param name="ex">The exception.</param>
            <param name="tags">List of tags to add to the case.</param>
            <returns>Returns the result of the users decision.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Insight.ShowCrashReportDialog(System.Exception,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Shows a crash report dialog.
            </summary>
            <param name="ex">The exception.</param>
            <param name="description">Report description.</param>
            <param name="tags">List of tags to add to the case.</param>
            <returns>Returns the result of the users decision.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Insight.SendCrashReport(System.String,System.String,System.String)">
            <summary>
            Sends a crash report behind the scenes.
            </summary>
            <param name="title">Title of crash report.</param>
            <param name="description">Report description.</param>
            <param name="exceptionMessage">The exception message.</param>
        </member>
        <member name="M:CodeSmith.Engine.Insight.SendCrashReport(System.String,System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Sends a crash report behind the scenes.
            </summary>
            <param name="title">Title of crash report.</param>
            <param name="description">Report description.</param>
            <param name="exceptionMessage">The exception message.</param>
            <param name="tags">List of tags to add to the case.</param>
        </member>
        <member name="M:CodeSmith.Engine.Insight.SendCrashReport(System.Exception)">
            <summary>
            Sends a crash report behind the scenes.
            </summary>
            <param name="ex">The exception.</param>
        </member>
        <member name="M:CodeSmith.Engine.Insight.SendCrashReport(System.Exception,System.Collections.Generic.List{System.String})">
            <summary>
            Sends a crash report behind the scenes.
            </summary>
            <param name="ex">The exception.</param>
            <param name="tags">List of tags to add to the case.</param>
        </member>
        <member name="M:CodeSmith.Engine.Insight.SendCrashReport(System.Exception,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Sends a crash report behind the scenes.
            </summary>
            <param name="ex">The exception.</param>
            <param name="description">Adds a description to to the case.</param>
            <param name="tags">List of tags to add to the case.</param>
        </member>
        <member name="M:CodeSmith.Engine.Insight.Enable">
            <summary>
            Enable CodeSmith's Error Reporting
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Insight.ShowDialog">
            <summary>
            If true, this will show the submit feedback dialog box to the end user. This should always be false for console applications.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Insight.EntryPoint">
            <summary>
            Sets the name of the Entry Assembly.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.DelimitedStringCollection">
            <summary>
            A collection that provides notifications when items get added, removed, or when the whole list is refreshed. 
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.DelimitedStringCollection"/> class.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.DelimitedStringCollection"/> class.
            </summary>
            <param name="collection">The collection.</param>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.DelimitedStringCollection"/> class.
            </summary>
            <param name="delimitedValues">The delimited values.</param>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.BlockReentrancy">
            <summary>
            Disallows reentrant attempts to change this collection.
            </summary>
            <returns>An IDisposable object that can be used to dispose of the object.</returns>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.CheckReentrancy">
            <summary>
            Checks for reentrant attempts to change this collection.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.ClearItems">
            <summary>
            Removes all elements from the <see cref="T:System.Collections.ObjectModel.Collection`1"/>.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.InsertItem(System.Int32,System.String)">
            <summary>
            Inserts an element into the <see cref="T:System.Collections.ObjectModel.Collection`1"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The object to insert. The value can be null for reference types.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is less than zero.
            -or-
            <paramref name="index"/> is greater than <see cref="P:System.Collections.ObjectModel.Collection`1.Count"/>.
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.Move(System.Int32,System.Int32)">
            <summary>
            Moves the item at the specified index to a new location in the collection.
            </summary>
            <param name="oldIndex">The zero-based index specifying the location of the item to be moved.</param>
            <param name="newIndex">The zero-based index specifying the new location of the item.</param>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.MoveItem(System.Int32,System.Int32)">
            <summary>
            Moves the item at the specified index to a new location in the collection.
            </summary>
            <param name="oldIndex">The zero-based index specifying the location of the item to be moved.</param>
            <param name="newIndex">The zero-based index specifying the new location of the item.</param>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.OnCollectionChanged">
            <summary>
            Raises the CollectionChanged event with the provided arguments.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Raises the PropertyChanged event with the provided arguments.
            </summary>
            <param name="e">The <see cref="T:System.ComponentModel.PropertyChangedEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.OnPropertyChanged(System.String)">
            <summary>
            Raises the PropertyChanged event with the provided arguments.
            </summary>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.RemoveItem(System.Int32)">
            <summary>
            Removes the element at the specified index of the <see cref="T:System.Collections.ObjectModel.Collection`1"/>.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is less than zero.
            -or-
            <paramref name="index"/> is equal to or greater than <see cref="P:System.Collections.ObjectModel.Collection`1.Count"/>.
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.SetItem(System.Int32,System.String)">
            <summary>
            Replaces the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to replace.</param>
            <param name="item">The new value for the element at the specified index. The value can be null for reference types.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is less than zero.
            -or-
            <paramref name="index"/> is greater than <see cref="P:System.Collections.ObjectModel.Collection`1.Count"/>.
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.ToString(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the values.
            </summary>
            <param name="values">The values.</param>
            <param name="delimiter">The delimiter.</param>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.ToString(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the values.
            </summary>
            <param name="values">The values.</param>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.ToArray">
            <summary>
            Returns an array of strings that represents the current collection.
            </summary>
            <returns>An array of strings that represents the current collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.AddDelimited(System.String)">
            <summary>
            Adds the split values from <paramref name="delimitedValues"/> to the collection.
            The string is split using the <see cref="P:CodeSmith.Engine.DelimitedStringCollection.Delimiter"/> property.
            </summary>
            <param name="delimitedValues">The delimited values.</param>
            <returns>The number of values added.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="delimitedValues"/> is null.</exception>
        </member>
        <member name="P:CodeSmith.Engine.DelimitedStringCollection.Delimiter">
            <summary>
            Gets or sets the string delimiter.
            </summary>
            <value>The string delimiter.</value>
        </member>
        <member name="E:CodeSmith.Engine.DelimitedStringCollection.PropertyChanged">
            <summary>
            Occurs when a property value changed.
            </summary>
        </member>
        <member name="E:CodeSmith.Engine.DelimitedStringCollection.CollectionChanged">
            <summary>
            Occurs when the collection changed.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.DelimitedStringCollection.DelimitedStringTypeConverter">
            <summary>
            A type converter for the <see cref="T:CodeSmith.Engine.DelimitedStringCollection"/>.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.DelimitedStringTypeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert an object of the given type to the type of this converter, using the specified context.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext"/> that provides a format context.</param>
            <param name="sourceType">A <see cref="T:System.Type"/> that represents the type you want to convert from.</param>
            <returns>
            true if this converter can perform the conversion; otherwise, false.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.DelimitedStringTypeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert the object to the specified type, using the specified context.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext"/> that provides a format context.</param>
            <param name="destinationType">A <see cref="T:System.Type"/> that represents the type you want to convert to.</param>
            <returns>
            true if this converter can perform the conversion; otherwise, false.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.DelimitedStringTypeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Converts the given object to the type of this converter, using the specified context and culture information.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext"/> that provides a format context.</param>
            <param name="culture">The <see cref="T:System.Globalization.CultureInfo"/> to use as the current culture.</param>
            <param name="value">The <see cref="T:System.Object"/> to convert.</param>
            <returns>
            An <see cref="T:System.Object"/> that represents the converted value.
            </returns>
            <exception cref="T:System.NotSupportedException">
            The conversion cannot be performed.
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.DelimitedStringCollection.DelimitedStringTypeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Converts the given value object to the specified type, using the specified context and culture information.
            </summary>
            <param name="context">An <see cref="T:System.ComponentModel.ITypeDescriptorContext"/> that provides a format context.</param>
            <param name="culture">A <see cref="T:System.Globalization.CultureInfo"/>. If null is passed, the current culture is assumed.</param>
            <param name="value">The <see cref="T:System.Object"/> to convert.</param>
            <param name="destinationType">The <see cref="T:System.Type"/> to convert the <paramref name="value"/> parameter to.</param>
            <returns>
            An <see cref="T:System.Object"/> that represents the converted value.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="destinationType"/> parameter is null.
            </exception>
            <exception cref="T:System.NotSupportedException">
            The conversion cannot be performed.
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.IConfiguration.LoadDefaultSettings">
            <summary>
            Loads the default settings.
            </summary>
            <remarks>
            This method is called when existing config file is not 
            found.  Use this method to populate the configuration 
            class with default values.
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.IConfiguration.UpgradeFile(System.IO.FileInfo@)">
            <summary>
            Upgrades the file.
            </summary>
            <param name="file">The file to upgrade.</param>
            <remarks>
            This method is called just before loading a previous config 
            file. Use this method to modify the file before it is loaded.
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.IConfiguration.UpgradeSettings">
            <summary>
            Upgrades the settings.
            </summary>
            <remarks>
            This method is called after loading a previous config file. 
            Use this method to change any existing configurations to
            work with the latest version.
            </remarks>
        </member>
        <member name="P:CodeSmith.Engine.IConfiguration.CanWatchFile">
            <summary>
            Gets a value indicating whether this instance can watch file.
            </summary>
            <value>
            	<c>true</c> if this instance can watch file; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:CodeSmith.Engine.IConfiguration.ConfigurationFile">
            <summary>
            Gets the configuration file.
            </summary>
            <value>The configuration file.</value>
        </member>
        <member name="P:CodeSmith.Engine.IConfiguration.IsBackwardCompatible">
            <summary>
            Gets a value indicating whether this configuration is backward compatible.
            </summary>
            <value>
            	<c>true</c> if this configuration is backward compatible; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:CodeSmith.Engine.IConfiguration.ConfigurationVersion">
            <summary>
            Gets or sets the configuration version.
            </summary>
            <value>The configuration version.</value>
        </member>
        <member name="P:CodeSmith.Engine.LanguageRegionDefinition.LanguageKeys">
            <summary>
            Gets the list of language keys for the region defintion.
            </summary>
            <value>The language keys.</value>
        </member>
        <member name="P:CodeSmith.Engine.LanguageRegionDefinition.RegionStartRegex">
            <summary>
            Gets or sets the region start regex.
            </summary>
            <value>The region start regex.</value>
        </member>
        <member name="P:CodeSmith.Engine.LanguageRegionDefinition.RegionEndRegex">
            <summary>
            Gets or sets the region end regex.
            </summary>
            <value>The region end regex.</value>
        </member>
        <member name="P:CodeSmith.Engine.MergeStrategyAlias.Name">
            <summary>
            Gets or sets the name of the merge strategy alias.
            </summary>
            <value>The merge strategy alias name.</value>
        </member>
        <member name="P:CodeSmith.Engine.MergeStrategyAlias.TypeName">
            <summary>
            Gets or sets the fully qualified type name for the merge strategy.
            </summary>
            <value>The name of the type.</value>
        </member>
        <member name="P:CodeSmith.Engine.PropertyDesignerMap.DataTypes">
            <summary>
            Gets the list of data types the designer should be used for.
            </summary>
            <value>The data types.</value>
        </member>
        <member name="P:CodeSmith.Engine.PropertyDesignerMap.EditorType">
            <summary>
            Gets or sets the type of the editor.
            </summary>
            <value>The type of the editor.</value>
        </member>
        <member name="P:CodeSmith.Engine.PropertyDesignerMap.SerializerType">
            <summary>
            Gets or sets the type of the serializer.
            </summary>
            <value>The type of the serializer.</value>
        </member>
        <member name="T:CodeSmith.Engine.CodeTemplate">
            <summary>
            All templates must derive from this class.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.OnInit">
            <summary>
            This method can be overridden to perform logic when the template instance is created.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.SetPropertyDefaults">
            <summary>
            This method is overridden in templates to set default values in a template instance.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.SetUnknownDirectiveAttributes">
            <summary>
            This method is overridden in templates to set unknown directive attributes in the ContextData.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.OnPreRender">
            <summary>
            This method can be overridden to perform logic before the template is rendered.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.OnError(System.Exception)">
            <summary>
            This method can be overridden to perform logic when a template exception occurs.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.OnPropertyChanged(System.String)">
            <summary>
            This method can be overridden to perform logic when a property changes.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.Render(System.IO.TextWriter)">
            <summary>
            Renders to the template output to the specified writer.
            </summary>
            <param name="writer">Writer.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.OnPostRender(System.String)">
            <summary>
            This method can be overridden to perform logic after the template is rendered.
            </summary>
            <param name="result">The template output.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.RenderToString">
            <summary>
            Renders the template output to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.RenderToString(System.String,CodeSmith.Engine.IMergeStrategy)">
            <summary>
            Renders the template output to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.RenderToFile(System.String,System.Boolean)">
            <summary>
            Renders the template output to a file.
            </summary>
            <param name="path">The output file path.</param>
            <param name="overwrite">if set to <c>true</c> overwrite file.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.RenderToFile(System.String,System.String,System.Boolean)">
            <summary>
            Renders the template output to a file.
            </summary>
            <param name="path">The output file path.</param>
            <param name="dependentUpon">The file that the output is dependent upon.</param>
            <param name="overwrite">if set to <c>true</c> overwrite file.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.RenderToFile(CodeSmith.Engine.OutputFile,System.Boolean)">
            <summary>
            Renders the template output to a file.
            </summary>
            <param name="outputFile">The output file.</param>
            <param name="overwrite">if set to <c>true</c> overwrite file.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.RenderToFile(System.String,CodeSmith.Engine.IMergeStrategy)">
            <summary>
            Renders the template output to a file using a merge strategy.
            </summary>
            <param name="path">The output path.</param>
            <param name="strategy">The merge strategy to use.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.RenderToFile(System.String,System.String,CodeSmith.Engine.IMergeStrategy)">
            <summary>
            Renders the template output to a file using a merge strategy.
            </summary>
            <param name="path">The output path.</param>
            <param name="strategy">The merge strategy to use.</param>
            <param name="sourcePath">The source file to base the merge on.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.RenderToFile(CodeSmith.Engine.OutputFile,System.String,CodeSmith.Engine.IMergeStrategy)">
            <summary>
            Renders the template output to a file using a merge strategy.
            </summary>
            <param name="outputFile">The output file.</param>
            <param name="strategy">The merge strategy to use.</param>
            <param name="sourcePath">The source file to base the merge on.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.Validate">
            <summary>
            Validates this template instance.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.GetFileName">
            <summary>
            Gets a default name for the template output.  This can be overriden in your template to provide a suitable name for the output of the template based on the property values.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.SetContextData(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Set the context data object for the template.
            Any items in the current ContextData object will be added to the new one.
            This method should only be called while a template is initializing.
            </summary>
            <param name="contextData">The context data object.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.ParseDefaultValue(System.Reflection.PropertyInfo,System.String)">
            <summary>
            Parses the default value for properties.  This can be overridden to provide custom default parsing logic.
            </summary>
            <param name="targetProperty">Target property.</param>
            <param name="defaultValue">Default value.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.GetPropertyAttribute(System.String,System.String)">
            <summary>
            Gets the property attribute.  Property attributes can be used to store various information at the property level.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="attributeName">Name of the attribute.</param>
            <returns>The value of the attribute</returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.SetPropertyAttribute(System.String,System.String,System.String)">
            <summary>
            Sets the property attribute.  Property attributes can be used to store various information at the property level.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="attributeName">Name of the attribute.</param>
            <param name="attributeValue">The attribute value.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.GetTemplateAttribute(System.String)">
            <summary>
            Gets the template attribute.  Template attributes can be used to store various information at the template level.
            </summary>
            <param name="attributeName">Name of the attribute.</param>
            <returns>The value of the attribute</returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.SetTemplateAttribute(System.String,System.String)">
            <summary>
            Sets the template attribute.  Template attributes can be used to store various information at the template level.
            </summary>
            <param name="attributeName">Name of the attribute.</param>
            <param name="attributeValue">The attribute value.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.GetProperties">
            <summary>
            Gets information on all of the properties on this template.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.GetProperties(System.Boolean)">
            <summary>
            Gets information on all of the properties on this template.
            </summary>
            <param name="includeNonBrowsable">Whether non-browsable properties should be included.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.GetRequiredProperties">
            <summary>
            Gets information on all of the required properties for this template.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.SavePropertiesToHashtable">
            <summary>
            Saves the properties to a Hashtable.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.SavePropertiesToHashtable(System.Boolean)">
            <summary>
            Saves the properties to a Hashtable.
            </summary>
            <returns></returns>
            <param name="includeNonBrowsable">Whether non-browsable properties should be included.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.RestorePropertiesFromHashtable(System.Collections.Hashtable)">
            <summary>
            Restores the properties from a Hashtable.
            </summary>
            <param name="properties">Properties.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.SavePropertiesToXmlFile(System.String)">
            <summary>
            Saves the properties to an XML file.
            </summary>
            <param name="xmlFilePath">XML file path.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.CopyPropertiesTo(CodeSmith.Engine.CodeTemplate)">
            <summary>
            Copies any matching properties to another CodeTemplate instance.
            </summary>
            <param name="template">Template.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.CopyPropertiesTo(CodeSmith.Engine.CodeTemplate,System.Boolean)">
            <summary>
            Copies any matching properties to another CodeTemplate instance.
            </summary>
            <param name="template">Template.</param>
            <param name="includeNonBrowsable">Whether non-browsable properties should be included.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.RestorePropertiesFromXmlFile(System.String)">
            <summary>
            Restores the properties from XML file.
            </summary>
            <param name="xmlFilePath">XML file path.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.SavePropertiesToXml(System.Xml.XmlWriter)">
            <summary>
            Saves the properties to XML.
            </summary>
            <param name="xmlWriter">XmlWriter.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.SavePropertiesToXml">
            <summary>
            Saves the properties to XML.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.RestorePropertiesFromXml(System.String,System.String)">
            <summary>
            Restores the properties from XML.
            </summary>
            <param name="xmlFragment">The XML fragment.</param>
            <param name="baseDirectory">The base directory to resolve file references.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.SetProperty(System.String,System.Object)">
            <summary>
            Sets the value for the specified property.
            </summary>
            <param name="name">Property name.</param>
            <param name="value">Value to assign.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.SetProperty(System.Reflection.PropertyInfo,System.Object)">
            <summary>
            Sets the value for the specified property.
            </summary>
            <param name="propertyInfo">Information about the target property.</param>
            <param name="value">Value to assign.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.GetProperty(System.String)">
            <summary>
            Gets the value for the specified property.
            </summary>
            <param name="name">Property name.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.GetCodeTemplateInstance(System.String)">
            <summary>
            Gets an instance of the specified template.
            </summary>
            <param name="templatePath">Path to the template.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.GetCodeTemplateInstance(System.String,System.Boolean)">
            <summary>
            Gets an instance of the specified template.
            </summary>
            <param name="templatePath">Path to the template.</param>
            <param name="forceRecompile">Forces the template to be recompiled instead of using the cache.</param>
            <returns>The CodeTemplate instance.</returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.GetCodeTemplateInstance(System.String,System.Boolean,System.Boolean)">
            <summary>
            Gets an instance of the specified template.
            </summary>
            <param name="templatePath">Path to the template.</param>
            <param name="forceRecompile">Forces the template to be recompiled instead of using the cache.</param>
            <param name="shareContextData">Share template context data with the child template instance.</param>
            <returns>The CodeTemplate instance.</returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.OnOutputRegistered(CodeSmith.Engine.OutputRegisteredEventArgs)">
            <summary>
                This is the method that is responsible for notifying
                receivers that the event occurred
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.OnPreOutputWritten(CodeSmith.Engine.OutputCancelEventArgs)">
            <summary>
                This is the method that is responsible for notifying
                receivers that the event occurred
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.OnPreOutputWritten(System.String)">
            <summary>
                This is the method that is responsible for notifying
                receivers that the event occurred
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.OnReferenceRegistered(CodeSmith.Engine.ItemRegisteredEventArgs)">
            <summary>
            Raises the <see cref="E:ReferenceRegistered"/> event.
            </summary>
            <param name="e">The <see cref="T:CodeSmith.Engine.ItemRegisteredEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.RegisterReference(System.String)">
            <summary>
            Registers the reference.
            </summary>
            <param name="referenceName">Name of the reference.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.Create``1">
            <summary>
            Gets an instance of the specified template type.  Should be used with the Register directive.
            </summary>
            <returns>The CodeTemplate instance.</returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplate.Create``1(System.Boolean)">
            <summary>
            Gets an instance of the specified template type.  Should be used with the Register directive.
            </summary>
            <param name="shareContextData">Share template context data with the child template instance.</param>
            <returns>The CodeTemplate instance.</returns>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplate.Response">
            <summary>
            Response stream for the template output.  You can write to the stream programmatically using this property.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplate.Progress">
            <summary>
            Provides a way to report execution progress for the template.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplate.State">
            <summary>
            State of this template instance.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplate.CodeTemplateInfo">
            <summary>
            Gets the information for the current template.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplate.ValidationErrors">
            <summary>
            Gets the validation errors for this template.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplate.ContextData">
            <summary>
            Contextual data items can be stored in this object and shared with sub-templates.  This data will not be persisted with the template property set.
            </summary>
        </member>
        <member name="E:CodeSmith.Engine.CodeTemplate.OutputRegistered">
            <summary>
                Raised when an output file is registered
            </summary>
        </member>
        <member name="E:CodeSmith.Engine.CodeTemplate.PreOutputWritten">
            <summary>
                Raised prior to an output being written to disk
            </summary>
        </member>
        <member name="E:CodeSmith.Engine.CodeTemplate.ReferenceRegistered">
            <summary>
            Occurs when a reference is registered.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeTemplateWriter.Indent">
            <summary>
            Increments the IndentLevel by one.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateWriter.IndentLevel">
            <summary>
            The number of tabs or spaces the generated output should indent.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.CodeTemplateWriter.IndentValue">
            <summary>
            This value is outputted once for each Indent Level. IndentValue defaults to one tab.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.OutputFile">
            <summary>
            A class representing a template output file.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.OutputFile.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.OutputFile"/> class.
            </summary>
            <param name="outputFile">The output file.</param>
        </member>
        <member name="M:CodeSmith.Engine.OutputFile.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.OutputFile"/> class.
            </summary>
            <param name="outputFile">The output file.</param>
            <param name="metadata">The metadata.</param>
        </member>
        <member name="M:CodeSmith.Engine.OutputFile.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.OutputFile"/> class.
            </summary>
            <param name="outputFile">The output file.</param>
            <param name="dependentUpon">The file that output is dependent upon.</param>
        </member>
        <member name="M:CodeSmith.Engine.OutputFile.#ctor(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.OutputFile"/> class.
            </summary>
            <param name="outputFile">The output file.</param>
            <param name="dependentUpon">The file that output is dependent upon.</param>
            <param name="metadata">The metadata.</param>
        </member>
        <member name="M:CodeSmith.Engine.OutputFile.op_Implicit(System.String)~CodeSmith.Engine.OutputFile">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:CodeSmith.Engine.OutputFile"/>.
            </summary>
            <param name="outputFile">The output file.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:CodeSmith.Engine.OutputFile.op_Implicit(CodeSmith.Engine.OutputFile)~System.String">
            <summary>
            Performs an implicit conversion from <see cref="T:CodeSmith.Engine.OutputFile"/> to <see cref="T:System.String"/>.
            </summary>
            <param name="outputFile">The output file.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="P:CodeSmith.Engine.OutputFile.OutputFileName">
            <summary>
            Gets the name of the output file.
            </summary>
            <value>The name of the output file.</value>
        </member>
        <member name="P:CodeSmith.Engine.OutputFile.DependentUpon">
            <summary>
            Gets or sets the dependent upon file.
            </summary>
            <value>The dependent upon file.</value>
        </member>
        <member name="P:CodeSmith.Engine.OutputFile.Metadata">
            <summary>
            Gets the metadata.
            </summary>
            <value>The metadata.</value>
        </member>
        <member name="T:CodeSmith.Engine.ItemRegisteredEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.ItemRegisteredEventArgs.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.ItemRegisteredEventArgs"/> class.
            </summary>
            <param name="itemName">Name of the item.</param>
        </member>
        <member name="P:CodeSmith.Engine.ItemRegisteredEventArgs.ItemName">
            <summary>
            Gets or sets the name of the item.
            </summary>
            <value>The name of the item.</value>
        </member>
        <member name="T:CodeSmith.Engine.OutputCancelEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.OutputRegisteredEventArgs">
            <summary>
                EventArgs derived type which holds the custom event fields
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.OutputRegisteredEventArgs.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.OutputRegisteredEventArgs"/> class.
            </summary>
            <param name="outputFile">The output file.</param>
        </member>
        <member name="M:CodeSmith.Engine.OutputRegisteredEventArgs.#ctor(CodeSmith.Engine.OutputFile)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.OutputRegisteredEventArgs"/> class.
            </summary>
            <param name="outputFile">The output file.</param>
        </member>
        <member name="P:CodeSmith.Engine.OutputRegisteredEventArgs.OutputFile">
            <summary>
            Gets or sets the output file.
            </summary>
            <value>The output file.</value>
        </member>
        <member name="M:CodeSmith.Engine.OutputCancelEventArgs.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.OutputCancelEventArgs"/> class.
            </summary>
            <param name="outputFile"></param>
        </member>
        <member name="M:CodeSmith.Engine.OutputCancelEventArgs.#ctor(CodeSmith.Engine.OutputFile)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.OutputCancelEventArgs"/> class.
            </summary>
            <param name="outputFile">The output file.</param>
        </member>
        <member name="P:CodeSmith.Engine.OutputCancelEventArgs.Cancel">
            <summary>
            Gets or sets a value indicating whether this output is canceled
            </summary>
            <value><c>true</c> if cancel; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:CodeSmith.Engine.OutputCancelEventHandler">
            <summary>
                This represents the delegate method prototype that
                event receivers must implement
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.OutputRegisteredEventHandler">
            <summary>
                This represents the delegate method prototype that
                event receivers must implement
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.Progress">
            <summary>
            Progress information.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Progress.PerformStep">
            <summary>
            Performs a progress step.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Progress.Increment(System.Int32)">
            <summary>
            Increments the current progress value by the specified amount.
            </summary>
            <param name="value">Value.</param>
        </member>
        <member name="E:CodeSmith.Engine.Progress.OnProgress">
            <summary>
            Occurs when the progress value has been changed.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Progress.MinimumValue">
            <summary>
            Minimum progress value.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Progress.MaximumValue">
            <summary>
            Maximum progress value.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Progress.Value">
            <summary>
            Gets or sets the current progress value.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.Progress.Step">
            <summary>
            Gets or sets the step increment value.
            </summary>
            <value></value>
        </member>
        <member name="T:CodeSmith.Engine.ValidationError">
            <summary>
            Provides information about a template validation error.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.GeneratorCompleteEventArgs">
            <summary>
                EventArgs derived type which holds the custom event fields
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.GeneratorCompleteEventArgs.#ctor(System.Boolean,System.Collections.ObjectModel.ReadOnlyCollection{CodeSmith.Engine.OutputFile})">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.GeneratorCompleteEventArgs"/> class.
            </summary>
            <param name="result">if set to <c>true</c> generation was successful.</param>
            <param name="registeredOutputs">The registered outputs.</param>
        </member>
        <member name="M:CodeSmith.Engine.GeneratorCompleteEventArgs.#ctor(System.Boolean,System.Collections.ObjectModel.ReadOnlyCollection{CodeSmith.Engine.OutputFile},System.Collections.ObjectModel.ReadOnlyCollection{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.GeneratorCompleteEventArgs"/> class.
            </summary>
            <param name="result">if set to <c>true</c> [result].</param>
            <param name="registeredOutputs">The registered outputs.</param>
            <param name="registeredReferences">The registered references.</param>
        </member>
        <member name="M:CodeSmith.Engine.GeneratorCompleteEventArgs.#ctor(System.Boolean,System.Collections.ObjectModel.ReadOnlyCollection{CodeSmith.Engine.OutputFile},System.Collections.ObjectModel.ReadOnlyCollection{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.GeneratorCompleteEventArgs"/> class.
            </summary>
            <param name="result">if set to <c>true</c> [result].</param>
            <param name="registeredOutputs">The registered outputs.</param>
            <param name="registeredReferences">The registered references.</param>
            <param name="cspFileName">The file path of the CodeSmith project file.</param>
        </member>
        <member name="M:CodeSmith.Engine.GeneratorCompleteEventArgs.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.GeneratorCompleteEventArgs"/> class.
            </summary>
            <param name="error">The error.</param>
        </member>
        <member name="T:CodeSmith.Engine.GeneratorCompleteEventHandler">
            <summary>
                This represents the delegate method prototype that
                event receivers must implement
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.GeneratorErrorEventArgs">
            <summary>
                EventArgs derived type which holds the custom event fields
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.GeneratorErrorEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
                Use this constructor to initialize the event arguments
                object with the custom event fields
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.GeneratorErrorEventHandler">
            <summary>
                This represents the delegate method prototype that
                event receivers must implement
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.GeneratorProgressEventHandler">
            <summary>
                This represents the delegate method prototype that
                event receivers must implement
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.MessageEventArgs">
            <summary>
                EventArgs derived type which holds the custom event fields
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.MessageEventArgs.#ctor(System.String)">
            <summary>
                Use this constructor to initialize the event arguments
                object with the custom event fields
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.MessageEventHandler">
            <summary>
                This represents the delegate method prototype that
                event receivers must implement
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.GeneratorProgressEventArgs">
            <summary>
                EventArgs derived type which holds the custom event fields
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.GeneratorProgressEventArgs.#ctor(System.Int32,System.Int32)">
            <summary>
                Use this constructor to initialize the event arguments
                object with the custom event fields
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeSmithLicense.CheckForFeaturesNotAllowed">
            <summary>
            This method checks to see if you are using invalid features of CodeSmith.
            E.G. You are using CodeSmith Professional and register a CodeSmith Standard Key.
                 This will cause CodeSmith Generator Studio to close.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.TrialRegistrationPanel.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:CodeSmith.Engine.Map.GetMapFiles">
            <summary>
            Gets the map files.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.Map.Load(System.String)">
            <summary>
            Loads the specified name.
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.Map.TryResolvePath(System.String,System.String,System.String@)">
            <summary>
            Tries the resolve path.
            </summary>
            <param name="mapName">Name of the map.</param>
            <param name="baseDirectory">The base directory.</param>
            <param name="fullPath">The full path.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.MapCollection"/> class.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.MapCollection"/> class.
            </summary>
            <param name="caseSensitive">Whether map lookups should be case sensitive or not.</param>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.MapCollection"/> class.
            </summary>
            <param name="mapFileName">Name of the map file.</param>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.MapCollection"/> class.
            </summary>
            <param name="mapFileName">Name of the map file.</param>
            <param name="reverse">if set to <c>true</c> the key and value will be reversed.</param>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.#ctor(System.String,System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.MapCollection"/> class.
            </summary>
            <param name="mapFileName">Name of the map file.</param>
            <param name="reverse">if set to <c>true</c> the key and value will be reversed.</param>
            <param name="defaultValue">The default value.</param>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.Save(System.String)">
            <summary>
            Saves the specified map file name.
            </summary>
            <param name="mapFileName">Name of the map file.</param>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.Load(System.String)">
            <summary>
            Loads the specified map file name.
            </summary>
            <param name="mapFileName">Name of the map file.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.Load(System.String,System.Boolean)">
            <summary>
            Loads the specified map file name.
            </summary>
            <param name="mapFileName">Name of the map file.</param>
            <param name="reverse">if set to <c>true</c> [reverse].</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.Add(System.String,System.String)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"></see> is read-only.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.</exception>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.ContainsKey(System.String)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2"></see> contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.</param>
            <returns>
            true if the <see cref="T:System.Collections.Generic.IDictionary`2"></see> contains an element with the key; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.ContainsValue(System.String)">
            <summary>
            Determines whether the specified value contains value.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	<c>true</c> if the specified value contains value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.Remove(System.String)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            true if the element is successfully removed; otherwise, false.  This method also returns false if key was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </returns>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"></see> is read-only.</exception>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.TryGetValue(System.String,System.String@)">
            <summary>
            Tries the get value.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing.</param>
            <param name="index">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">array is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero. </exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or- index is equal to or greater than the length of array.-or- The number of elements in the source <see cref="T:System.Collections.ICollection"></see> is greater than the available space from index to the end of the destination array. </exception>
            <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ICollection"></see> cannot be cast automatically to the type of the destination array. </exception>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
            <param name="key">The <see cref="T:System.Object"></see> to use as the key of the element to add.</param>
            <param name="value">The <see cref="T:System.Object"></see> to use as the value of the element to add.</param>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.IDictionary"></see> object. </exception>
            <exception cref="T:System.ArgumentNullException">key is null. </exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> is read-only.-or- The <see cref="T:System.Collections.IDictionary"></see> has a fixed size. </exception>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only. </exception>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary"></see> object contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary"></see> object.</param>
            <returns>
            true if the <see cref="T:System.Collections.IDictionary"></see> contains an element with the key; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException">key is null. </exception>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator"></see> object for the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator"></see> object for the <see cref="T:System.Collections.IDictionary"></see> object.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> object is read-only.-or- The <see cref="T:System.Collections.IDictionary"></see> has a fixed size. </exception>
            <exception cref="T:System.ArgumentNullException">key is null. </exception>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.OnDeserialization(System.Object)">
            <summary>
            Runs when the entire object graph has been deserialized.
            </summary>
            <param name="sender">The object that initiated the callback. The functionality for this parameter is not currently implemented.</param>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> with the data needed to serialize the target object.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> to populate with data.</param>
            <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext"></see>) for this serialization.</param>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission. </exception>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String@System#String}}#Add(System.Collections.Generic.KeyValuePair{System.String,System.String})">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.</exception>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String@System#String}}#Contains(System.Collections.Generic.KeyValuePair{System.String,System.String})">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> contains a specific value.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <returns>
            true if item is found in the <see cref="T:System.Collections.Generic.ICollection`1"></see>; otherwise, false.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String@System#String}}#CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.String}[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or-arrayIndex is equal to or greater than the length of array.-or-The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"></see> is greater than the available space from arrayIndex to the end of the destination array.-or-Type T cannot be cast automatically to the type of the destination array.</exception>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String@System#String}}#Remove(System.Collections.Generic.KeyValuePair{System.String,System.String})">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <returns>
            true if item was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"></see>; otherwise, false. This method also returns false if item is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </returns>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.</exception>
        </member>
        <member name="M:CodeSmith.Engine.MapCollection.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{System#String@System#String}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.FileName">
            <summary>
            Gets the name of the file.
            </summary>
            <value>The name of the file.</value>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.CaseSensitive">
            <summary>
            Wether the map lookups should be case Sensitive.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.Description">
            <summary>
            Gets or sets the description.
            </summary>
            <value>The description.</value>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.Reversed">
            <summary>
            Gets a value indicating whether this <see cref="T:CodeSmith.Engine.MapCollection"/> key value pair is reversed.
            </summary>
            <value><c>true</c> if reversed; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.ReturnKeyWhenNotFound">
            <summary>
            Gets or sets a value indicating whether to return the key when its not found in the collection.
            </summary>
            <value><c>true</c> to return the key; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.DefaultValue">
            <summary>
            Gets or sets the default value for when the key is not found.
            </summary>
            <value>The default value.</value>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            <value></value>
            <returns>An <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"></see>.</returns>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            <value></value>
            <returns>An <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"></see>.</returns>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.Item(System.String)">
            <summary>
            Gets or sets the <see cref="T:System.String"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.Item(System.String,System.String)">
            <summary>
            Gets the <see cref="T:System.String"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            <value></value>
            <returns>The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</returns>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe).
            </summary>
            <value></value>
            <returns>true if access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe); otherwise, false.</returns>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
            <value></value>
            <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.</returns>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.System#Collections#IDictionary#IsFixedSize">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object has a fixed size.
            </summary>
            <value></value>
            <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object has a fixed size; otherwise, false.</returns>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.System#Collections#IDictionary#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.
            </summary>
            <value></value>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only; otherwise, false.</returns>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.System#Collections#IDictionary#Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            <value></value>
            <returns>An <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"></see>.</returns>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.System#Collections#IDictionary#Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            <value></value>
            <returns>An <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"></see>.</returns>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            Gets or sets the <see cref="T:System.Object"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.MapCollection.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#String@System#String}}#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.
            </summary>
            <value></value>
            <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only; otherwise, false.</returns>
        </member>
        <member name="T:CodeSmith.Engine.IMergeStrategy">
            <summary>
            This interface can be implemented to create a merge strategy.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.IMergeStrategy.Init(System.String)">
            <summary>
            Initialize the merge strategy by passing in an initialization string.
            </summary>
            <param name="init">Initialization string.</param>
        </member>
        <member name="M:CodeSmith.Engine.IMergeStrategy.Merge(CodeSmith.Engine.CodeTemplate,System.String,System.String)">
            <summary>
            Merge the template output with the existing content.
            </summary>
            <param name="context">A reference to the CodeTemplate object that called the merge strategy.</param>
            <param name="sourceContent">The source content for the merge.</param>
            <param name="templateOutput">The template output that should be merged into the source.</param>
            <returns></returns>
        </member>
        <member name="T:CodeSmith.Engine.InsertRegionMergeStrategy">
            <summary>
            This merge strategy can be used to insert the template output into a named region inside an existing file
            and preserve the rest of the content in the file.  The initialization string should be of the format:
            "RegionName=&lt;RegionName&gt;;Language=&lt;Language&gt;"
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PreserveRegionsMergeStrategy">
            <summary>
            This merge strategy can be used to preserve designated custom regions inside an existing file and
            regenerate the rest of the content in the file.  The initialization string should be of the format:
            "RegionNameRegex=&lt;RegexExpression&gt;;Language=&lt;Language&gt;"
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.Parser.BuilderCollection">
            <summary>
            Implements a strongly typed collection of <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> elements.
            </summary>
            <remarks><para>
            <b>BuilderCollection</b> provides an <see cref="T:System.Collections.ArrayList"/>
            that is strongly typed for <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> elements.
            </para></remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.#ctor">
            <overloads>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> class.
            </overloads>
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> class
            that is empty and has the default initial capacity.
            </summary>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.#ctor"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> class
            that is empty and has the specified initial capacity.
            </summary>
            <param name="capacity">The number of elements that the new
            <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is initially capable of storing.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="capacity"/> is less than zero.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.#ctor(System.Int32)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.#ctor(CodeSmith.Engine.Parser.BuilderCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> class
            that contains elements copied from the specified collection and
            that has the same initial capacity as the number of elements copied.
            </summary>
            <param name="collection">The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>
            whose elements are copied to the new collection.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="collection"/> is a null reference.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.#ctor(CodeSmith.Engine.Parser.IBuilder[])">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> class
            that contains elements copied from the specified <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>
            array and that has the same initial capacity as the number of elements copied.
            </summary>
            <param name="array">An <see cref="T:System.Array"/> of <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>
            elements that are copied to the new collection.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="array"/> is a null reference.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.#ctor(System.Collections.ICollection)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.Add(CodeSmith.Engine.Parser.IBuilder)">
            <summary>
            Adds a <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> to the end of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <param name="value">The <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> object
            to be added to the end of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            This argument can be a null reference.
            </param>
            <returns>The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> index at which the
            <paramref name="value"/> has been added.</returns>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> has a fixed size.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> already contains the specified
            <paramref name="value"/>, and the <b>BuilderCollection</b>
            ensures that all elements are unique.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Add(System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.System#Collections#IList#Add(System.Object)">
            <summary>
            Adds an <see cref="T:System.Object"/> to the end of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <param name="value">
            The object to be added to the end of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            This argument must be compatible with <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>.
            This argument can be a null reference.
            </param>
            <returns>The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> index at which the
            <paramref name="value"/> has been added.</returns>
            <exception cref="T:System.InvalidCastException"><paramref name="value"/>
            is not compatible with <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>.</exception>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> has a fixed size.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> already contains the specified
            <paramref name="value"/>, and the <b>BuilderCollection</b>
            ensures that all elements are unique.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Add(System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.AddRange(CodeSmith.Engine.Parser.BuilderCollection)">
            <overloads>
            Adds a range of elements to the end of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </overloads>
            <summary>
            Adds the elements of another collection to the end of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <param name="collection">The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> whose elements
            should be added to the end of the current collection.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="collection"/> is a null reference.</exception>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> has a fixed size.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> already contains one or more elements
            in the specified <paramref name="collection"/>, and the <b>BuilderCollection</b>
            ensures that all elements are unique.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.AddRange(CodeSmith.Engine.Parser.IBuilder[])">
            <summary>
            Adds the elements of a <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> array
            to the end of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <param name="array">An <see cref="T:System.Array"/> of <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> elements
            that should be added to the end of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="array"/> is a null reference.</exception>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> has a fixed size.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> already contains one or more elements
            in the specified <paramref name="array"/>, and the <b>BuilderCollection</b>
            ensures that all elements are unique.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.AddRange(System.Collections.ICollection)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.BinarySearch(CodeSmith.Engine.Parser.IBuilder)">
            <summary>
            Searches the entire sorted <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> for an
            <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> element using the default comparer
            and returns the zero-based index of the element.
            </summary>
            <param name="value">The <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> object
            to locate in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            This argument can be a null reference.
            </param>
            <returns>The zero-based index of <paramref name="value"/> in the sorted
            <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>, if <paramref name="value"/> is found;
            otherwise, a negative number, which is the bitwise complement of the index
            of the next element that is larger than <paramref name="value"/> or, if there
            is no larger element, the bitwise complement of <see cref="P:CodeSmith.Engine.Parser.BuilderCollection.Count"/>.</returns>
            <exception cref="T:System.InvalidOperationException">
            Neither <paramref name="value"/> nor the elements of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>
            implement the <see cref="T:System.IComparable"/> interface.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.BinarySearch(System.Int32,System.Int32,System.Object,System.Collections.IComparer)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.Clear">
            <summary>
            Removes all elements from the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> has a fixed size.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Clear"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.Clone">
            <summary>
            Creates a shallow copy of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <returns>A shallow copy of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.</returns>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Clone"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.Contains(CodeSmith.Engine.Parser.IBuilder)">
            <summary>
            Determines whether the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>
            contains the specified <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> element.
            </summary>
            <param name="value">The <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> object
            to locate in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            This argument can be a null reference.
            </param>
            <returns><c>true</c> if <paramref name="value"/> is found in the
            <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>; otherwise, <c>false</c>.</returns>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Contains(System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.System#Collections#IList#Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> contains the specified element.
            </summary>
            <param name="value">The object to locate in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            This argument must be compatible with <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>.
            This argument can be a null reference.
            </param>
            <returns><c>true</c> if <paramref name="value"/> is found in the
            <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.InvalidCastException"><paramref name="value"/>
            is not compatible with <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Contains(System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.CopyTo(CodeSmith.Engine.Parser.IBuilder[])">
            <overloads>
            Copies the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> or a portion of it to a one-dimensional array.
            </overloads>
            <summary>
            Copies the entire <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> to a one-dimensional <see cref="T:System.Array"/>
            of <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> elements, starting at the beginning of the target array.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the
            <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> elements copied from the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            The <b>Array</b> must have zero-based indexing.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="array"/> is a null reference.</exception>
            <exception cref="T:System.ArgumentException">
            The number of elements in the source <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is greater
            than the available space in the destination <paramref name="array"/>.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.CopyTo(System.Array)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.CopyTo(CodeSmith.Engine.Parser.IBuilder[],System.Int32)">
            <summary>
            Copies the entire <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> to a one-dimensional <see cref="T:System.Array"/>
            of <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> elements, starting at the specified index of the target array.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the
            <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> elements copied from the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            The <b>Array</b> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/>
            at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="array"/> is a null reference.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="arrayIndex"/> is less than zero.</exception>
            <exception cref="T:System.ArgumentException"><para>
            <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
            </para><para>-or-</para><para>
            The number of elements in the source <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is greater than the
            available space from <paramref name="arrayIndex"/> to the end of the destination
            <paramref name="array"/>.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.CopyTo(System.Array)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the entire <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> to a one-dimensional <see cref="T:System.Array"/>,
            starting at the specified index of the target array.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the
            <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> elements copied from the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            The <b>Array</b> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/>
            at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="array"/> is a null reference.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="arrayIndex"/> is less than zero.</exception>
            <exception cref="T:System.ArgumentException"><para>
            <paramref name="array"/> is multidimensional.
            </para><para>-or-</para><para>
            <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
            </para><para>-or-</para><para>
            The number of elements in the source <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is greater than the
            available space from <paramref name="arrayIndex"/> to the end of the destination
            <paramref name="array"/>.</para></exception>
            <exception cref="T:System.InvalidCastException">
            The <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> type cannot be cast automatically
            to the type of the destination <paramref name="array"/>.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.CopyTo(System.Array)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.GetEnumerator">
            <summary>
            Returns an <see cref="T:CodeSmith.Engine.Parser.BuilderCollection.IBuilderEnumerator"/> that can
            iterate through the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <returns>An <see cref="T:CodeSmith.Engine.Parser.BuilderCollection.IBuilderEnumerator"/>
            for the entire <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.</returns>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.GetEnumerator"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IEnumerator"/> that can
            iterate through the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/>
            for the entire <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.</returns>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.GetEnumerator"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.IndexOf(CodeSmith.Engine.Parser.IBuilder)">
            <summary>
            Returns the zero-based index of the first occurrence of the specified
            <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <param name="value">The <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> object
            to locate in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            This argument can be a null reference.
            </param>
            <returns>
            The zero-based index of the first occurrence of <paramref name="value"/>
            in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>, if found; otherwise, -1.
            </returns>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.IndexOf(System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            Returns the zero-based index of the first occurrence of the specified
            <see cref="T:System.Object"/> in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <param name="value">The object to locate in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            This argument must be compatible with <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>.
            This argument can be a null reference.
            </param>
            <returns>
            The zero-based index of the first occurrence of <paramref name="value"/>
            in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>, if found; otherwise, -1.
            </returns>
            <exception cref="T:System.InvalidCastException"><paramref name="value"/>
            is not compatible with <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.IndexOf(System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.Insert(System.Int32,CodeSmith.Engine.Parser.IBuilder)">
            <summary>
            Inserts a <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> element into the
            <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="value"/>
            should be inserted.</param>
            <param name="value">The <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> object
            to insert into the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            This argument can be a null reference.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="index"/> is less than zero.</para>
            <para>-or-</para>
            <para><paramref name="index"/> is greater than <see cref="P:CodeSmith.Engine.Parser.BuilderCollection.Count"/>.</para>
            </exception>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> has a fixed size.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> already contains the specified
            <paramref name="value"/>, and the <b>BuilderCollection</b>
            ensures that all elements are unique.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Inserts an element into the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="value"/>
            should be inserted.</param>
            <param name="value">The object to insert into the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            This argument must be compatible with <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>.
            This argument can be a null reference.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="index"/> is less than zero.</para>
            <para>-or-</para>
            <para><paramref name="index"/> is greater than <see cref="P:CodeSmith.Engine.Parser.BuilderCollection.Count"/>.</para>
            </exception>
            <exception cref="T:System.InvalidCastException"><paramref name="value"/>
            is not compatible with <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>.</exception>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> has a fixed size.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> already contains the specified
            <paramref name="value"/>, and the <b>BuilderCollection</b>
            ensures that all elements are unique.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Insert(System.Int32,System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.ReadOnly(CodeSmith.Engine.Parser.BuilderCollection)">
            <summary>
            Returns a read-only wrapper for the specified <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <param name="collection">The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> to wrap.</param>
            <returns>A read-only wrapper around <paramref name="collection"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="collection"/> is a null reference.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.Remove(CodeSmith.Engine.Parser.IBuilder)">
            <summary>
            Removes the first occurrence of the specified <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>
            from the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <param name="value">The <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> object
            to remove from the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            This argument can be a null reference.
            </param>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> has a fixed size.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Remove(System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.System#Collections#IList#Remove(System.Object)">
            <summary>
            Removes the first occurrence of the specified <see cref="T:System.Object"/>
            from the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <param name="value">The object to remove from the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            This argument must be compatible with <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>.
            This argument can be a null reference.
            </param>
            <exception cref="T:System.InvalidCastException"><paramref name="value"/>
            is not compatible with <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>.</exception>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> has a fixed size.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Remove(System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="index"/> is less than zero.</para>
            <para>-or-</para>
            <para><paramref name="index"/> is equal to or greater than <see cref="P:CodeSmith.Engine.Parser.BuilderCollection.Count"/>.</para>
            </exception>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> has a fixed size.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.RemoveAt(System.Int32)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes the specified range of elements from the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <param name="index">The zero-based starting index of the range
            of elements to remove.</param>
            <param name="count">The number of elements to remove.</param>
            <exception cref="T:System.ArgumentException">
            <paramref name="index"/> and <paramref name="count"/> do not denote a
            valid range of elements in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="index"/> is less than zero.</para>
            <para>-or-</para>
            <para><paramref name="count"/> is less than zero.</para>
            </exception>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> has a fixed size.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.RemoveRange(System.Int32,System.Int32)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.Reverse">
            <overloads>
            Reverses the order of the elements in the 
            <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> or a portion of it.
            </overloads>
            <summary>
            Reverses the order of the elements in the entire <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Reverse"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverses the order of the elements in the specified range.
            </summary>
            <param name="index">The zero-based starting index of the range
            of elements to reverse.</param>
            <param name="count">The number of elements to reverse.</param>
            <exception cref="T:System.ArgumentException">
            <paramref name="index"/> and <paramref name="count"/> do not denote a
            valid range of elements in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="index"/> is less than zero.</para>
            <para>-or-</para>
            <para><paramref name="count"/> is less than zero.</para>
            </exception>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Reverse"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.Sort">
            <overloads>
            Sorts the elements in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> or a portion of it.
            </overloads>
            <summary>
            Sorts the elements in the entire <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>
            using the <see cref="T:System.IComparable"/> implementation of each element.
            </summary>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Sort"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.Sort(System.Collections.IComparer)">
            <summary>
            Sorts the elements in the entire <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>
            using the specified <see cref="T:System.Collections.IComparer"/> interface.
            </summary>
            <param name="comparer">
            <para>The <see cref="T:System.Collections.IComparer"/> implementation to use when comparing elements.</para>
            <para>-or-</para>
            <para>A null reference to use the <see cref="T:System.IComparable"/> implementation 
            of each element.</para></param>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Sort"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.Sort(System.Int32,System.Int32,System.Collections.IComparer)">
            <summary>
            Sorts the elements in the specified range 
            using the specified <see cref="T:System.Collections.IComparer"/> interface.
            </summary>
            <param name="index">The zero-based starting index of the range
            of elements to sort.</param>
            <param name="count">The number of elements to sort.</param>
            <param name="comparer">
            <para>The <see cref="T:System.Collections.IComparer"/> implementation to use when comparing elements.</para>
            <para>-or-</para>
            <para>A null reference to use the <see cref="T:System.IComparable"/> implementation 
            of each element.</para></param>
            <exception cref="T:System.ArgumentException">
            <paramref name="index"/> and <paramref name="count"/> do not denote a
            valid range of elements in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="index"/> is less than zero.</para>
            <para>-or-</para>
            <para><paramref name="count"/> is less than zero.</para>
            </exception>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Sort"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.Synchronized(CodeSmith.Engine.Parser.BuilderCollection)">
            <summary>
            Returns a synchronized (thread-safe) wrapper
            for the specified <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <param name="collection">The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> to synchronize.</param>
            <returns>
            A synchronized (thread-safe) wrapper around <paramref name="collection"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="collection"/> is a null reference.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.Synchronized(System.Collections.IList)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.ToArray">
            <summary>
            Copies the elements of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> to a new
            <see cref="T:System.Array"/> of <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> elements.
            </summary>
            <returns>A one-dimensional <see cref="T:System.Array"/> of <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>
            elements containing copies of the elements of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.</returns>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.ToArray"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.TrimToSize">
            <summary>
            Sets the capacity to the actual number of elements in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>BuilderCollection</b> has a fixed size.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.ArrayList.TrimToSize"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.BuilderCollection.Unique(CodeSmith.Engine.Parser.BuilderCollection)">
            <summary>
            Returns a wrapper for the specified <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>
            ensuring that all elements are unique.
            </summary>
            <param name="collection">The <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> to wrap.</param>    
            <returns>
            A wrapper around <paramref name="collection"/> ensuring that all elements are unique.
            </returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="collection"/> contains duplicate elements.</exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="collection"/> is a null reference.</exception>
            <remarks><para>
            The <b>Unique</b> wrapper provides a set-like collection by ensuring
            that all elements in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> are unique.
            </para><para>
            <b>Unique</b> raises an <see cref="T:System.ArgumentException"/> if the specified 
            <paramref name="collection"/> contains any duplicate elements. The returned
            wrapper raises a <see cref="T:System.NotSupportedException"/> whenever the user attempts 
            to add an element that is already contained in the <b>BuilderCollection</b>.
            </para><para>
            <strong>Note:</strong> The <b>Unique</b> wrapper reflects any changes made
            to the underlying <paramref name="collection"/>, including the possible
            creation of duplicate elements. The uniqueness of all elements is therefore
            no longer assured if the underlying collection is manipulated directly.
            </para></remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.BuilderCollection.InnerArray">
            <summary>
            Gets the list of elements contained in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> instance.
            </summary>
            <value>
            A one-dimensional <see cref="T:System.Array"/> with zero-based indexing that contains all 
            <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> elements in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </value>
            <remarks>
            Use <b>InnerArray</b> to access the element array of a <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>
            instance that might be a read-only or synchronized wrapper. This is necessary because
            the element array field of wrapper classes is always a null reference.
            </remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.BuilderCollection.Capacity">
            <summary>
            Gets or sets the capacity of the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <value>The number of elements that the
            <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> can contain.</value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <b>Capacity</b> is set to a value that is less than <see cref="P:CodeSmith.Engine.Parser.BuilderCollection.Count"/>.</exception>
            <remarks>Please refer to <see cref="P:System.Collections.ArrayList.Capacity"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.BuilderCollection.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <value>
            The number of elements contained in the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </value>
            <remarks>Please refer to <see cref="P:System.Collections.ArrayList.Count"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.BuilderCollection.IsFixedSize">
            <summary>
            Gets a value indicating whether the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> has a fixed size.
            </summary>
            <value><c>true</c> if the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> has a fixed size;
            otherwise, <c>false</c>. The default is <c>false</c>.</value>
            <remarks>Please refer to <see cref="P:System.Collections.ArrayList.IsFixedSize"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.BuilderCollection.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.
            </summary>
            <value><c>true</c> if the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only;
            otherwise, <c>false</c>. The default is <c>false</c>.</value>
            <remarks>Please refer to <see cref="P:System.Collections.ArrayList.IsReadOnly"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.BuilderCollection.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>
            is synchronized (thread-safe).
            </summary>
            <value><c>true</c> if access to the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is
            synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
            <remarks>Please refer to <see cref="P:System.Collections.ArrayList.IsSynchronized"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.BuilderCollection.IsUnique">
            <summary>
            Gets a value indicating whether the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> 
            ensures that all elements are unique.
            </summary>
            <value>
            <c>true</c> if the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> ensures that all 
            elements are unique; otherwise, <c>false</c>. The default is <c>false</c>.
            </value>
            <remarks>
            <b>IsUnique</b> returns <c>true</c> exactly if the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>
            is exposed through a <see cref="M:CodeSmith.Engine.Parser.BuilderCollection.Unique(CodeSmith.Engine.Parser.BuilderCollection)"/> wrapper. 
            Please refer to <see cref="M:CodeSmith.Engine.Parser.BuilderCollection.Unique(CodeSmith.Engine.Parser.BuilderCollection)"/> for details.
            </remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.BuilderCollection.Item(System.Int32)">
            <summary>
            Gets or sets the <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> element at the specified index.
            </summary>
            <param name="index">The zero-based index of the
            <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> element to get or set.</param>
            <value>
            The <see cref="T:CodeSmith.Engine.Parser.IBuilder"/> element at the specified <paramref name="index"/>.
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="index"/> is less than zero.</para>
            <para>-or-</para>
            <para><paramref name="index"/> is equal to or greater than <see cref="P:CodeSmith.Engine.Parser.BuilderCollection.Count"/>.</para>
            </exception>
            <exception cref="T:System.NotSupportedException"><para>
            The property is set and the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.
            </para><para>-or-</para><para>
            The property is set, the <b>BuilderCollection</b> already contains the
            specified element at a different index, and the <b>BuilderCollection</b>
            ensures that all elements are unique.</para></exception>
            <remarks>Please refer to <see cref="P:System.Collections.ArrayList.Item(System.Int32)"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.BuilderCollection.System#Collections#IList#Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <value>
            The element at the specified <paramref name="index"/>. When the property
            is set, this value must be compatible with <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>.
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="index"/> is less than zero.</para>
            <para>-or-</para>
            <para><paramref name="index"/> is equal to or greater than <see cref="P:CodeSmith.Engine.Parser.BuilderCollection.Count"/>.</para>
            </exception>
            <exception cref="T:System.InvalidCastException">The property is set to a value
            that is not compatible with <see cref="T:CodeSmith.Engine.Parser.IBuilder"/>.</exception>
            <exception cref="T:System.NotSupportedException"><para>
            The property is set and the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/> is read-only.
            </para><para>-or-</para><para>
            The property is set, the <b>BuilderCollection</b> already contains the
            specified element at a different index, and the <b>BuilderCollection</b>
            ensures that all elements are unique.</para></exception>
            <remarks>Please refer to <see cref="P:System.Collections.ArrayList.Item(System.Int32)"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.BuilderCollection.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize
            access to the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </summary>
            <value>An object that can be used to synchronize
            access to the <see cref="T:CodeSmith.Engine.Parser.BuilderCollection"/>.
            </value>
            <remarks>Please refer to <see cref="P:System.Collections.ArrayList.SyncRoot"/> for details.</remarks>
        </member>
        <member name="T:CodeSmith.Engine.Parser.ICollapsibleBuilder">
            <summary>
            This is a marker interface to indicate that whitespace around this object should be removed.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Parser.RegisterTemplateBuilder.ResolveTypeFromClassName(System.Collections.Hashtable,System.String)">
            <summary>
            Looks in each referenced assembly for a certian class. When found it returns that type.
            </summary>
            <param name="assemblyDependencies">referenced assembly.</param>
            <param name="className">name of the class.</param>
            <returns>Looks in each referenced assembly for a certian class. When found it returns that type.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Parser.RegisterTemplateBuilder.CurrentDomain_ReflectionOnlyAssemblyResolve(System.Object,System.ResolveEventArgs)">
             <summary>
             How to load an assembly at runtime that is located in a folder that is not the bin folder of the application.
            
             http://support.microsoft.com/kb/837908
             </summary>
             <param name="sender"></param>
             <param name="args">args.Name is the name of the assembly needing to be resolved.</param>
             <returns>The resolved assembly or null.</returns>
        </member>
        <member name="T:CodeSmith.Engine.Parser.StringPair">
            <summary>
            Implements a strongly typed pair of one <see cref="T:System.String"/>
            key and one <see cref="T:System.String"/> value.
            </summary>
            <remarks>
            <b>StringPair</b> provides a <see cref="T:System.Collections.DictionaryEntry"/> that is strongly
            typed for <see cref="T:System.String"/> keys and <see cref="T:System.String"/> values.
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.StringPair.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.StringPair"/>
            class with the specified key and value.
            </summary>
            <param name="key">
            The <see cref="T:System.String"/> key in the key-and-value pair.</param>
            <param name="value">
            The <see cref="T:System.String"/> value in the key-and-value pair.
            This argument can be a null reference.
            </param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key"/> is a null reference.</exception>
        </member>
        <member name="M:CodeSmith.Engine.Parser.StringPair.op_Implicit(System.Collections.DictionaryEntry)~CodeSmith.Engine.Parser.StringPair">
            <summary>
            Converts a <see cref="T:System.Collections.DictionaryEntry"/> to a <see cref="T:CodeSmith.Engine.Parser.StringPair"/>.
            </summary>
            <param name="entry">A <see cref="T:System.Collections.DictionaryEntry"/> object to convert.</param>
            <returns>A <see cref="T:CodeSmith.Engine.Parser.StringPair"/> object that represents
            the converted <paramref name="entry"/>.</returns>
            <exception cref="T:System.InvalidCastException">
            <para><paramref name="entry"/> contains a key that is not compatible
            with <see cref="T:System.String"/>.</para>
            <para>-or-</para>
            <para><paramref name="entry"/> contains a value that is not compatible
            with <see cref="T:System.String"/>.</para>
            </exception>
        </member>
        <member name="M:CodeSmith.Engine.Parser.StringPair.op_Implicit(CodeSmith.Engine.Parser.StringPair)~System.Collections.DictionaryEntry">
            <summary>
            Converts a <see cref="T:CodeSmith.Engine.Parser.StringPair"/> to a <see cref="T:System.Collections.DictionaryEntry"/>.
            </summary>
            <param name="pair">A <see cref="T:CodeSmith.Engine.Parser.StringPair"/> object to convert.</param>
            <returns>A <see cref="T:System.Collections.DictionaryEntry"/> object that
            represents the converted <paramref name="pair"/>.</returns>
        </member>
        <member name="P:CodeSmith.Engine.Parser.StringPair.Key">
            <summary>
            Gets or sets the <see cref="T:System.String"/> key in the key-and-value pair.
            </summary>
            <value>
            The <see cref="T:System.String"/> key in the key-and-value pair.
            The default is a null reference.
            </value>
            <exception cref="T:System.ArgumentNullException">
            <b>Key</b> is set to a null reference.</exception>
            <remarks>
            <see cref="T:CodeSmith.Engine.Parser.StringPair"/> is a value type and therefore has an implicit default
            constructor that zeroes all data members. This means that the <b>Key</b> property of
            a default-constructed <b>StringPair</b> contains a null reference by default,
            even though it is not possible to explicitly set <b>Key</b> to a null reference.
            </remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.StringPair.Value">
            <summary>
            Gets or sets the <see cref="T:System.String"/> value in the key-and-value pair.
            </summary>
            <value>
            The <see cref="T:System.String"/> value in the key-and-value pair.
            This value can be a null reference, which is also the default.
            </value>
        </member>
        <member name="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary">
            <summary>
            Implements a strongly typed collection of <see cref="T:CodeSmith.Engine.Parser.StringPair"/>
            key-and-value pairs that are organized based on the hash code of the key.
            </summary>
            <remarks>
            <b>ParsedAttributeDictionary</b> provides a <see cref="T:System.Collections.Hashtable"/> that is strongly typed
            for <see cref="T:System.String"/> keys and <see cref="T:System.String"/> values.
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.#ctor">
            <overloads>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> class.
            </overloads>
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> class
            that is empty and has the default initial capacity, the default load factor,
            the default hash code provider and the default comparer.
            </summary>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.#ctor"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> class
            that is empty and has the default initial capacity, the default load factor,
            the specified hash code provider and the specified comparer.
            </summary>
            <param name="provider">
            <para>The <see cref="T:System.Collections.IHashCodeProvider"/> that supplies the hash codes
            for all keys in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</para>
            <para>-or-</para>
            <para>A null reference to use the default hash code provider, which is each key's
            implementation of <see cref="M:System.Object.GetHashCode"/>.</para></param>
            <param name="comparer">
            <para>The <see cref="T:System.Collections.IComparer"/> to use to determine whether two keys are equal.</para>
            <para>-or-</para>
            <para>A null reference to use the default comparer, which is each key's
            implementation of <see cref="M:System.Object.Equals(System.Object)"/>.</para></param>
            <remarks>
            Please refer to <see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)"/> for details.
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> class
            that is empty and has the specified initial capacity, the default load factor,
            the default hash code provider and the default comparer.
            </summary>
            <param name="capacity">The approximate number of elements that the new
            <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is initially capable of storing.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="capacity"/> is less than zero.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.#ctor(System.Int32)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> class
            that is empty and has the specified initial capacity, the default load factor,
            the specified hash code provider and the specified comparer.
            </summary>
            <param name="capacity">The approximate number of elements that the new
            <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is initially capable of storing.</param>
            <param name="provider">
            <para>The <see cref="T:System.Collections.IHashCodeProvider"/> that supplies the hash codes
            for all keys in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</para>
            <para>-or-</para>
            <para>A null reference to use the default hash code provider, which is each key's
            implementation of <see cref="M:System.Object.GetHashCode"/>.</para></param>
            <param name="comparer">
            <para>The <see cref="T:System.Collections.IComparer"/> to use to determine whether two keys are equal.</para>
            <para>-or-</para>
            <para>A null reference to use the default comparer, which is each key's
            implementation of <see cref="M:System.Object.Equals(System.Object)"/>.</para></param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="capacity"/> is less than zero.</exception>
            <remarks>
            Please refer to <see cref="M:System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)"/> for details.
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.#ctor(System.Int32,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> class
            that is empty and has the specified initial capacity, the specified load factor,
            the default hash code provider and the default comparer.
            </summary>
            <param name="capacity">The approximate number of elements that the new
            <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is initially capable of storing.</param>
            <param name="loadFactor">A number in the range from 0.1 through 1.0
            indicating the maximum ratio of elements to buckets.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="capacity"/> is less than zero.</para>
            <para>-or-</para>
            <para><paramref name="loadFactor"/> is less than 0.1.</para>
            <para>-or-</para>
            <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> class
            that is empty and has the specified initial capacity, the specified load factor,
            the specified hash code provider and the specified comparer.
            </summary>
            <param name="capacity">The approximate number of elements that the new
            <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is initially capable of storing.</param>
            <param name="loadFactor">A number in the range from 0.1 through 1.0
            indicating the maximum ratio of elements to buckets.</param>
            <param name="provider">
            <para>The <see cref="T:System.Collections.IHashCodeProvider"/> that supplies the hash codes
            for all keys in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</para>
            <para>-or-</para>
            <para>A null reference to use the default hash code provider, which is each key's
            implementation of <see cref="M:System.Object.GetHashCode"/>.</para></param>
            <param name="comparer">
            <para>The <see cref="T:System.Collections.IComparer"/> to use to determine whether two keys are equal.</para>
            <para>-or-</para>
            <para>A null reference to use the default comparer, which is each key's
            implementation of <see cref="M:System.Object.Equals(System.Object)"/>.</para></param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="capacity"/> is less than zero.</para>
            <para>-or-</para>
            <para><paramref name="loadFactor"/> is less than 0.1.</para>
            <para>-or-</para>
            <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
            <remarks>
            Please refer to <see cref="M:System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)"/>
            for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.#ctor(CodeSmith.Engine.Parser.ParsedAttributeDictionary)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> class
            that contains elements copied from the specified dictionary and
            that has the same initial capacity as the number of elements copied, the
            default load factor, the default hash code provider and the default comparer.
            </summary>
            <param name="dictionary">The <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>
            whose elements are copied to the new collection.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="dictionary"/> is a null reference.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.#ctor(System.Collections.IDictionary)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> class
            that contains elements copied from the specified <see cref="T:System.Collections.IDictionary"/>
            and that has the same initial capacity as the number of elements copied, the
            default load factor, the default hash code provider and the default comparer.
            </summary>
            <param name="dictionary">The <see cref="T:System.Collections.IDictionary"/>
            whose elements are copied to the new collection.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="dictionary"/> is a null reference.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> class
            that contains elements copied from the specified <see cref="T:System.Collections.IDictionary"/>
            and that has the same initial capacity as the number of elements copied, the
            default load factor, the specified hash code provider and the specified comparer.
            </summary>
            <param name="dictionary">The <see cref="T:System.Collections.IDictionary"/>
            whose elements are copied to the new collection.</param>
            <param name="provider">
            <para>The <see cref="T:System.Collections.IHashCodeProvider"/> that supplies the hash codes
            for all keys in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</para>
            <para>-or-</para>
            <para>A null reference to use the default hash code provider, which is each key's
            implementation of <see cref="M:System.Object.GetHashCode"/>.</para></param>
            <param name="comparer">
            <para>The <see cref="T:System.Collections.IComparer"/> to use to determine whether two keys are equal.</para>
            <para>-or-</para>
            <para>A null reference to use the default comparer, which is each key's
            implementation of <see cref="M:System.Object.Equals(System.Object)"/>.</para></param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="dictionary"/> is a null reference.</exception>
            <remarks>
            Please refer to <see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)"/>
            for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.#ctor(System.Collections.IDictionary,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> class
            that contains elements copied from the specified <see cref="T:System.Collections.IDictionary"/>
            and that has the same initial capacity as the number of elements copied, the
            specified load factor, the default hash code provider and the default comparer.
            </summary>
            <param name="dictionary">The <see cref="T:System.Collections.IDictionary"/>
            whose elements are copied to the new collection.</param>
            <param name="loadFactor">A number in the range from 0.1 through 1.0
            indicating the maximum ratio of elements to buckets.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="dictionary"/> is a null reference.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="loadFactor"/> is less than 0.1.</para>
            <para>-or-</para>
            <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
            <remarks>
            Please refer to <see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)"/> for details.
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> class
            that contains elements copied from the specified <see cref="T:System.Collections.IDictionary"/>
            and that has the same initial capacity as the number of elements copied, the
            specified load factor, the specified hash code provider and the specified comparer.
            </summary>
            <param name="dictionary">The <see cref="T:System.Collections.IDictionary"/>
            whose elements are copied to the new collection.</param>
            <param name="loadFactor">A number in the range from 0.1 through 1.0
            indicating the maximum ratio of elements to buckets.</param>
            <param name="provider">
            <para>The <see cref="T:System.Collections.IHashCodeProvider"/> that supplies the hash codes
            for all keys in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</para>
            <para>-or-</para>
            <para>A null reference to use the default hash code provider, which is each key's
            implementation of <see cref="M:System.Object.GetHashCode"/>.</para></param>
            <param name="comparer">
            <para>The <see cref="T:System.Collections.IComparer"/> to use to determine whether two keys are equal.</para>
            <para>-or-</para>
            <para>A null reference to use the default comparer, which is each key's
            implementation of <see cref="M:System.Object.Equals(System.Object)"/>.</para></param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="dictionary"/> is a null reference.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="loadFactor"/> is less than 0.1.</para>
            <para>-or-</para>
            <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
            <remarks>
            Please refer to <see cref="M:System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)"/>
            for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.Add(System.String,System.String)">
            <summary>
            Adds an element with the specified <see cref="T:System.String"/> key and
            <see cref="T:System.String"/> value to the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <param name="key">The <see cref="T:System.String"/> key of the element
            to add to the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</param>
            <param name="value">The <see cref="T:System.String"/> value of the element
            to add to the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            This argument can be a null reference.
            </param>
            <exception cref="T:System.ArgumentException">
            An element with the specified <paramref name="key"/>
            already exists in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key"/> is a null reference.</exception>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>ParsedAttributeDictionary</b> has a fixed size.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            Adds an element with the specified key and value
            to the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <param name="key">The key of the element to add to the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            This argument must be compatible with <see cref="T:System.String"/>.</param>
            <param name="value">The value of the element to add to the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            This argument must be compatible with <see cref="T:System.String"/>.
            This argument can be a null reference.
            </param>
            <exception cref="T:System.ArgumentException">
            An element with the specified <paramref name="key"/>
            already exists in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key"/> is a null reference.</exception>
            <exception cref="T:System.InvalidCastException">
            <para><paramref name="key"/> is not compatible with <see cref="T:System.String"/>.</para>
            <para>-or-</para>
            <para><paramref name="value"/> is not compatible with <see cref="T:System.String"/>.</para>
            </exception>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>ParsedAttributeDictionary</b> has a fixed size.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.Add(System.Object,System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.Clear">
            <summary>
            Removes all elements from the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>ParsedAttributeDictionary</b> has a fixed size.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.Clear"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.Clone">
            <summary>
            Creates a shallow copy of the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <returns>A shallow copy of the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</returns>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.Clone"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.Contains(System.String)">
            <summary>
            Determines whether the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>
            contains the specified <see cref="T:System.String"/> key.
            </summary>
            <param name="key">The <see cref="T:System.String"/> key
            to locate in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</param>
            <returns><c>true</c> if the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> contains an element
            with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key"/> is a null reference.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.Contains(System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> contains the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            This argument must be compatible with <see cref="T:System.String"/>.</param>
            <returns><c>true</c> if the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> contains an element
            with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key"/> is a null reference.</exception>
            <exception cref="T:System.InvalidCastException"><paramref name="key"/>
            is not compatible with <see cref="T:System.String"/>.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.Contains(System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.ContainsKey(System.String)">
            <summary>
            Determines whether the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>
            contains the specified <see cref="T:System.String"/> key.
            </summary>
            <param name="key">The <see cref="T:System.String"/> key
            to locate in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</param>
            <returns><c>true</c> if the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> contains an element
            with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key"/> is a null reference.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.ContainsKey(System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.ContainsValue(System.String)">
            <summary>
            Determines whether the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>
            contains the specified <see cref="T:System.String"/> value.
            </summary>
            <param name="value">The <see cref="T:System.String"/> value
            to locate in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            This argument can be a null reference.
            </param>
            <returns><c>true</c> if the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> contains an element
            with the specified <paramref name="value"/>; otherwise, <c>false</c>.</returns>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.ContainsValue(System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.CopyTo(CodeSmith.Engine.Parser.StringPair[],System.Int32)">
            <summary>
            Copies the entire <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> to a one-dimensional <see cref="T:System.Array"/> of
            <see cref="T:CodeSmith.Engine.Parser.StringPair"/> elements, starting at the specified index of the target array.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the
            <see cref="T:CodeSmith.Engine.Parser.StringPair"/> elements copied from the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            The <b>Array</b> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/>
            at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="array"/> is a null reference.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="arrayIndex"/> is less than zero.</exception>
            <exception cref="T:System.ArgumentException"><para>
            <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
            </para><para>-or-</para><para>
            The number of elements in the source <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is greater than
            the available space from <paramref name="arrayIndex"/> to the end of the destination
            <paramref name="array"/>.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the entire <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> to a one-dimensional <see cref="T:System.Array"/>,
            starting at the specified index of the target array.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the
            <see cref="T:CodeSmith.Engine.Parser.StringPair"/> elements copied from the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            The <b>Array</b> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/>
            at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="array"/> is a null reference.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="arrayIndex"/> is less than zero.</exception>
            <exception cref="T:System.ArgumentException"><para>
            <paramref name="array"/> is multidimensional.
            </para><para>-or-</para><para>
            <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
            </para><para>-or-</para><para>
            The number of elements in the source <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is greater than
            the available space from <paramref name="arrayIndex"/> to the end of the destination
            <paramref name="array"/>.</para></exception>
            <exception cref="T:System.InvalidCastException">
            The <see cref="T:CodeSmith.Engine.Parser.StringPair"/> type cannot be cast automatically
            to the type of the destination <paramref name="array"/>.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.CopyTo(System.Array,System.Int32)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.GetEnumerator">
            <summary>
            Returns an <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary.StringPairEnumerator"/>
            that can iterate through the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <returns>An <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary.StringPairEnumerator"/>
            for the entire <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</returns>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.GetEnumerator"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator"/> that can
            iterate through the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <returns>An <see cref="T:System.Collections.IDictionaryEnumerator"/>
            for the entire <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</returns>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.GetEnumerator"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IEnumerator"/> that can
            iterate through the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/>
            for the entire <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</returns>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.GetEnumerator"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.Remove(System.String)">
            <summary>
            Removes the element with the specified <see cref="T:System.String"/> key
            from the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <param name="key">The <see cref="T:System.String"/> key of the element
            to remove from the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key"/> is a null reference.</exception>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>ParsedAttributeDictionary</b> has a fixed size.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.Remove(System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            Removes the element with the specified key
            from the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <param name="key">The key of the element to remove from the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            This argument must be compatible with <see cref="T:System.String"/>.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key"/> is a null reference.</exception>
            <exception cref="T:System.InvalidCastException"><paramref name="key"/>
            is not compatible with <see cref="T:System.String"/>.</exception>
            <exception cref="T:System.NotSupportedException">
            <para>The <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is read-only.</para>
            <para>-or-</para>
            <para>The <b>ParsedAttributeDictionary</b> has a fixed size.</para></exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.Remove(System.Object)"/> for details.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.ReadOnly(CodeSmith.Engine.Parser.ParsedAttributeDictionary)">
            <summary>
            Returns a read-only wrapper for the specified <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <param name="dictionary">The <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> to wrap.</param>
            <returns>A read-only wrapper around <paramref name="dictionary"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="dictionary"/> is a null reference.</exception>
            <remarks>
            <b>ReadOnly</b> has the same effect as the <see cref="M:System.Collections.ArrayList.ReadOnly(System.Collections.IList)"/>
            method of the <see cref="T:System.Collections.ArrayList"/> class.
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.Parser.ParsedAttributeDictionary.Synchronized(CodeSmith.Engine.Parser.ParsedAttributeDictionary)">
            <summary>
            Returns a synchronized (thread-safe) wrapper
            for the specified <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <param name="dictionary">The <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> to synchronize.</param>
            <returns>A synchronized (thread-safe) wrapper around <paramref name="dictionary"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="dictionary"/> is a null reference.</exception>
            <remarks>Please refer to <see cref="M:System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.ParsedAttributeDictionary.Count">
            <summary>
            Gets the number of key-and-value pairs contained in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <value>
            The number of key-and-value pairs contained in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </value>
            <remarks>Please refer to <see cref="P:System.Collections.Hashtable.Count"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.ParsedAttributeDictionary.IsFixedSize">
            <summary>
            Gets a value indicating whether the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> has a fixed size.
            </summary>
            <value><c>true</c> if the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> has a fixed size;
            otherwise, <c>false</c>. The default is <c>false</c>.</value>
            <remarks>Please refer to <see cref="P:System.Collections.Hashtable.IsFixedSize"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.ParsedAttributeDictionary.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is read-only.
            </summary>
            <value><c>true</c> if the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is read-only;
            otherwise, <c>false</c>. The default is <c>false</c>.</value>
            <remarks>Please refer to <see cref="P:System.Collections.Hashtable.IsReadOnly"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.ParsedAttributeDictionary.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>
            is synchronized (thread-safe).
            </summary>
            <value><c>true</c> if access to the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is
            synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
            <remarks>Please refer to <see cref="P:System.Collections.Hashtable.IsSynchronized"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.ParsedAttributeDictionary.Item(System.String)">
            <summary>
            Gets or sets the <see cref="T:System.String"/> value
            associated with the specified <see cref="T:System.String"/> key.
            </summary>
            <param name="key">The <see cref="T:System.String"/> key
            whose value to get or set.</param>
            <value>The <see cref="T:System.String"/> value associated with the specified
            <paramref name="key"/>. If the specified <paramref name="key"/> is not found,
            attempting to get it returns
            a null reference,
            and attempting to set it creates a new element using the specified
            <paramref name="key"/>.</value>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key"/> is a null reference.</exception>
            <exception cref="T:System.NotSupportedException">
            <para>The property is set and the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is read-only.</para>
            <para>-or-</para>
            <para>The property is set, <paramref name="key"/> does not exist in the collection,
            and the <b>ParsedAttributeDictionary</b> has a fixed size.</para></exception>
            <remarks>Please refer to <see cref="P:System.Collections.Hashtable.Item(System.Object)"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.ParsedAttributeDictionary.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="key">The key whose value to get or set.
            This argument must be compatible with <see cref="T:System.String"/>.</param>
            <value>
            The value associated with the specified <paramref name="key"/>. If the specified
            <paramref name="key"/> is not found, attempting to get it returns
            a null reference,
            and attempting to set it creates a new element using the specified <paramref name="key"/>.
            When set, this value must be compatible with <see cref="T:System.String"/>.
            </value>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key"/> is a null reference.</exception>
            <exception cref="T:System.InvalidCastException">
            <para><paramref name="key"/> is not compatible with <see cref="T:System.String"/>.</para>
            <para>-or-</para>
            <para>The property is set to a value that is not compatible with
            <see cref="T:System.String"/>.</para></exception>
            <exception cref="T:System.NotSupportedException">
            <para>The property is set and the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/> is read-only.</para>
            <para>-or-</para>
            <para>The property is set, <paramref name="key"/> does not exist in the collection,
            and the <b>ParsedAttributeDictionary</b> has a fixed size.</para></exception>
            <remarks>Please refer to <see cref="P:System.Collections.Hashtable.Item(System.Object)"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.ParsedAttributeDictionary.Keys">
            <summary>
            Gets an <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary.KeyList"/> containing
            the keys in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <value>An <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary.KeyList"/> containing
            the keys in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</value>
            <remarks>Please refer to <see cref="P:System.Collections.Hashtable.Keys"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.ParsedAttributeDictionary.System#Collections#IDictionary#Keys">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> containing
            the keys in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <value>An <see cref="T:System.Collections.ICollection"/> containing
            the keys in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</value>
            <remarks>Please refer to <see cref="P:System.Collections.Hashtable.Keys"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.ParsedAttributeDictionary.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize
            access to the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <value>An object that can be used to synchronize
            access to the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</value>
            <remarks>Please refer to <see cref="P:System.Collections.Hashtable.SyncRoot"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.ParsedAttributeDictionary.Values">
            <summary>
            Gets an <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary.ValueList"/> containing
            the values in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <value>An <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary.ValueList"/> containing
            the values in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</value>
            <remarks>Please refer to <see cref="P:System.Collections.Hashtable.Values"/> for details.</remarks>
        </member>
        <member name="P:CodeSmith.Engine.Parser.ParsedAttributeDictionary.System#Collections#IDictionary#Values">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> containing
            the values in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.
            </summary>
            <value>An <see cref="T:System.Collections.ICollection"/> containing
            the values in the <see cref="T:CodeSmith.Engine.Parser.ParsedAttributeDictionary"/>.</value>
            <remarks>Please refer to <see cref="P:System.Collections.Hashtable.Values"/> for details.</remarks>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.BinaryPredicate`1">
            <summary>
            The BinaryPredicate delegate type  encapsulates a method that takes two
            items of the same type, and returns a boolean value representating 
            some relationship between them. For example, checking whether two
            items are equal or equivalent is one kind of binary predicate.
            </summary>
            <param name="item1">The first item.</param>
            <param name="item2">The second item.</param>
            <returns>Whether item1 and item2 satisfy the relationship that the BinaryPredicate defines.</returns>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms">
            <summary>
            Algorithms contains a number of static methods that implement
            algorithms that work on collections. Most of the methods deal with
            the standard generic collection interfaces such as IEnumerable&lt;T&gt;,
            ICollection&lt;T&gt; and IList&lt;T&gt;.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Range``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Returns a view onto a sub-range of a list. Items from <paramref name="list"/> are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to <paramref name="list"/>
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view, but insertions and deletions in the underlying list do not.
            </summary>
            <remarks>This method can be used to apply an algorithm to a portion of a list. For example:
            <code>Algorithms.ReverseInPlace(Algorithms.Range(list, 3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
            <typeparam name="T">The type of the items in the list.</typeparam>
            <param name="list">The list to view.</param>
            <param name="start">The starting index of the view.</param>
            <param name="count">The number of items in the view.</param>
            <returns>A list that is a view onto the given sub-list. </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> or <paramref name="count"/> is negative.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> + <paramref name="count"/> is greater than the
            size of <paramref name="list"/>.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Range``1(``0[],System.Int32,System.Int32)">
            <summary>
            Returns a view onto a sub-range of an array. Items from <paramref name="array"/> are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to <paramref name="array"/>
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view. After an insertion, the last item in <paramref name="array"/> "falls off the end". After a deletion, the
            last item in array becomes the default value (0 or null).
            </summary>
            <remarks>This method can be used to apply an algorithm to a portion of a array. For example:
            <code>Algorithms.ReverseInPlace(Algorithms.Range(array, 3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
            <param name="array">The array to view.</param>
            <param name="start">The starting index of the view.</param>
            <param name="count">The number of items in the view.</param>
            <returns>A list that is a view onto the given sub-array. </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> or <paramref name="count"/> is negative.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> + <paramref name="count"/> is greater than the
            size of <paramref name="array"/>.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReadOnly``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns a read-only view onto a collection. The returned ICollection&lt;T&gt; interface
            only allows operations that do not change the collection: GetEnumerator, Contains, CopyTo,
            Count. The ReadOnly property returns false, indicating that the collection is read-only. All other
            methods on the interface throw a NotSupportedException.
            </summary>
            <remarks>The data in the underlying collection is not copied. If the underlying
            collection is changed, then the read-only view also changes accordingly.</remarks>
            <typeparam name="T">The type of items in the collection.</typeparam>
            <param name="collection">The collection to wrap.</param>
            <returns>A read-only view onto <paramref name="collection"/>. If <paramref name="collection"/> is null, then null is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReadOnly``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns a read-only view onto a list. The returned IList&lt;T&gt; interface
            only allows operations that do not change the list: GetEnumerator, Contains, CopyTo,
            Count, IndexOf, and the get accessor of the indexer. 
            The IsReadOnly property returns true, indicating that the list is read-only. All other
            methods on the interface throw a NotSupportedException.
            </summary>
            <remarks>The data in the underlying list is not copied. If the underlying
            list is changed, then the read-only view also changes accordingly.</remarks>
            <typeparam name="T">The type of items in the list.</typeparam>
            <param name="list">The list to wrap.</param>
            <returns>A read-only view onto <paramref name="list"/>. Returns null if <paramref name="list"/> is null. 
            If <paramref name="list"/> is already read-only, returns <paramref name="list"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReadOnly``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns a read-only view onto a dictionary. The returned IDictionary&lt;TKey,TValue&gt; interface
            only allows operations that do not change the dictionary. 
            The IsReadOnly property returns true, indicating that the dictionary is read-only. All other
            methods on the interface throw a NotSupportedException.
            </summary>
            <remarks>The data in the underlying dictionary is not copied. If the underlying
            dictionary is changed, then the read-only view also changes accordingly.</remarks>
            <param name="dictionary">The dictionary to wrap.</param>
            <returns>A read-only view onto <paramref name="dictionary"/>. Returns null if <paramref name="dictionary"/> is null. 
            If <paramref name="dictionary"/> is already read-only, returns <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.TypedAs``1(System.Collections.IEnumerable)">
            <summary>
            Given a non-generic IEnumerable interface, wrap a generic IEnumerable&lt;T&gt;
            interface around it. The generic interface will enumerate the same objects as the 
            underlying non-generic collection, but can be used in places that require a generic interface.
            The underlying non-generic collection must contain only items that
            are of type <cref name="T"/> or a type derived from it. This method is useful
            when interfacing older, non-generic collections to newer code that uses generic interfaces.
            </summary>
            <remarks>Some collections implement both generic and non-generic interfaces. For efficiency,
            this method will first attempt to cast <paramref name="untypedCollection"/> to IEnumerable&lt;T&gt;. 
            If that succeeds, it is returned; otherwise, a wrapper object is created.</remarks>
            <typeparam name="T">The item type of the wrapper collection.</typeparam>
            <param name="untypedCollection">An untyped collection. This collection should only contain
            items of type <cref name="T"/> or a type derived from it. </param>
            <returns>A generic IEnumerable&lt;T&gt; wrapper around <paramref name="untypedCollection"/>. 
            If <paramref name="untypedCollection"/> is null, then null is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.TypedAs``1(System.Collections.ICollection)">
            <summary>
            Given a non-generic ICollection interface, wrap a generic ICollection&lt;T&gt;
            interface around it. The generic interface will enumerate the same objects as the 
            underlying non-generic collection, but can be used in places that require a generic interface.
            The underlying non-generic collection must contain only items that
            are of type <cref name="T"/> or a type derived from it. This method is useful
            when interfacing older, non-generic collections to newer code that uses generic interfaces.
            </summary>
            <remarks><para>Some collections implement both generic and non-generic interfaces. For efficiency,
            this method will first attempt to cast <paramref name="untypedCollection"/> to ICollection&lt;T&gt;. 
            If that succeeds, it is returned; otherwise, a wrapper object is created.</para>
            <para>Unlike the generic interface, the non-generic ICollection interfaces does
            not contain methods for adding or removing items from the collection. For this reason,
            the returned ICollection&lt;T&gt; will be read-only.</para></remarks>
            <typeparam name="T">The item type of the wrapper collection.</typeparam>
            <param name="untypedCollection">An untyped collection. This collection should only contain
            items of type <cref name="T"/> or a type derived from it. </param>
            <returns>A generic ICollection&lt;T&gt; wrapper around <paramref name="untypedCollection"/>.
            If <paramref name="untypedCollection"/> is null, then null is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.TypedAs``1(System.Collections.IList)">
            <summary>
            Given a non-generic IList interface, wrap a generic IList&lt;T&gt;
            interface around it. The generic interface will enumerate the same objects as the 
            underlying non-generic list, but can be used in places that require a generic interface.
            The underlying non-generic list must contain only items that
            are of type <cref name="T"/> or a type derived from it. This method is useful
            when interfacing older, non-generic lists to newer code that uses generic interfaces.
            </summary>
            <remarks>Some collections implement both generic and non-generic interfaces. For efficiency,
            this method will first attempt to cast <paramref name="untypedList"/> to IList&lt;T&gt;. 
            If that succeeds, it is returned; otherwise, a wrapper object is created.</remarks>
            <typeparam name="T">The item type of the wrapper list.</typeparam>
            <param name="untypedList">An untyped list. This list should only contain
            items of type <cref name="T"/> or a type derived from it. </param>
            <returns>A generic IList&lt;T&gt; wrapper around <paramref name="untypedList"/>.
            If <paramref name="untypedList"/> is null, then null is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Untyped``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Given a generic ICollection&lt;T&gt; interface, wrap a non-generic (untyped)
            ICollection interface around it. The non-generic interface will contain the same objects as the 
            underlying generic collection, but can be used in places that require a non-generic interface.
            This method is useful when interfacing generic interfaces with older code that uses non-generic interfaces.
            </summary>
            <remarks>Many generic collections already implement the non-generic interfaces directly. This
            method will first attempt to simply cast <paramref name="typedCollection"/> to ICollection. If that
            succeeds, it is returned; if it fails, then a wrapper object is created.</remarks>
            <typeparam name="T">The item type of the underlying collection.</typeparam>
            <param name="typedCollection">A typed collection to wrap.</param>
            <returns>A non-generic ICollection wrapper around <paramref name="typedCollection"/>.
            If <paramref name="typedCollection"/> is null, then null is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Untyped``1(System.Collections.Generic.IList{``0})">
            <summary>
            Given a generic IList&lt;T&gt; interface, wrap a non-generic (untyped)
            IList interface around it. The non-generic interface will contain the same objects as the 
            underlying generic list, but can be used in places that require a non-generic interface.
            This method is useful when interfacing generic interfaces with older code that uses non-generic interfaces.
            </summary>
            <remarks>Many generic collections already implement the non-generic interfaces directly. This
            method will first attempt to simply cast <paramref name="typedList"/> to IList. If that
            succeeds, it is returned; if it fails, then a wrapper object is created.</remarks>
            <typeparam name="T">The item type of the underlying list.</typeparam>
            <param name="typedList">A typed list to wrap.</param>
            <returns>A non-generic IList wrapper around <paramref name="typedList"/>.
            If <paramref name="typedList"/> is null, then null is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReadWriteList``1(``0[])">
            <summary>
            <para>Creates a read-write IList&lt;T&gt; wrapper around an array. When an array is
            implicitely converted to an IList&lt;T&gt;, changes to the items in the array cannot
            be made through the interface. This method creates a read-write IList&lt;T&gt; wrapper
            on an array that can be used to make changes to the array. </para>
            <para>Use this method when you need to pass an array to an algorithms that takes an 
            IList&lt;T&gt; and that tries to modify items in the list. Algorithms in this class generally do not
            need this method, since they have been design to operate on arrays even when they
            are passed as an IList&lt;T&gt;.</para>
            </summary>
            <remarks>Since arrays cannot be resized, inserting an item causes the last item in the array to be automatically
            removed. Removing an item causes the last item in the array to be replaced with a default value (0 or null). Clearing
            the list causes all the items to be replaced with a default value.</remarks>
            <param name="array">The array to wrap.</param>
            <returns>An IList&lt;T&gt; wrapper onto <paramref name="array"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Replace``1(System.Collections.Generic.IEnumerable{``0},``0,``0)">
            <summary>
            Replace all items in a collection equal to a particular value with another values, yielding another collection.
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
            <param name="collection">The collection to process.</param>
            <param name="itemFind">The value to find and replace within <paramref name="collection"/>.</param>
            <param name="replaceWith">The new value to replace with.</param>
            <returns>An new collection with the items from <paramref name="collection"/>, in the same order, 
            with the appropriate replacements made.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Replace``1(System.Collections.Generic.IEnumerable{``0},``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Replace all items in a collection equal to a particular value with another values, yielding another collection. A passed
            IEqualityComparer is used to determine equality.
            </summary>
            <param name="collection">The collection to process.</param>
            <param name="itemFind">The value to find and replace within <paramref name="collection"/>.</param>
            <param name="replaceWith">The new value to replace with.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
            <returns>An new collection with the items from <paramref name="collection"/>, in the same order, 
            with the appropriate replacements made.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Replace``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0)">
            <summary>
            Replace all items in a collection that a predicate evalues at true with a value, yielding another collection. .
            </summary>
            <param name="collection">The collection to process.</param>
            <param name="predicate">The predicate used to evaluate items with the collection. If the predicate returns true for a particular
            item, the item is replaces with <paramref name="replaceWith"/>.</param>
            <param name="replaceWith">The new value to replace with.</param>
            <returns>An new collection with the items from <paramref name="collection"/>, in the same order, 
            with the appropriate replacements made.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReplaceInPlace``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>
            Replace all items in a list or array equal to a particular value with another value. The replacement is done in-place, changing
            the list.
            </summary>
            <remarks><para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
            <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</para></remarks>
            <param name="list">The list or array to process.</param>
            <param name="itemFind">The value to find and replace within <paramref name="list"/>.</param>
            <param name="replaceWith">The new value to replace with.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReplaceInPlace``1(System.Collections.Generic.IList{``0},``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Replace all items in a list or array equal to a particular value with another values.
            The replacement is done in-place, changing
            the list. A passed IEqualityComparer is used to determine equality.
            </summary>
            <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</remarks>
            <param name="list">The list or array to process.</param>
            <param name="itemFind">The value to find and replace within <paramref name="equalityComparer"/>.</param>
            <param name="replaceWith">The new value to replace with.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReplaceInPlace``1(System.Collections.Generic.IList{``0},System.Predicate{``0},``0)">
            <summary>
            Replace all items in a list or array that a predicate evaluates at true with a value. The replacement is done in-place, changing
            the list.
            </summary>
            <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</remarks>
            <param name="list">The list or array to process.</param>
            <param name="predicate">The predicate used to evaluate items with the collection. If the predicate returns true for a particular
            item, the item is replaces with <paramref name="replaceWith"/>.</param>
            <param name="replaceWith">The new value to replace with.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.RemoveDuplicates``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Remove consecutive equal items from a collection, yielding another collection. In each run of consecutive equal items
            in the collection, all items after the first item in the run are removed. 
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
            <param name="collection">The collection to process.</param>
            <returns>An new collection with the items from <paramref name="collection"/>, in the same order, 
            with consecutive duplicates removed.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.RemoveDuplicates``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Remove consecutive equal items from a collection, yielding another collection. In each run of consecutive equal items
            in the collection, all items after the first item in the run are removed. A passed
            IEqualityComparer is used to determine equality.
            </summary>
            <param name="collection">The collection to process.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
            <returns>An new collection with the items from <paramref name="collection"/>, in the same order, 
            with consecutive duplicates removed.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> or <paramref name="equalityComparer"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.RemoveDuplicates``1(System.Collections.Generic.IEnumerable{``0},CodeSmith.Engine.PowerCollections.BinaryPredicate{``0})">
            <summary>
            Remove consecutive "equal" items from a collection, yielding another collection. In each run of consecutive equal items
            in the collection, all items after the first item in the run are removed. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
            <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. </remarks>
            <param name="collection">The collection to process.</param>
            <param name="predicate">The BinaryPredicate used to compare items for "equality". An item <c>current</c> is removed if <c>predicate(first, current)==true</c>, where
            <c>first</c> is the first item in the group of "duplicate" items.</param>
            <returns>An new collection with the items from <paramref name="collection"/>, in the same order, 
            with consecutive "duplicates" removed.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.RemoveDuplicatesInPlace``1(System.Collections.Generic.IList{``0})">
            <summary>
            Remove consecutive equal items from a list or array. In each run of consecutive equal items
            in the list, all items after the first item in the run are removed. The removal is done in-place, changing
            the list. 
            </summary>
            <remarks><para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
            <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</para></remarks>
            <param name="list">The list or array to process.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.RemoveDuplicatesInPlace``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Remove subsequent consecutive equal items from a list or array. In each run of consecutive equal items
            in the list, all items after the first item in the run are removed.
            The replacement is done in-place, changing
            the list. A passed IEqualityComparer is used to determine equality.
            </summary>
            <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</remarks>
            <param name="list">The list or array to process.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.RemoveDuplicatesInPlace``1(System.Collections.Generic.IList{``0},CodeSmith.Engine.PowerCollections.BinaryPredicate{``0})">
            <summary>
            Remove consecutive "equal" items from a list or array. In each run of consecutive equal items
            in the list, all items after the first item in the run are removed. The replacement is done in-place, changing
            the list. The passed BinaryPredicate is used to determine if two items are "equal".
            </summary>
            <remarks><para>Since an arbitrary BinaryPredicate is passed to this function, what is being tested for need not be true equality. </para>
            <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</para></remarks>
            <param name="list">The list or array to process.</param>
            <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FirstConsecutiveEqual``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Finds the first occurence of <paramref name="count"/> consecutive equal items in the
            list.
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
            <param name="list">The list to examine.</param>
            <param name="count">The number of consecutive equal items to look for. The count must be at least 1.</param>
            <returns>The index of the first item in the first run of <paramref name="count"/> consecutive equal items, or -1 if no such run exists..</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FirstConsecutiveEqual``1(System.Collections.Generic.IList{``0},System.Int32,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Finds the first occurence of <paramref name="count"/> consecutive equal items in the
            list. A passed IEqualityComparer is used to determine equality.
            </summary>
            <param name="list">The list to examine.</param>
            <param name="count">The number of consecutive equal items to look for. The count must be at least 1.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
            <returns>The index of the first item in the first run of <paramref name="count"/> consecutive equal items, or -1 if no such run exists.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FirstConsecutiveEqual``1(System.Collections.Generic.IList{``0},System.Int32,CodeSmith.Engine.PowerCollections.BinaryPredicate{``0})">
            <summary>
            Finds the first occurence of <paramref name="count"/> consecutive "equal" items in the
            list. The passed BinaryPredicate is used to determine if two items are "equal".
            </summary>
            <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being tested for need not be true equality. </remarks>
            <param name="list">The list to examine.</param>
            <param name="count">The number of consecutive equal items to look for. The count must be at least 1.</param>
            <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
            <returns>The index of the first item in the first run of <paramref name="count"/> consecutive equal items, or -1 if no such run exists.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FirstConsecutiveWhere``1(System.Collections.Generic.IList{``0},System.Int32,System.Predicate{``0})">
            <summary>
            Finds the first occurence of <paramref name="count"/> consecutive items in the
            list for which a given predicate returns true.
            </summary>
            <param name="list">The list to examine.</param>
            <param name="count">The number of consecutive items to look for. The count must be at least 1.</param>
            <param name="predicate">The predicate used to test each item.</param>
            <returns>The index of the first item in the first run of <paramref name="count"/> items where <paramref name="predicate"/>
            returns true for all items in the run, or -1 if no such run exists.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Finds the first item in a collection that satisfies the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <remarks>If the default value for T could be present in the collection, and 
            would be matched by the predicate, then this method is inappropriate, because
            you cannot disguish whether the default value for T was actually present in the collection,
            or no items matched the predicate. In this case, use TryFindFirstWhere.</remarks>
            <param name="collection">The collection to search.</param>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <returns>The first item in the collection that matches the condition, or the default value for T (0 or null) if no
            item that matches the condition is found.</returns>
            <seealso cref="M:CodeSmith.Engine.PowerCollections.Algorithms.TryFindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.TryFindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)">
            <summary>
            Finds the first item in a collection that satisfies the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <param name="collection">The collection to search.</param>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <param name="foundItem">Outputs the first item in the collection that matches the condition, if the method returns true.</param>
            <returns>True if an item satisfying the condition was found. False if no such item exists in the collection.</returns>
            <seealso cref="M:CodeSmith.Engine.PowerCollections.Algorithms.FindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Finds the last item in a collection that satisfies the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <remarks><para>If the collection implements IList&lt;T&gt;, then the list is scanned in reverse until a 
            matching item is found. Otherwise, the entire collection is iterated in the forward direction.</para>
            <para>If the default value for T could be present in the collection, and 
            would be matched by the predicate, then this method is inappropriate, because
            you cannot disguish whether the default value for T was actually present in the collection,
            or no items matched the predicate. In this case, use TryFindFirstWhere.</para></remarks>
            <param name="collection">The collection to search.</param>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <returns>The last item in the collection that matches the condition, or the default value for T (0 or null) if no
            item that matches the condition is found.</returns>
            <seealso cref="M:CodeSmith.Engine.PowerCollections.Algorithms.TryFindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.TryFindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)">
            <summary>
            Finds the last item in a collection that satisfies the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <remarks>If the collection implements IList&lt;T&gt;, then the list is scanned in reverse until a 
            matching item is found. Otherwise, the entire collection is iterated in the forward direction.</remarks>
            <param name="collection">The collection to search.</param>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <param name="foundItem">Outputs the last item in the collection that matches the condition, if the method returns true.</param>
            <returns>True if an item satisfying the condition was found. False if no such item exists in the collection.</returns>
            <seealso cref="M:CodeSmith.Engine.PowerCollections.Algorithms.FindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FindWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Enumerates all the items in <paramref name="collection"/> that satisfy the condition defined
            by <paramref name="predicate"/>.
            </summary>
            <param name="collection">The collection to check all the items in.</param>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>An IEnumerable&lt;T&gt; that enumerates the items that satisfy the condition.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FindFirstIndexWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>
            Finds the index of the first item in a list that satisfies the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <param name="list">The list to search.</param>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <returns>The index of the first item satisfying the condition. -1 if no such item exists in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FindLastIndexWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>
            Finds the index of the last item in a list that satisfies the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <param name="list">The list to search.</param>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <returns>The index of the last item satisfying the condition. -1 if no such item exists in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FindIndicesWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>
            Enumerates the indices of all the items in <paramref name="list"/> that satisfy the condition defined
            by <paramref name="predicate"/>.
            </summary>
            <param name="list">The list to check all the items in.</param>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items that satisfy the condition.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FirstIndexOf``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Finds the index of the first item in a list equal to a given item.
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
            <param name="list">The list to search.</param>
            <param name="item">The item to search for.</param>
            <returns>The index of the first item equal to <paramref name="item"/>. -1 if no such item exists in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FirstIndexOf``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Finds the index of the first item in a list equal to a given item. A passed
            IEqualityComparer is used to determine equality.
            </summary>
            <param name="list">The list to search.</param>
            <param name="item">The item to search for.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
            <returns>The index of the first item equal to <paramref name="item"/>. -1 if no such item exists in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.LastIndexOf``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Finds the index of the last item in a list equal to a given item.
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
            <param name="list">The list to search.</param>
            <param name="item">The item to search for.</param>
            <returns>The index of the last item equal to <paramref name="item"/>. -1 if no such item exists in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.LastIndexOf``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Finds the index of the last item in a list equal to a given item. A passed
            IEqualityComparer is used to determine equality.
            </summary>
            <param name="list">The list to search.</param>
            <param name="item">The item to search for.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
            <returns>The index of the last item equal to <paramref name="item"/>. -1 if no such item exists in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IndicesOf``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Enumerates the indices of all the items in a list equal to a given item.
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
            <param name="list">The list to search.</param>
            <param name="item">The item to search for.</param>
            <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to <paramref name="item"/>. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IndicesOf``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Enumerates the indices of all the items in a list equal to a given item. A passed
            IEqualityComparer is used to determine equality.
            </summary>
            <param name="list">The list to search.</param>
            <param name="item">The item to search for.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
            <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to <paramref name="item"/>. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FirstIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Finds the index of the first item in a list equal to one of several given items.
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
            <param name="list">The list to search.</param>
            <param name="itemsToLookFor">The items to search for.</param>
            <returns>The index of the first item equal to any of the items in the collection <paramref name="itemsToLookFor"/>. 
            -1 if no such item exists in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FirstIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Finds the index of the first item in a list equal to one of several given items. A passed
            IEqualityComparer is used to determine equality.
            </summary>
            <param name="list">The list to search.</param>
            <param name="itemsToLookFor">The items to search for.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode methods will be called.</param>
            <returns>The index of the first item equal to any of the items in the collection <paramref name="itemsToLookFor"/>. 
            -1 if no such item exists in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FirstIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},CodeSmith.Engine.PowerCollections.BinaryPredicate{``0})">
            <summary>
            Finds the index of the first item in a list "equal" to one of several given items. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
            <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. This methods finds 
            first item X which satisfies BinaryPredicate(X,Y), where Y is one of the items in <paramref name="itemsToLookFor"/></remarks>
            <param name="list">The list to search.</param>
            <param name="itemsToLookFor">The items to search for.</param>
            <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
            <returns>The index of the first item "equal" to any of the items in the collection <paramref name="itemsToLookFor"/>, using 
            <paramref name="predicate"/> as the test for equality. 
            -1 if no such item exists in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.LastIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Finds the index of the last item in a list equal to one of several given items.
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
            <param name="list">The list to search.</param>
            <param name="itemsToLookFor">The items to search for.</param>
            <returns>The index of the last item equal to any of the items in the collection <paramref name="itemsToLookFor"/>. 
            -1 if no such item exists in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.LastIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Finds the index of the last item in a list equal to one of several given items. A passed
            IEqualityComparer is used to determine equality.
            </summary>
            <param name="list">The list to search.</param>
            <param name="itemsToLookFor">The items to search for.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality.</param>
            <returns>The index of the last item equal to any of the items in the collection <paramref name="itemsToLookFor"/>. 
            -1 if no such item exists in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.LastIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},CodeSmith.Engine.PowerCollections.BinaryPredicate{``0})">
            <summary>
            Finds the index of the last item in a list "equal" to one of several given items. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
            <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. This methods finds 
            last item X which satisfies BinaryPredicate(X,Y), where Y is one of the items in <paramref name="itemsToLookFor"/></remarks>
            <param name="list">The list to search.</param>
            <param name="itemsToLookFor">The items to search for.</param>
            <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
            <returns>The index of the last item "equal" to any of the items in the collection <paramref name="itemsToLookFor"/>, using 
            <paramref name="predicate"/> as the test for equality. 
            -1 if no such item exists in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IndicesOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Enumerates the indices of all the items in a list equal to one of several given items. 
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
            <param name="list">The list to search.</param>
            <param name="itemsToLookFor">A collection of items to search for.</param>
            <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to
            any of the items in the collection <paramref name="itemsToLookFor"/>. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IndicesOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Enumerates the indices of all the items in a list equal to one of several given items. A passed
            IEqualityComparer is used to determine equality.
            </summary>
            <param name="list">The list to search.</param>
            <param name="itemsToLookFor">A collection of items to search for.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. </param>
            <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to
            any of the items in the collection <paramref name="itemsToLookFor"/>. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IndicesOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},CodeSmith.Engine.PowerCollections.BinaryPredicate{``0})">
            <summary>
            Enumerates the indices of all the items in a list equal to one of several given items. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
            <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. This methods finds 
            last item X which satisfies BinaryPredicate(X,Y), where Y is one of the items in <paramref name="itemsToLookFor"/></remarks>
            <param name="list">The list to search.</param>
            <param name="itemsToLookFor">A collection of items to search for.</param>
            <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
            <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items "equal" to any of the items 
            in the collection <paramref name="itemsToLookFor"/>, using 
            <paramref name="predicate"/> as the test for equality. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.SearchForSubsequence``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Searchs a list for a sub-sequence of items that match a particular pattern. A subsequence 
            of <paramref name="list"/> matches pattern at index i if list[i] is equal to the first item
            in <paramref name="pattern"/>, list[i+1] is equal to the second item in <paramref name="pattern"/>,
            and so forth for all the items in <paramref name="pattern"/>.
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
            <typeparam name="T">The type of items in the list.</typeparam>
            <param name="list">The list to search.</param>
            <param name="pattern">The sequence of items to search for.</param>
            <returns>The first index with <paramref name="list"/> that matches the items in <paramref name="pattern"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.SearchForSubsequence``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},CodeSmith.Engine.PowerCollections.BinaryPredicate{``0})">
            <summary>
            Searchs a list for a sub-sequence of items that match a particular pattern. A subsequence 
            of <paramref name="list"/> matches pattern at index i if list[i] is "equal" to the first item
            in <paramref name="pattern"/>, list[i+1] is "equal" to the second item in <paramref name="pattern"/>,
            and so forth for all the items in <paramref name="pattern"/>. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
            <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being tested
            for in the pattern need not be equality. </remarks>
            <typeparam name="T">The type of items in the list.</typeparam>
            <param name="list">The list to search.</param>
            <param name="pattern">The sequence of items to search for.</param>
            <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
            <returns>The first index with <paramref name="list"/> that matches the items in <paramref name="pattern"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.SearchForSubsequence``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Searchs a list for a sub-sequence of items that match a particular pattern. A subsequence 
            of <paramref name="list"/> matches pattern at index i if list[i] is equal to the first item
            in <paramref name="pattern"/>, list[i+1] is equal to the second item in <paramref name="pattern"/>,
            and so forth for all the items in <paramref name="pattern"/>. The passed 
            instance of IEqualityComparer&lt;T&gt; is used for determining if two items are equal.
            </summary>
            <typeparam name="T">The type of items in the list.</typeparam>
            <param name="list">The list to search.</param>
            <param name="pattern">The sequence of items to search for.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
            <returns>The first index with <paramref name="list"/> that matches the items in <paramref name="pattern"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IsSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines if one collection is a subset of another, considered as sets. The first set is a subset
            of the second set if every item in the first set also occurs in the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
            <remarks>
            <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
            </remarks>
            <param name="collection1">The first collection.</param>
            <param name="collection2">The second collection.</param>
            <returns>True if <paramref name="collection1"/> is a subset of <paramref name="collection2"/>, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IsSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines if one collection is a subset of another, considered as sets. The first set is a subset
            of the second set if every item in the first set also occurs in the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
            <remarks>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
            </remarks>
            <param name="collection1">The first collection.</param>
            <param name="collection2">The second collection.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality.</param>
            <returns>True if <paramref name="collection1"/> is a subset of <paramref name="collection2"/>, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IsProperSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines if one collection is a proper subset of another, considered as sets. The first set is a proper subset
            of the second set if every item in the first set also occurs in the second set, and the first set is strictly smaller than
            the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
            <remarks>
            <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
            </remarks>
            <param name="collection1">The first collection.</param>
            <param name="collection2">The second collection.</param>
            <returns>True if <paramref name="collection1"/> is a subset of <paramref name="collection2"/>, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IsProperSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines if one collection is a proper subset of another, considered as sets. The first set is a proper subset
            of the second set if every item in the first set also occurs in the second set, and the first set is strictly smaller than
            the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
            <remarks>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
            </remarks>
            <param name="collection1">The first collection.</param>
            <param name="collection2">The second collection.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
            <returns>True if <paramref name="collection1"/> is a proper subset of <paramref name="collection2"/>, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.DisjointSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines if two collections are disjoint, considered as sets. Two sets are disjoint if they
            have no common items.
            </summary>
            <remarks>
            <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsDisjoint method on that class.</para>
            </remarks>
            <param name="collection1">The first collection.</param>
            <param name="collection2">The second collection.</param>
            <returns>True if <paramref name="collection1"/> are <paramref name="collection2"/> are disjoint, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.DisjointSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines if two collections are disjoint, considered as sets. Two sets are disjoint if they
            have no common items.
            </summary>
            <remarks>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsDisjoint method on that class.</para>
            </remarks>
            <param name="collection1">The first collection.</param>
            <param name="collection2">The second collection.</param>
            <param name="equalityComparer">The IEqualityComparerComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
            <returns>True if <paramref name="collection1"/> are <paramref name="collection2"/> are disjoint, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines if two collections are equal, considered as sets. Two sets are equal if they
            have have the same items, with order not being significant.
            </summary>
            <remarks>
            <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the EqualTo method on that class.</para>
            </remarks>
            <param name="collection1">The first collection.</param>
            <param name="collection2">The second collection.</param>
            <returns>True if <paramref name="collection1"/> are <paramref name="collection2"/> are equal, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines if two collections are equal, considered as sets. Two sets are equal if they
            have have the same items, with order not being significant.
            </summary>
            <remarks>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the EqualTo method on that class.</para>
            </remarks>
            <param name="collection1">The first collection.</param>
            <param name="collection2">The second collection.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
            <returns>True if <paramref name="collection1"/> are <paramref name="collection2"/> are equal, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.SetIntersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Computes the set-theoretic intersection of two collections. The intersection of two sets
            is all items that appear in both of the sets. If an item appears X times in one set,
            and Y times in the other set, the intersection contains the item Minimum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the intersection of the collections; the order of the
            items in this collection is undefined.
            </summary>
            <remarks>
            <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Intersection or IntersectionWith methods on that class.</para>
            </remarks>
            <param name="collection1">The first collection to intersect.</param>
            <param name="collection2">The second collection to intersect.</param>
            <returns>The intersection of the two collections, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.SetIntersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Computes the set-theoretic intersection of two collections. The intersection of two sets
            is all items that appear in both of the sets. If an item appears X times in one set,
            and Y times in the other set, the intersection contains the item Minimum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the intersection of the collections; the order of the
            items in this collection is undefined.
            </summary>
            <remarks>
            <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Intersection or IntersectionWith methods on that class.</para>
            </remarks>
            <param name="collection1">The first collection to intersect.</param>
            <param name="collection2">The second collection to intersect.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
            <returns>The intersection of the two collections, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.SetUnion``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Computes the set-theoretic union of two collections. The union of two sets
            is all items that appear in either of the sets. If an item appears X times in one set,
            and Y times in the other set, the union contains the item Maximum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the union of the collections; the order of the
            items in this collection is undefined.
            </summary>
            <remarks>
            <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Union or UnionWith methods on that class.</para>
            </remarks>
            <param name="collection1">The first collection to union.</param>
            <param name="collection2">The second collection to union.</param>
            <returns>The union of the two collections, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.SetUnion``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Computes the set-theoretic union of two collections. The union of two sets
            is all items that appear in either of the sets. If an item appears X times in one set,
            and Y times in the other set, the union contains the item Maximum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the union of the collections; the order of the
            items in this collection is undefined.
            </summary>
            <remarks>
            <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the union or unionWith methods on that class.</para>
            </remarks>
            <param name="collection1">The first collection to union.</param>
            <param name="collection2">The second collection to union.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
            <returns>The union of the two collections, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.SetDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Computes the set-theoretic difference of two collections. The difference of two sets
            is all items that appear in the first set, but not in the second. If an item appears X times in the first set,
            and Y times in the second set, the difference contains the item X - Y times (0 times if X &lt; Y). 
            The source collections are not changed.
            A new collection is created with the difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
            <remarks>
            <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Difference or DifferenceWith methods on that class.</para>
            </remarks>
            <param name="collection1">The first collection to difference.</param>
            <param name="collection2">The second collection to difference.</param>
            <returns>The difference of <paramref name="collection1"/> and <paramref name="collection2"/>, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.SetDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Computes the set-theoretic difference of two collections. The difference of two sets
            is all items that appear in the first set, but not in the second. If an item appears X times in the first set,
            and Y times in the second set, the difference contains the item X - Y times (0 times if X &lt; Y). 
            The source collections are not changed.
            A new collection is created with the difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
            <remarks>
            <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the difference or differenceWith methods on that class.</para>
            </remarks>
            <param name="collection1">The first collection to difference.</param>
            <param name="collection2">The second collection to difference.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
            <returns>The difference of <paramref name="collection1"/> and <paramref name="collection2"/>, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.SetSymmetricDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Computes the set-theoretic symmetric difference of two collections. The symmetric difference of two sets
            is all items that appear in the one of the sets, but not in the other. If an item appears X times in the one set,
            and Y times in the other set, the symmetric difference contains the item AbsoluteValue(X - Y) times. 
            The source collections are not changed.
            A new collection is created with the symmetric difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
            <remarks>
            <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the SymmetricDifference or SymmetricDifferenceWith methods on that class.</para>
            </remarks>
            <param name="collection1">The first collection to symmetric difference.</param>
            <param name="collection2">The second collection to symmetric difference.</param>
            <returns>The symmetric difference of <paramref name="collection1"/> and <paramref name="collection2"/>, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.SetSymmetricDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Computes the set-theoretic symmetric difference of two collections. The symmetric difference of two sets
            is all items that appear in the one of the sets, but not in the other. If an item appears X times in the one set,
            and Y times in the other set, the symmetric difference contains the item AbsoluteValue(X - Y) times. 
            The source collections are not changed.
            A new collection is created with the symmetric difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
            <remarks>
            <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the symmetric difference or symmetric differenceWith methods on that class.</para>
            </remarks>
            <param name="collection1">The first collection to symmetric difference.</param>
            <param name="collection2">The second collection to symmetric difference.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
            <returns>The symmetric difference of <paramref name="collection1"/> and <paramref name="collection2"/>, considered as sets.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/> or <paramref name="collection2"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.CartesianProduct``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Computes the cartestian product of two collections: all possible pairs of items, with the first item taken from the first collection and 
            the second item taken from the second collection. If the first collection has N items, and the second collection has M items, the cartesian
            product will have N * M pairs.
            </summary>
            <typeparam name="TFirst">The type of items in the first collection.</typeparam>
            <typeparam name="TSecond">The type of items in the second collection.</typeparam>
            <param name="first">The first collection.</param>
            <param name="second">The second collection.</param>
            <returns>An IEnumerable&lt;Pair&lt;TFirst, TSecond&gt;&gt; that enumerates the cartesian product of the two collections.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ToString``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets a string representation of the elements in the collection.
            The string representation starts with "{", has a list of items separated
            by commas (","), and ends with "}". Each item in the collection is 
            converted to a string by calling its ToString method (null is represented by "null").
            Contained collections (except strings) are recursively converted to strings by this method.
            </summary>
            <param name="collection">A collection to get the string representation of.</param>
            <returns>The string representation of the collection. If <paramref name="collection"/> is null, then the string "null" is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ToString``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,System.String,System.String,System.String)">
            <summary>
            Gets a string representation of the elements in the collection.
            The string to used at the beginning and end, and to separate items,
            and supplied by parameters. Each item in the collection is 
            converted to a string by calling its ToString method (null is represented by "null").
            </summary>
            <param name="collection">A collection to get the string representation of.</param>
            <param name="recursive">If true, contained collections (except strings) are converted to strings by a recursive call to this method, instead
            of by calling ToString.</param>
            <param name="start">The string to appear at the beginning of the output string.</param>
            <param name="separator">The string to appear between each item in the string.</param>
            <param name="end">The string to appear at the end of the output string.</param>
            <returns>The string representation of the collection. If <paramref name="collection"/> is null, then the string "null" is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="start"/>, <paramref name="separator"/>, or <paramref name="end"/>
             is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ToString``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Gets a string representation of the mappings in a dictionary.
            The string representation starts with "{", has a list of mappings separated
            by commas (", "), and ends with "}". Each mapping is represented
            by "key->value". Each key and value in the dictionary is 
            converted to a string by calling its ToString method (null is represented by "null").
            Contained collections (except strings) are recursively converted to strings by this method.
            </summary>
            <param name="dictionary">A dictionary to get the string representation of.</param>
            <returns>The string representation of the collection, or "null" 
            if <paramref name="dictionary"/> is null.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetRandomGenerator">
            <summary>
            Return a private random number generator to use if the user
            doesn't supply one.
            </summary>
            <returns>The private random number generator. Only one is ever created
            and is always returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.RandomShuffle``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Randomly shuffles the items in a collection, yielding a new collection.
            </summary>
            <typeparam name="T">The type of the items in the collection.</typeparam>
            <param name="collection">The collection to shuffle.</param>
            <returns>An array with the same size and items as <paramref name="collection"/>, but the items in a randomly chosen order.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.RandomShuffle``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
            <summary>
            Randomly shuffles the items in a collection, yielding a new collection.
            </summary>
            <typeparam name="T">The type of the items in the collection.</typeparam>
            <param name="collection">The collection to shuffle.</param>
            <param name="randomGenerator">The random number generator to use to select the random order.</param>
            <returns>An array with the same size and items as <paramref name="collection"/>, but the items in a randomly chosen order.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.RandomShuffleInPlace``1(System.Collections.Generic.IList{``0})">
            <summary>
            Randomly shuffles the items in a list or array, in place.
            </summary>
            <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</remarks>
            <param name="list">The list or array to shuffle.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.RandomShuffleInPlace``1(System.Collections.Generic.IList{``0},System.Random)">
            <summary>
            Randomly shuffles the items in a list or array, in place.
            </summary>
            <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</remarks>
            <param name="list">The list or array to shuffle.</param>
            <param name="randomGenerator">The random number generator to use to select the random order.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.RandomSubset``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Picks a random subset of <paramref name="count"/> items from <paramref name="collection"/>, and places
            those items into a random order. No item is selected more than once.
            </summary>
            <remarks>If the collection implements IList&lt;T&gt;, then this method takes time O(<paramref name="count"/>).
            Otherwise, this method takes time O(N), where N is the number of items in the collection.</remarks>
            <typeparam name="T">The type of items in the collection.</typeparam>
            <param name="collection">The collection of items to select from. This collection is not changed.</param>
            <param name="count">The number of items in the subset to choose.</param>
            <returns>An array of <paramref name="count"/> items, selected at random from <paramref name="collection"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is negative or greater than <paramref name="collection"/>.Count.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.RandomSubset``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Random)">
            <summary>
            Picks a random subset of <paramref name="count"/> items from <paramref name="collection"/>, and places
            those items into a random order. No item is selected more than once.
            </summary>
            <remarks>If the collection implements IList&lt;T&gt;, then this method takes time O(<paramref name="count"/>).
            Otherwise, this method takes time O(N), where N is the number of items in the collection.</remarks>
            <typeparam name="T">The type of items in the collection.</typeparam>
            <param name="collection">The collection of items to select from. This collection is not changed.</param>
            <param name="count">The number of items in the subset to choose.</param>
            <param name="randomGenerator">The random number generates used to make the selection.</param>
            <returns>An array of <paramref name="count"/> items, selected at random from <paramref name="collection"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is negative or greater than <paramref name="collection"/>.Count.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="randomGenerator"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GeneratePermutations``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Generates all the possible permutations of the items in <paramref name="collection"/>. If <paramref name="collection"/>
            has N items, then N factorial permutations will be generated. This method does not compare the items to determine if
            any of them are equal. If some items are equal, the same permutation may be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate the six permutations, AAB, AAB,
            ABA, ABA, BAA, BAA (not necessarily in that order). To take equal items into account, use the GenerateSortedPermutations
            method.
            </summary>
            <typeparam name="T">The type of items to permute.</typeparam>
            <param name="collection">The collection of items to permute.</param>
            <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection"/>. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GenerateSortedPermutations``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Generates all the possible permutations of the items in <paramref name="collection"/>, in lexicographical order. 
            Even if some items are equal, the same permutation will not be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate only the three permutations, AAB, ABA,
            BAA. 
            </summary>
            <typeparam name="T">The type of items to permute.</typeparam>
            <param name="collection">The collection of items to permute.</param>
            <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection"/>. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GenerateSortedPermutations``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Generates all the possible permutations of the items in <paramref name="collection"/>, in lexicographical order. A
            supplied IComparer&lt;T&gt; instance is used to compare the items.
            Even if some items are equal, the same permutation will not be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate only the three permutations, AAB, ABA,
            BAA. 
            </summary>
            <typeparam name="T">The type of items to permute.</typeparam>
            <param name="collection">The collection of items to permute.</param>
            <param name="comparer">The IComparer&lt;T&gt; used to compare the items.</param>
            <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection"/>. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GenerateSortedPermutations``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Generates all the possible permutations of the items in <paramref name="collection"/>, in lexicographical order. A
            supplied Comparison&lt;T&gt; delegate is used to compare the items.
            Even if some items are equal, the same permutation will not be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate only the three permutations, AAB, ABA,
            BAA. 
            </summary>
            <typeparam name="T">The type of items to permute.</typeparam>
            <param name="collection">The collection of items to permute.</param>
            <param name="comparison">The Comparison&lt;T&gt; delegate used to compare the items.</param>
            <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection"/>. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Maximum``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Finds the maximum value in a collection.
            </summary>
            <remarks>Values in the collection are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
            <typeparam name="T">The type of items in the collection.</typeparam>
            <param name="collection">The collection to search.</param>
            <returns>The largest item in the collection. </returns>
            <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Maximum``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Finds the maximum value in a collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection.
            </summary>
            <typeparam name="T">The type of items in the collection.</typeparam>
            <param name="collection">The collection to search.</param>
            <param name="comparer">The comparer instance used to compare items in the collection.</param>
            <returns>The largest item in the collection.</returns>
            <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> or <paramref name="comparer"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Maximum``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Finds the maximum value in a collection. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
            <typeparam name="T">The type of items in the collection.</typeparam>
            <param name="collection">The collection to search.</param>
            <param name="comparison">The comparison used to compare items in the collection.</param>
            <returns>The largest item in the collection.</returns>
            <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> or <paramref name="comparison"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Minimum``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Finds the minimum value in a collection.
            </summary>
            <remarks>Values in the collection are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
            <typeparam name="T">The type of items in the collection.</typeparam>
            <param name="collection">The collection to search.</param>
            <returns>The smallest item in the collection.</returns>
            <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Minimum``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Finds the minimum value in a collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection.
            </summary>
            <typeparam name="T">The type of items in the collection.</typeparam>
            <param name="collection">The collection to search.</param>
            <param name="comparer">The comparer instance used to compare items in the collection.</param>
            <returns>The smallest item in the collection.</returns>
            <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> or <paramref name="comparer"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Minimum``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Finds the minimum value in a collection. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
            <typeparam name="T">The type of items in the collection.</typeparam>
            <param name="collection">The collection to search.</param>
            <param name="comparison">The comparison used to compare items in the collection.</param>
            <returns>The smallest item in the collection.</returns>
            <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> or <paramref name="comparison"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IndexOfMaximum``1(System.Collections.Generic.IList{``0})">
            <summary>
            Finds the index of the maximum value in a list.
            </summary>
            <remarks>Values in the list are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
            <typeparam name="T">The type of items in the list.</typeparam>
            <param name="list">The list to search.</param>
            <returns>The index of the largest item in the list. If the maximum value appears
            multiple times, the index of the first appearance is used. If the list is empty, -1 is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IndexOfMaximum``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Finds the index of the maximum value in a list. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
            <typeparam name="T">The type of items in the list.</typeparam>
            <param name="list">The list to search.</param>
            <param name="comparer">The comparer instance used to compare items in the collection.</param>
            <returns>The index of the largest item in the list. If the maximum value appears
            multiple times, the index of the first appearance is used. If the list is empty, -1 is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> or <paramref name="comparer"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IndexOfMaximum``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <summary>
            Finds the index of the maximum value in a list. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
            <typeparam name="T">The type of items in the list.</typeparam>
            <param name="list">The list to search.</param>
            <param name="comparison">The comparison used to compare items in the collection.</param>
            <returns>The index of the largest item in the list. If the maximum value appears
            multiple times, the index of the first appearance is used. If the list is empty, -1 is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> or <paramref name="comparison"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IndexOfMinimum``1(System.Collections.Generic.IList{``0})">
            <summary>
            Finds the index of the minimum value in a list.
            </summary>
            <remarks>Values in the list are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
            <typeparam name="T">The type of items in the list.</typeparam>
            <param name="list">The list to search.</param>
            <returns>The index of the smallest item in the list. If the minimum value appears
            multiple times, the index of the first appearance is used.</returns>
            <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IndexOfMinimum``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Finds the index of the minimum value in a list. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
            <typeparam name="T">The type of items in the list.</typeparam>
            <param name="list">The list to search.</param>
            <param name="comparer">The comparer instance used to compare items in the collection.</param>
            <returns>The index of the smallest item in the list. If the minimum value appears
            multiple times, the index of the first appearance is used.</returns>
            <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> or <paramref name="comparer"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.IndexOfMinimum``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <summary>
            Finds the index of the minimum value in a list. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
            <typeparam name="T">The type of items in the list.</typeparam>
            <param name="list">The list to search.</param>
            <param name="comparison">The comparison delegate used to compare items in the collection.</param>
            <returns>The index of the smallest item in the list. If the minimum value appears
            multiple times, the index of the first appearance is used.</returns>
            <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> or <paramref name="comparison"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Sort``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a sorted version of a collection.
            </summary>
            <remarks>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
            <param name="collection">The collection to sort.</param>
            <returns>An array containing the sorted version of the collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Sort``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a sorted version of a collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
            <param name="collection">The collection to sort.</param>
            <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
            <returns>An array containing the sorted version of the collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Sort``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Creates a sorted version of a collection. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
            <param name="collection">The collection to sort.</param>
            <param name="comparison">The comparison delegate used to compare items in the collection.</param>
            <returns>An array containing the sorted version of the collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.SortInPlace``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts a list or array in place.
            </summary>
            <remarks><para>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
            <para>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</para>
            <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</para></remarks>
            <param name="list">The list or array to sort.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.SortInPlace``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts a list or array in place. A supplied IComparer&lt;T&gt; is used
            to compare the items in the list. 
            </summary>
            <remarks><para>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
            <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</para></remarks>
            <param name="list">The list or array to sort.</param>
            <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.SortInPlace``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <summary>
            Sorts a list or array in place. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the list.
            </summary>
            <remarks><para>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
            <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</para></remarks>
            <param name="list">The list or array to sort.</param>
            <param name="comparison">The comparison delegate used to compare items in the collection.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.StableSort``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a sorted version of a collection. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection.
            </summary>
            <remarks>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
            <param name="collection">The collection to sort.</param>
            <returns>An array containing the sorted version of the collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.StableSort``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a sorted version of a collection. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
            <param name="collection">The collection to sort.</param>
            <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
            <returns>An array containing the sorted version of the collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.StableSort``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Creates a sorted version of a collection. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
            <remarks>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
            <param name="collection">The collection to sort.</param>
            <param name="comparison">The comparison delegate used to compare items in the collection.</param>
            <returns>An array containing the sorted version of the collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.StableSortInPlace``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts a list or array in place. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            </summary>
            <remarks><para>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</para>
            <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</para></remarks>
            <param name="list">The list or array to sort.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.StableSortInPlace``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts a list or array in place. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            A supplied IComparer&lt;T&gt; is used
            to compare the items in the list. 
            </summary>
            <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</remarks>
            <param name="list">The list or array to sort.</param>
            <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.StableSortInPlace``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <summary>
            Sorts a list or array in place. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the list.
            </summary>
            <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</remarks>
            <param name="list">The list or array to sort.</param>
            <param name="comparison">The comparison delegate used to compare items in the collection.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Int32@)">
            <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the natural ordering of the type (it's implementation of IComparable&lt;T&gt;).
            </summary>
            <param name="list">The sorted list to search.</param>
            <param name="item">The item to search for.</param>
            <param name="index">Returns the first index at which the item can be found. If the return
            value is zero, indicating that <paramref name="item"/> was not present in the list, then this
            returns the index at which <paramref name="item"/> could be inserted to maintain the sorted
            order of the list.</param>
            <returns>The number of items equal to <paramref name="item"/> that appear in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IComparer{``0},System.Int32@)">
            <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering in the passed instance of IComparer&lt;T&gt;.
            </summary>
            <param name="list">The sorted list to search.</param>
            <param name="item">The item to search for.</param>
            <param name="comparer">The comparer instance used to sort the list. Only
            the Compare method is used.</param>
            <param name="index">Returns the first index at which the item can be found. If the return
            value is zero, indicating that <paramref name="item"/> was not present in the list, then this
            returns the index at which <paramref name="item"/> could be inserted to maintain the sorted
            order of the list.</param>
            <returns>The number of items equal to <paramref name="item"/> that appear in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Comparison{``0},System.Int32@)">
            <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering in the passed Comparison&lt;T&gt; delegate.
            </summary>
            <param name="list">The sorted list to search.</param>
            <param name="item">The item to search for.</param>
            <param name="comparison">The comparison delegate used to sort the list.</param>
            <param name="index">Returns the first index at which the item can be found. If the return
            value is zero, indicating that <paramref name="item"/> was not present in the list, then this
            returns the index at which <paramref name="item"/> could be inserted to maintain the sorted
            order of the list.</param>
            <returns>The number of items equal to <paramref name="item"/> that appear in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.MergeSorted``1(System.Collections.Generic.IEnumerable{``0}[])">
            <summary>
            Merge several sorted collections into a single sorted collection. Each input collection must be sorted
            by the natural ordering of the type (it's implementation of IComparable&lt;T&gt;). The merging
            is stable; equal items maintain their ordering, and equal items in different collections are placed
            in the order of the collections.
            </summary>
            <param name="collections">The set of collections to merge. In many languages, this parameter
            can be specified as several individual parameters.</param>
            <returns>An IEnumerable&lt;T&gt; that enumerates all the items in all the collections
            in sorted order. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.MergeSorted``1(System.Collections.Generic.IComparer{``0},System.Collections.Generic.IEnumerable{``0}[])">
            <summary>
            Merge several sorted collections into a single sorted collection. Each input collection must be sorted
            by the ordering in the passed instance of IComparer&lt;T&gt;. The merging
            is stable; equal items maintain their ordering, and equal items in different collections are placed
            in the order of the collections.
            </summary>
            <param name="collections">The set of collections to merge. In many languages, this parameter
            can be specified as several individual parameters.</param>
            <param name="comparer">The comparer instance used to sort the list. Only
            the Compare method is used.</param>
            <returns>An IEnumerable&lt;T&gt; that enumerates all the items in all the collections
            in sorted order. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.MergeSorted``1(System.Comparison{``0},System.Collections.Generic.IEnumerable{``0}[])">
            <summary>
            Merge several sorted collections into a single sorted collection. Each input collection must be sorted
            by the ordering in the passed Comparison&lt;T&gt; delegate. The merging
            is stable; equal items maintain their ordering, and equal items in different collections are placed
            in the order of the collections.
            </summary>
            <param name="collections">The set of collections to merge. In many languages, this parameter
            can be specified as several individual parameters.</param>
            <param name="comparison">The comparison delegate used to sort the collections.</param>
            <returns>An IEnumerable&lt;T&gt; that enumerates all the items in all the collections
            in sorted order. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.LexicographicalCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Performs a lexicographical comparison of two sequences of values. A lexicographical comparison compares corresponding
            pairs of elements from two sequences in order. If the first element of sequence1 is less than the first element of sequence2, 
            then the comparison ends and the first sequence is lexicographically less than the second. If the first elements of each sequence
            are equal, then the comparison proceeds to the second element of each sequence. If one sequence is shorter than the other,
            but corresponding elements are all equal, then the shorter sequence is considered less than the longer one.
            </summary>
            <remarks>T must implement either IComparable&lt;T&gt; and this implementation is used
            to compare the items. </remarks>
            <typeparam name="T">Types of items to compare. This type must implement IComparable&lt;T&gt; to allow 
            items to be compared.</typeparam>
            <param name="sequence1">The first sequence to compare.</param>
            <param name="sequence2">The second sequence to compare.</param>
            <returns>Less than zero if <paramref name="sequence1"/> is lexicographically less than <paramref name="sequence2"/>.
            Greater than zero if <paramref name="sequence1"/> is lexicographically greater than <paramref name="sequence2"/>.
            Zero if <paramref name="sequence1"/> is equal to <paramref name="sequence2"/>.</returns>
            <exception cref="T:System.NotSupportedException">T does not implement IComparable&lt;T&gt; or IComparable.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.LexicographicalCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Performs a lexicographical comparison of two sequences of values, using a supplied comparison delegate. A lexicographical comparison compares corresponding
            pairs of elements from two sequences in order. If the first element of sequence1 is less than the first element of sequence2, 
            then the comparison ends and the first sequence is lexicographically less than the second. If the first elements of each sequence
            are equal, then the comparison proceeds to the second element of each sequence. If one sequence is shorter than the other,
            but corresponding elements are all equal, then the shorter sequence is considered less than the longer one.
            </summary>
            <typeparam name="T">Types of items to compare.</typeparam>
            <param name="sequence1">The first sequence to compare.</param>
            <param name="sequence2">The second sequence to compare.</param>
            <param name="comparison">The IComparison&lt;T&gt; delegate to compare items. 
            Only the Compare member function of this interface is called.</param>
            <returns>Less than zero if <paramref name="sequence1"/> is lexicographically less than <paramref name="sequence2"/>.
            Greater than zero if <paramref name="sequence1"/> is lexicographically greater than <paramref name="sequence2"/>.
            Zero if <paramref name="sequence1"/> is equal to <paramref name="sequence2"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.LexicographicalCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Performs a lexicographical comparison of two sequences of values, using a supplied comparer interface. A lexicographical comparison compares corresponding
            pairs of elements from two sequences in order. If the first element of sequence1 is less than the first element of sequence2, 
            then the comparison ends and the first sequence is lexicographically less than the second. If the first elements of each sequence
            are equal, then the comparison proceeds to the second element of each sequence. If one sequence is shorter than the other,
            but corresponding elements are all equal, then the shorter sequence is considered less than the longer one.
            </summary>
            <typeparam name="T">Types of items to compare.</typeparam>
            <param name="sequence1">The first sequence to compare.</param>
            <param name="sequence2">The second sequence to compare.</param>
            <param name="comparer">The IComparer&lt;T&gt; used to compare items. 
            Only the Compare member function of this interface is called.</param>
            <returns>Less than zero if <paramref name="sequence1"/> is lexicographically less than <paramref name="sequence2"/>.
            Greater than zero if <paramref name="sequence1"/> is lexicographically greater than <paramref name="sequence2"/>.
            Zero if <paramref name="sequence1"/> is equal to <paramref name="sequence2"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sequence1"/>, <paramref name="sequence2"/>, or 
            <paramref name="comparer"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetLexicographicalComparer``1">
            <summary>
            Creates an IComparer instance that can be used for comparing ordered
            sequences of type T; that is IEnumerable&lt;Tgt;. This comparer can be used
            for collections or algorithms that use sequences of T as an item type. The Lexicographical
            ordered of sequences is for comparison.
            </summary>
            <remarks>T must implement either IComparable&lt;T&gt; and this implementation is used
            to compare the items. </remarks>
            <returns>At IComparer&lt;IEnumerable&lt;T&gt;&gt; that compares sequences of T.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetLexicographicalComparer``1(System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates an IComparer instance that can be used for comparing ordered
            sequences of type T; that is IEnumerable&lt;Tgt;. This comparer can be uses
            for collections or algorithms that use sequences of T as an item type. The Lexicographics
            ordered of sequences is for comparison.
            </summary>
            <param name="comparer">A comparer instance used to compare individual items of type T.</param>
            <returns>At IComparer&lt;IEnumerable&lt;T&gt;&gt; that compares sequences of T.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetLexicographicalComparer``1(System.Comparison{``0})">
            <summary>
            Creates an IComparer instance that can be used for comparing ordered
            sequences of type T; that is IEnumerable&lt;Tgt;. This comparer can be uses
            for collections or algorithms that use sequences of T as an item type. The Lexicographics
            ordered of sequences is for comparison.
            </summary>
            <param name="comparison">A comparison delegate used to compare individual items of type T.</param>
            <returns>At IComparer&lt;IEnumerable&lt;T&gt;&gt; that compares sequences of T.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetReverseComparer``1(System.Collections.Generic.IComparer{``0})">
            <summary>
            Reverses the order of comparison of an IComparer&lt;T&gt;. The resulting comparer can be used,
            for example, to sort a collection in descending order. Equality and hash codes are unchanged.
            </summary>
            <typeparam name="T">The type of items thta are being compared.</typeparam>
            <param name="comparer">The comparer to reverse.</param>
            <returns>An IComparer&lt;T&gt; that compares items in the reverse order of <paramref name="comparer"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetIdentityComparer``1">
            <summary>
            Gets an IEqualityComparer&lt;T&gt; instance that can be used to compare objects
            of type T for object identity only. Two objects compare equal only if they
            are references to the same object. 
            </summary>
            <returns>An IEqualityComparer&lt;T&gt; instance for identity comparison.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetReverseComparison``1(System.Comparison{``0})">
            <summary>
            Reverses the order of comparison of an Comparison&lt;T&gt;. The resulting comparison can be used,
            for example, to sort a collection in descending order. 
            </summary>
            <typeparam name="T">The type of items that are being compared.</typeparam>
            <param name="comparison">The comparison to reverse.</param>
            <returns>A Comparison&lt;T&gt; that compares items in the reverse order of <paramref name="comparison"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparison"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetComparerFromComparison``1(System.Comparison{``0})">
            <summary>
            Given a comparison delegate that compares two items of type T, gets an
            IComparer&lt;T&gt; instance that performs the same comparison.
            </summary>
            <param name="comparison">The comparison delegate to use.</param>
            <returns>An IComparer&lt;T&gt; that performs the same comparing operation
            as <paramref name="comparison"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetComparisonFromComparer``1(System.Collections.Generic.IComparer{``0})">
            <summary>
            Given in IComparer&lt;T&gt; instenace that comparers two items from type T, 
            gets a Comparison delegate that performs the same comparison.
            </summary>
            <param name="comparer">The IComparer&lt;T&gt; instance to use.</param>
            <returns>A Comparison&lt;T&gt; delegate that performans the same comparing
            operation as <paramref name="comparer"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetCollectionEqualityComparer``1">
            <summary>
            Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, considered in order. This is the same notion of equality as
            in Algorithms.EqualCollections, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.
            </summary>
            <example>
            The following code creates a Dictionary where the keys are a collection of strings.
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetCollectionEqualityComparer&lt;string&gt;());
            </code>
            </example>
            <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality.</returns>
            <seealso cref="M:CodeSmith.Engine.PowerCollections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetCollectionEqualityComparer``1(System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            <para>Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, considered in order. This is the same notion of equality as
            in Algorithms.EqualCollections, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.</para>
            <para>An IEqualityComparer&lt;T&gt; is used to determine if individual T's are equal</para>
            </summary>
            <example>
            The following code creates a Dictionary where the keys are a collection of strings, compared in a case-insensitive way
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetCollectionEqualityComparer&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase));
            </code>
            </example>
            <param name="equalityComparer">An IEqualityComparer&lt;T&gt; implementation used to compare individual T's.</param>
            <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality.</returns>
            <seealso cref="M:CodeSmith.Engine.PowerCollections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetSetEqualityComparer``1">
            <summary>
            <para>Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, without regard to order. This is the same notion of equality as
            in Algorithms.EqualSets, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.</para>
            <para>An IEqualityComparer&lt;T&gt; is used to determine if individual T's are equal</para>
            </summary>
            <example>
            The following code creates a Dictionary where the keys are a set of strings, without regard to order
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetSetEqualityComparer&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase));
            </code>
            </example>
            <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality, without regard to order.</returns>
            <seealso cref="M:CodeSmith.Engine.PowerCollections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetSetEqualityComparer``1(System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, without regard to order. This is the same notion of equality as
            in Algorithms.EqualSets, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.
            </summary>
            <example>
            The following code creates a Dictionary where the keys are a set of strings, without regard to order
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetSetEqualityComparer&lt;string&gt;());
            </code>
            </example>
            <param name="equalityComparer">An IEqualityComparer&lt;T&gt; implementation used to compare individual T's.</param>
            <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality, without regard to order.</returns>
            <seealso cref="M:CodeSmith.Engine.PowerCollections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Determines if a collection contains any item that satisfies the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <param name="collection">The collection to check all the items in.</param>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>True if the collection contains one or more items that satisfy the condition
            defined by <paramref name="predicate"/>. False if the collection does not contain
            an item that satisfies <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.TrueForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Determines if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <param name="collection">The collection to check all the items in.</param>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>True if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate"/>, or if the collection is empty. False if one or more items
            in the collection do not satisfy <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.CountWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Counts the number of items in the collection that satisfy the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <param name="collection">The collection to count items in.</param>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>The number of items in the collection that satisfy <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.RemoveWhere``1(System.Collections.Generic.ICollection{``0},System.Predicate{``0})">
            <summary>
            Removes all the items in the collection that satisfy the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <remarks>If the collection if an array or implements IList&lt;T&gt;, an efficient algorithm that
            compacts items is used. If not, then ICollection&lt;T&gt;.Remove is used
            to remove items from the collection. If the collection is an array or fixed-size list,
            the non-removed elements are placed, in order, at the beginning of
            the list, and the remaining list items are filled with a default value (0 or null).</remarks>
            <param name="collection">The collection to check all the items in.</param>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>Returns a collection of the items that were removed. This collection contains the
            items in the same order that they orginally appeared in <paramref name="collection"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Convert``2(System.Collections.Generic.IEnumerable{``0},System.Converter{``0,``1})">
            <summary>
            Convert a collection of items by applying a delegate to each item in the collection. The resulting collection
            contains the result of applying <paramref name="converter"/> to each item in <paramref name="sourceCollection"/>, in
            order.
            </summary>
            <typeparam name="TSource">The type of items in the collection to convert.</typeparam>
            <typeparam name="TDest">The type each item is being converted to.</typeparam>
            <param name="sourceCollection">The collection of item being converted.</param>
            <param name="converter">A delegate to the method to call, passing each item in <paramref name="sourceCollection"/>.</param>
            <returns>The resulting collection from applying <paramref name="converter"/> to each item in <paramref name="sourceCollection"/>, in
            order.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sourceCollection"/> or <paramref name="converter"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetDictionaryConverter``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Creates a delegate that converts keys to values by used a dictionary to map values. Keys
            that a not present in the dictionary are converted to the default value (zero or null).
            </summary>
            <remarks>This delegate can be used as a parameter in Convert or ConvertAll methods to convert
            entire collections.</remarks>
            <param name="dictionary">The dictionary used to perform the conversion.</param>
            <returns>A delegate to a method that converts keys to values. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.GetDictionaryConverter``2(System.Collections.Generic.IDictionary{``0,``1},``1)">
            <summary>
            Creates a delegate that converts keys to values by used a dictionary to map values. Keys
            that a not present in the dictionary are converted to a supplied default value.
            </summary>
            <remarks>This delegate can be used as a parameter in Convert or ConvertAll methods to convert
            entire collections.</remarks>
            <param name="dictionary">The dictionary used to perform the conversion.</param>
            <param name="defaultValue">The result of the conversion for keys that are not present in the dictionary.</param>
            <returns>A delegate to a method that converts keys to values. </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Performs the specified action on each item in a collection.
            </summary>
            <param name="collection">The collection to process.</param>
            <param name="action">An Action delegate which is invoked for each item in <paramref name="collection"/>.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Partition``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>
            Partition a list or array based on a predicate. After partitioning, all items for which
            the predicate returned true precede all items for which the predicate returned false.
            </summary>
            <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</remarks>
            <param name="list">The list or array to partition.</param>
            <param name="predicate">A delegate that defines the partitioning condition.</param>
            <returns>The index of the first item in the second half of the partition; i.e., the first item for
            which <paramref name="predicate"/> returned false. If the predicate was true for all items
            in the list, list.Count is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.StablePartition``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>
            Partition a list or array based on a predicate. After partitioning, all items for which
            the predicate returned true precede all items for which the predicate returned false. 
            The partition is stable, which means that if items X and Y have the same result from
            the predicate, and X precedes Y in the original list, X will precede Y in the 
            partitioned list.
            </summary>
            <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</remarks>
            <param name="list">The list or array to partition.</param>
            <param name="predicate">A delegate that defines the partitioning condition.</param>
            <returns>The index of the first item in the second half of the partition; i.e., the first item for
            which <paramref name="predicate"/> returned false. If the predicate was true for all items
            in the list, list.Count is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Concatenate``1(System.Collections.Generic.IEnumerable{``0}[])">
            <summary>
            Concatenates all the items from several collections. The collections need not be of the same type, but
            must have the same item type.
            </summary>
            <param name="collections">The set of collections to concatenate. In many languages, this parameter
            can be specified as several individual parameters.</param>
            <returns>An IEnumerable that enumerates all the items in each of the collections, in order.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines if the two collections contain equal items in the same order. The two collections do not need
            to be of the same type; it is permissible to compare an array and an OrderedBag, for instance.
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
            <typeparam name="T">The type of items in the collections.</typeparam>
            <param name="collection1">The first collection to compare.</param>
            <param name="collection2">The second collection to compare.</param>
            <returns>True if the collections have equal items in the same order. If both collections are empty, true is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines if the two collections contain equal items in the same order. The passed 
            instance of IEqualityComparer&lt;T&gt; is used for determining if two items are equal.
            </summary>
            <typeparam name="T">The type of items in the collections.</typeparam>
            <param name="collection1">The first collection to compare.</param>
            <param name="collection2">The second collection to compare.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals member function of this interface is called.</param>
            <returns>True if the collections have equal items in the same order. If both collections are empty, true is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/>, <paramref name="collection2"/>, or
            <paramref name="equalityComparer"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},CodeSmith.Engine.PowerCollections.BinaryPredicate{``0})">
            <summary>
            Determines if the two collections contain "equal" items in the same order. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
            <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being tested
            for need not be equality. For example, the following code determines if each integer in
            list1 is less than or equal to the corresponding integer in list2.
            <code>
            List&lt;int&gt; list1, list2;
            if (EqualCollections(list1, list2, delegate(int x, int y) { return x &lt;= y; }) {
                // the check is true...
            }
            </code>
            </remarks>
            <typeparam name="T">The type of items in the collections.</typeparam>
            <param name="collection1">The first collection to compare.</param>
            <param name="collection2">The second collection to compare.</param>
            <param name="predicate">The BinaryPredicate used to compare items for "equality". 
            This predicate can compute any relation between two items; it need not represent equality or an equivalence relation.</param>
            <returns>True if <paramref name="predicate"/>returns true for each corresponding pair of
            items in the two collections. If both collections are empty, true is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/>, <paramref name="collection2"/>, or
            <paramref name="predicate"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Create an array with the items in a collection.
            </summary>
            <remarks>If <paramref name="collection"/> implements ICollection&lt;T&gt;T, then 
            ICollection&lt;T&gt;.CopyTo() is used to fill the array. Otherwise, the IEnumerable&lt;T&gt;.GetEnumerator()
            is used to fill the array.</remarks>
            <typeparam name="T">Element type of the collection.</typeparam>
            <param name="collection">Collection to create array from.</param>
            <returns>An array with the items from the collection, in enumeration order.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Count``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Count the number of items in an IEnumerable&lt;T&gt; collection. If 
            a more specific collection type is being used, it is more efficient to use
            the Count property, if one is provided.
            </summary>
            <remarks>If the collection implements ICollection&lt;T&gt;, this method
            simply returns ICollection&lt;T&gt;.Count. Otherwise, it enumerates all items
            and counts them.</remarks>
            <param name="collection">The collection to count items in.</param>
            <returns>The number of items in the collection.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.CountEqual``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Counts the number of items in the collection that are equal to <paramref name="find"/>.
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
            <param name="collection">The collection to count items in.</param>
            <param name="find">The item to compare to.</param>
            <returns>The number of items in the collection that are equal to <paramref name="find"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.CountEqual``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Counts the number of items in the collection that are equal to <paramref name="find"/>.
            </summary>
            <param name="collection">The collection to count items in.</param>
            <param name="find">The item to compare to.</param>
            <param name="equalityComparer">The comparer to use to determine if two items are equal. Only the Equals
            member function will be called.</param>
            <returns>The number of items in the collection that are equal to <paramref name="find"/>.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="collection"/> or <paramref name="equalityComparer"/>
            is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.NCopiesOf``1(System.Int32,``0)">
            <summary>
            Creates an IEnumerator that enumerates a given item <paramref name="n"/> times.
            </summary>
            <example>
            The following creates a list consisting of 1000 copies of the double 1.0.
            <code>
            List&lt;double&gt; list = new List&lt;double&gt;(Algorithms.NCopiesOf(1000, 1.0));
            </code></example>
            <param name="n">The number of times to enumerate the item.</param>
            <param name="item">The item that should occur in the enumeration.</param>
            <returns>An IEnumerable&lt;T&gt; that yields <paramref name="n"/> copies
            of <paramref name="item"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The argument <paramref name="n"/> is less than zero.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Fill``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Replaces each item in a list with a given value. The list does not change in size.
            </summary>
            <typeparam name="T">The type of items in the list.</typeparam>
            <param name="list">The list to modify.</param>
            <param name="value">The value to fill with.</param>
            <exception cref="T:System.ArgumentException"><paramref name="list"/> is a read-only list.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Fill``1(``0[],``0)">
            <summary>
            Replaces each item in a array with a given value. 
            </summary>
            <param name="array">The array to modify.</param>
            <param name="value">The value to fill with.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FillRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,``0)">
            <summary>
            Replaces each item in a part of a list with a given value.
            </summary>
            <typeparam name="T">The type of items in the list.</typeparam>
            <param name="list">The list to modify.</param>
            <param name="start">The index at which to start filling. The first index in the list has index 0.</param>
            <param name="count">The number of items to fill.</param>
            <param name="value">The value to fill with.</param>
            <exception cref="T:System.ArgumentException"><paramref name="list"/> is a read-only list.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> or <paramref name="count"/> is negative, or 
            <paramref name="start"/> + <paramref name="count"/> is greater than <paramref name="list"/>.Count.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.FillRange``1(``0[],System.Int32,System.Int32,``0)">
            <summary>
            Replaces each item in a part of a array with a given value.
            </summary>
            <param name="array">The array to modify.</param>
            <param name="start">The index at which to start filling. The first index in the array has index 0.</param>
            <param name="count">The number of items to fill.</param>
            <param name="value">The value to fill with.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> or <paramref name="count"/> is negative, or 
            <paramref name="start"/> + <paramref name="count"/> is greater than <paramref name="array"/>.Length.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Copy``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Copies all of the items from the collection <paramref name="source"/> to the list <paramref name="dest"/>, starting
            at the index <paramref name="destIndex"/>. If necessary, the size of the destination list is expanded.
            </summary>
            <param name="source">The collection that provide the source items. </param>
            <param name="dest">The list to store the items into.</param>
            <param name="destIndex">The index to begin copying items to.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="destIndex"/> is negative or 
            greater than <paramref name="dest"/>.Count.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> or <paramref name="dest"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Copy``1(System.Collections.Generic.IEnumerable{``0},``0[],System.Int32)">
            <summary>
            Copies all of the items from the collection <paramref name="source"/> to the array <paramref name="dest"/>, starting
            at the index <paramref name="destIndex"/>. 
            </summary>
            <param name="source">The collection that provide the source items. </param>
            <param name="dest">The array to store the items into.</param>
            <param name="destIndex">The index to begin copying items to.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="destIndex"/> is negative or 
            greater than <paramref name="dest"/>.Length.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> or <paramref name="dest"/> is null.</exception>
            <exception cref="T:System.ArgumentException">The collection has more items than will fit into the array. In this case, the array
            has been filled with as many items as fit before the exception is thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Copy``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Copies at most <paramref name="count"/> items from the collection <paramref name="source"/> to the list <paramref name="dest"/>, starting
            at the index <paramref name="destIndex"/>. If necessary, the size of the destination list is expanded. The source collection must not be
            the destination list or part thereof.
            </summary>
            <param name="source">The collection that provide the source items. </param>
            <param name="dest">The list to store the items into.</param>
            <param name="destIndex">The index to begin copying items to.</param>
            <param name="count">The maximum number of items to copy.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="destIndex"/> is negative or 
            greater than <paramref name="dest"/>.Count</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is negative.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> or <paramref name="dest"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Copy``1(System.Collections.Generic.IEnumerable{``0},``0[],System.Int32,System.Int32)">
            <summary>
            Copies at most <paramref name="count"/> items from the collection <paramref name="source"/> to the array <paramref name="dest"/>, starting
            at the index <paramref name="destIndex"/>. The source collection must not be
            the destination array or part thereof.
            </summary>
            <param name="source">The collection that provide the source items. </param>
            <param name="dest">The array to store the items into.</param>
            <param name="destIndex">The index to begin copying items to.</param>
            <param name="count">The maximum number of items to copy. The array must be large enought to fit this number of items.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="destIndex"/> is negative or 
            greater than <paramref name="dest"/>.Length.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is negative or <paramref name="destIndex"/> + <paramref name="count"/>
            is greater than <paramref name="dest"/>.Length.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> or <paramref name="dest"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Copy``1(System.Collections.Generic.IList{``0},System.Int32,System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Copies <paramref name="count"/> items from the list <paramref name="source"/>, starting at the index <paramref name="sourceIndex"/>, 
            to the list <paramref name="dest"/>, starting at the index <paramref name="destIndex"/>. If necessary, the size of the destination list is expanded.
            The source and destination lists may be the same.
            </summary>
            <param name="source">The collection that provide the source items. </param>
            <param name="sourceIndex">The index within <paramref name="source"/>to begin copying items from.</param>
            <param name="dest">The list to store the items into.</param>
            <param name="destIndex">The index within <paramref name="dest"/>to begin copying items to.</param>
            <param name="count">The maximum number of items to copy.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex"/> is negative or 
            greater than <paramref name="source"/>.Count</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="destIndex"/> is negative or 
            greater than <paramref name="dest"/>.Count</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is negative or too large.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> or <paramref name="dest"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Copy``1(System.Collections.Generic.IList{``0},System.Int32,``0[],System.Int32,System.Int32)">
            <summary>
            Copies <paramref name="count"/> items from the list or array <paramref name="source"/>, starting at the index <paramref name="sourceIndex"/>, 
            to the array <paramref name="dest"/>, starting at the index <paramref name="destIndex"/>. 
            The source may be the same as the destination array.
            </summary>
            <param name="source">The list or array that provide the source items. </param>
            <param name="sourceIndex">The index within <paramref name="source"/>to begin copying items from.</param>
            <param name="dest">The array to store the items into.</param>
            <param name="destIndex">The index within <paramref name="dest"/>to begin copying items to.</param>
            <param name="count">The maximum number of items to copy. The destination array must be large enough to hold this many items.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex"/> is negative or 
            greater than <paramref name="source"/>.Count</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="destIndex"/> is negative or 
            greater than <paramref name="dest"/>.Length</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is negative or too large.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> or <paramref name="dest"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Reverse``1(System.Collections.Generic.IList{``0})">
            <summary>
            Reverses a list and returns the reversed list, without changing the source list.
            </summary>
            <param name="source">The list to reverse.</param>
            <returns>A collection that contains the items from <paramref name="source"/> in reverse order.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReverseInPlace``1(System.Collections.Generic.IList{``0})">
            <summary>
            Reverses a list or array in place.
            </summary>
            <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</remarks>
            <param name="list">The list or array to reverse.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="list"/> is read only.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.Rotate``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Rotates a list and returns the rotated list, without changing the source list.
            </summary>
            <param name="source">The list to rotate.</param>
            <param name="amountToRotate">The number of elements to rotate. This value can be positive or negative. 
            For example, rotating by positive 3 means that source[3] is the first item in the returned collection.
            Rotating by negative 3 means that source[source.Count - 3] is the first item in the returned collection.</param>
            <returns>A collection that contains the items from <paramref name="source"/> in rotated order.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.RotateInPlace``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Rotates a list or array in place.
            </summary>
            <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list"/>.</remarks>
            <param name="list">The list or array to rotate.</param>
            <param name="amountToRotate">The number of elements to rotate. This value can be positive or negative. 
            For example, rotating by positive 3 means that list[3] is the first item in the resulting list.
            Rotating by negative 3 means that list[list.Count - 3] is the first item in the resulting list.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.ListRange`1">
            <summary>
            The class that is used to implement IList&lt;T&gt; to view a sub-range
            of a list. The object stores a wrapped list, and a start/count indicating
            a sub-range of the list. Insertion/deletions through the sub-range view
            cause the count to change also; insertions and deletions directly on
            the wrapped list do not.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.ListBase`1">
            <summary>
            ListBase is an abstract class that can be used as a base class for a read-write collection that needs 
            to implement the generic IList&lt;T&gt; and non-generic IList collections. The derived class needs
            to override the following methods: Count, Clear, Insert, RemoveAt, and the indexer. The implementation
            of all the other methods in IList&lt;T&gt; and IList are handled by ListBase.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.CollectionBase`1">
            <summary>
            CollectionBase is a base class that can be used to more easily implement the
            generic ICollection&lt;T&gt; and non-generic ICollection interfaces.
            </summary>
            <remarks>
            <para>To use CollectionBase as a base class, the derived class must override
            the Count, GetEnumerator, Add, Clear, and Remove methods. </para>
            <para>ICollection&lt;T&gt;.Contains need not be implemented by the
            derived class, but it should be strongly considered, because the CollectionBase implementation
            may not be very efficient.</para>
            </remarks>
            <typeparam name="T">The item type of the collection.</typeparam>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.#ctor">
            <summary>
            Creates a new CollectionBase. 
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.ToString">
            <summary>
            Shows the string representation of the collection. The string representation contains
            a list of the items in the collection. Contained collections (except string) are expanded
            recursively.
            </summary>
            <returns>The string representation of the collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.Add(`0)">
            <summary>
            Must be overridden to allow adding items to this collection.
            </summary>
            <remarks><p>This method is not abstract, although derived classes should always
            override it. It is not abstract because some derived classes may wish to reimplement
            Add with a different return type (typically bool). In C#, this can be accomplished
            with code like the following:</p>
            <code>
                public class MyCollection&lt;T&gt;: CollectionBase&lt;T&gt;, ICollection&lt;T&gt;
                {
                    public new bool Add(T item) {
                        /* Add the item */
                    }
             
                    void ICollection&lt;T&gt;.Add(T item) {
                        Add(item);
                    }
                }
            </code>
            </remarks>
            <param name="item">Item to be added to the collection.</param>
            <exception cref="T:System.NotImplementedException">Always throws this exception to indicated
            that the method must be overridden or re-implemented in the derived class.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.Clear">
            <summary>
            Must be overridden to allow clearing this collection.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.Remove(`0)">
            <summary>
            Must be overridden to allow removing items from this collection.
            </summary>
            <returns>True if <paramref name="item"/> existed in the collection and
            was removed. False if <paramref name="item"/> did not exist in the collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.Contains(`0)">
            <summary>
            Determines if the collection contains a particular item. This default implementation
            iterates all of the items in the collection via GetEnumerator, testing each item
            against <paramref name="item"/> using IComparable&lt;T&gt;.Equals or
            Object.Equals.
            </summary>
            <remarks>You should strongly consider overriding this method to provide
            a more efficient implementation, or if the default equality comparison
            is inappropriate.</remarks>
            <param name="item">The item to check for in the collection.</param>
            <returns>True if the collection contains <paramref name="item"/>, false otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies all the items in the collection into an array. Implemented by
            using the enumerator returned from GetEnumerator to get all the items
            and copy them to the provided array.
            </summary>
            <param name="array">Array to copy to.</param>
            <param name="arrayIndex">Starting index in <paramref name="array"/> to copy to.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.ToArray">
            <summary>
            Creates an array of the correct size, and copies all the items in the 
            collection into the array, by calling CopyTo.
            </summary>
            <returns>An array containing all the elements in the collection, in order.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.AsReadOnly">
            <summary>
            Provides a read-only view of this collection. The returned ICollection&lt;T&gt; provides
            a view of the collection that prevents modifications to the collection. Use the method to provide
            access to the collection without allowing changes. Since the returned object is just a view,
            changes to the collection will be reflected in the view.
            </summary>
            <returns>An ICollection&lt;T&gt; that provides read-only access to the collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.Exists(System.Predicate{`0})">
            <summary>
            Determines if the collection contains any item that satisfies the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>True if the collection contains one or more items that satisfy the condition
            defined by <paramref name="predicate"/>. False if the collection does not contain
            an item that satisfies <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.TrueForAll(System.Predicate{`0})">
            <summary>
            Determines if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>True if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate"/>, or if the collection is empty. False if one or more items
            in the collection do not satisfy <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.CountWhere(System.Predicate{`0})">
            <summary>
            Counts the number of items in the collection that satisfy the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>The number of items in the collection that satisfy <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.FindAll(System.Predicate{`0})">
            <summary>
            Enumerates the items in the collection that satisfy the condition defined
            by <paramref name="predicate"/>.
            </summary>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>An IEnumerable&lt;T&gt; that enumerates the items that satisfy the condition.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.RemoveAll(System.Predicate{`0})">
            <summary>
            Removes all the items in the collection that satisfy the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>Returns a collection of the items that were removed, in sorted order.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.ForEach(System.Action{`0})">
            <summary>
            Performs the specified action on each item in this collection.
            </summary>
            <param name="action">An Action delegate which is invoked for each item in this collection.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.ConvertAll``1(System.Converter{`0,``0})">
            <summary>
            Convert this collection of items by applying a delegate to each item in the collection. The resulting enumeration
            contains the result of applying <paramref name="converter"/> to each item in this collection, in
            order.
            </summary>
            <typeparam name="TOutput">The type each item is being converted to.</typeparam>
            <param name="converter">A delegate to the method to call, passing each item in this collection.</param>
            <returns>An IEnumerable&lt;TOutput^gt; that enumerates the resulting collection from applying <paramref name="converter"/> to each item in this collection in
            order.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="converter"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.GetEnumerator">
            <summary>
            Must be overridden to enumerate all the members of the collection.
            </summary>
            <returns>A generic IEnumerator&lt;T&gt; that can be used
            to enumerate all the items in the collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies all the items in the collection into an array. Implemented by
            using the enumerator returned from GetEnumerator to get all the items
            and copy them to the provided array.
            </summary>
            <param name="array">Array to copy to.</param>
            <param name="index">Starting index in <paramref name="array"/> to copy to.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Provides an IEnumerator that can be used to iterate all the members of the
            collection. This implementation uses the IEnumerator&lt;T&gt; that was overridden
            by the derived classes to enumerate the members of the collection.
            </summary>
            <returns>An IEnumerator that can be used to iterate the collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.CollectionBase`1.DebuggerDisplayString">
            <summary>
            Display the contents of the collection in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
            <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.CollectionBase`1.Count">
            <summary>
            Must be overridden to provide the number of items in the collection.
            </summary>
            <value>The number of items in the collection.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.CollectionBase`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Indicates whether the collection is read-only. Always returns false.
            </summary>
            <value>Always returns false.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.CollectionBase`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Indicates whether the collection is synchronized.
            </summary>
            <value>Always returns false, indicating that the collection is not synchronized.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.CollectionBase`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Indicates the synchronization object for this collection.
            </summary>
            <value>Always returns this.</value>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.#ctor">
            <summary>
            Creates a new ListBase.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.Clear">
            <summary>
            This method must be overridden by the derived class to empty the list
            of all items.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.Insert(System.Int32,`0)">
            <summary>
            This method must be overridden by the derived class to insert a new
            item at the given index. 
            </summary>
            <param name="index">The index in the list to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item in the list has index 0.</param>
            <param name="item">The item to insert at the given index.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than Count.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.RemoveAt(System.Int32)">
            <summary>
            This method must be overridden by the derived class to remove the
            item at the given index. 
            </summary>
            <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.GetEnumerator">
            <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on.
            </summary>
            <remarks>The enumerator does not check for changes made
            to the structure of the list. Thus, changes to the list during
            enumeration may cause incorrect enumeration or out of range
            exceptions. Consider overriding this method and adding checks
            for structural changes.</remarks>
            <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.Contains(`0)">
            <summary>
            Determines if the list contains any item that compares equal to <paramref name="item"/>.
            The implementation simply checks whether IndexOf(item) returns a non-negative value.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="item">The item to search for.</param>
            <returns>True if the list contains an item that compares equal to <paramref name="item"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.Add(`0)">
            <summary>
            Adds an item to the end of the list. This method is equivalent to calling: 
            <code>Insert(Count, item)</code>
            </summary>
            <param name="item">The item to add to the list.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.Remove(`0)">
            <summary>
            Searches the list for the first item that compares equal to <paramref name="item"/>.
            If one is found, it is removed. Otherwise, the list is unchanged.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="item">The item to remove from the list.</param>
            <returns>True if an item was found and removed that compared equal to
            <paramref name="item"/>. False if no such item was in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.CopyTo(`0[])">
            <summary>
            Copies all the items in the list, in order, to <paramref name="array"/>,
            starting at index 0.
            </summary>
            <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies all the items in the list, in order, to <paramref name="array"/>,
            starting at <paramref name="arrayIndex"/>.
            </summary>
            <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count + arrayIndex.</param>
            <param name="arrayIndex">The starting index in <paramref name="array"/>
            to copy to.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from the list to <paramref name="array"/>,
            starting at <paramref name="arrayIndex"/>.
            </summary>
            <param name="index">The starting index in the source list of the range to copy.</param>
            <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count + arrayIndex.</param>
            <param name="arrayIndex">The starting index in <paramref name="array"/>
            to copy to.</param>
            <param name="count">The number of items to copy.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.AsReadOnly">
            <summary>
            Provides a read-only view of this list. The returned IList&lt;T&gt; provides
            a view of the list that prevents modifications to the list. Use the method to provide
            access to the list without allowing changes. Since the returned object is just a view,
            changes to the list will be reflected in the view.
            </summary>
            <returns>An IList&lt;T&gt; that provides read-only access to the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.Find(System.Predicate{`0})">
            <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
            <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate"/>,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:CodeSmith.Engine.PowerCollections.ListBase`1.TryFind(System.Predicate{`0},`0@)"/>.</remarks>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <returns>The first item that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, the default value for T is returned.</returns>
            <seealso cref="M:CodeSmith.Engine.PowerCollections.ListBase`1.TryFind(System.Predicate{`0},`0@)"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.TryFind(System.Predicate{`0},`0@)">
            <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate"/>. 
            </summary>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <param name="foundItem">If true is returned, this parameter receives the first item in the list
            that satifies the condition defined by <paramref name="predicate"/>.</param>
            <returns>True if an item that  satisfies the condition <paramref name="predicate"/> was found. False 
            if no item in the list satisfies that condition.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.FindLast(System.Predicate{`0})">
            <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
            <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate"/>,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:CodeSmith.Engine.PowerCollections.ListBase`1.TryFindLast(System.Predicate{`0},`0@)"/>.</remarks>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <returns>The last item that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, the default value for T is returned.</returns>
            <seealso cref="M:CodeSmith.Engine.PowerCollections.ListBase`1.TryFindLast(System.Predicate{`0},`0@)"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.TryFindLast(System.Predicate{`0},`0@)">
            <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate"/>. 
            </summary>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <param name="foundItem">If true is returned, this parameter receives the last item in the list
            that satifies the condition defined by <paramref name="predicate"/>.</param>
            <returns>True if an item that  satisfies the condition <paramref name="predicate"/> was found. False 
            if no item in the list satisfies that condition.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.FindIndex(System.Predicate{`0})">
            <summary>
            Finds the index of the first item in the list that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, -1 is returned.
            </summary>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <returns>The index of the first item that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.FindIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index"/> to the end, that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, -1 is returned.
            </summary>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <param name="index">The starting index of the range to check.</param>
            <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Finds the index of the first item, in the range of <paramref name="count"/> items starting from <paramref name="index"/>, that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, -1 is returned.
            </summary>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <param name="index">The starting index of the range to check.</param>
            <param name="count">The number of items in range to check.</param>
            <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.FindLastIndex(System.Predicate{`0})">
            <summary>
            Finds the index of the last item in the list that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, -1 is returned.
            </summary>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <returns>The index of the last item that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.FindLastIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index"/>, that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, -1 is returned.
            </summary>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <param name="index">The ending index of the range to check.</param>
            <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Finds the index of the last item, in the range of <paramref name="count"/> items ending at <paramref name="index"/>, that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, -1 is returned.
            </summary>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <param name="index">The ending index of the range to check.</param>
            <param name="count">The number of items in range to check.</param>
            <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.IndexOf(`0)">
            <summary>
            Finds the index of the first item in the list that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <returns>The index of the first item in the list that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.IndexOf(`0,System.Int32)">
            <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index"/> to the end,  
            that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <param name="index">The starting index of the range to check.</param>
            <returns>The index of the first item in the given range that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Finds the index of the first item, in the range of <paramref name="count"/> items starting from <paramref name="index"/>,  
            that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <param name="index">The starting index of the range to check.</param>
            <param name="count">The number of items in range to check.</param>
            <returns>The index of the first item in the given range that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.LastIndexOf(`0)">
            <summary>
            Finds the index of the last item in the list that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <returns>The index of the last item in the list that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.LastIndexOf(`0,System.Int32)">
            <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index"/>, that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <param name="index">The ending index of the range to check.</param>
            <returns>The index of the last item in the given range that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Finds the index of the last item, in the range of <paramref name="count"/> items ending at <paramref name="index"/>, 
            that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search for.</param>
            <param name="index">The ending index of the range to check.</param>
            <param name="count">The number of items in range to check.</param>
            <returns>The index of the last item in the given range that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.Range(System.Int32,System.Int32)">
            <summary>
            Returns a view onto a sub-range of this list. Items are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view, but insertions and deletions in the underlying list do not.
            </summary>
            <remarks>
            <para>This method can be used to apply an algorithm to a portion of a list. For example:</para>
            <code>Algorithms.ReverseInPlace(deque.Range(3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
            <param name="start">The starting index of the view.</param>
            <param name="count">The number of items in the view.</param>
            <returns>A list that is a view onto the given sub-part of this list. </returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> or <paramref name="count"/> is negative.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> + <paramref name="count"/> is greater than the
            size of the list.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.ConvertToItemType(System.String,System.Object)">
            <summary>
            Convert the given parameter to T. Throw an ArgumentException
            if it isn't.
            </summary>
            <param name="name">parameter name</param>
            <param name="value">parameter value</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.System#Collections#IList#Add(System.Object)">
            <summary>
            Adds an item to the end of the list. This method is equivalent to calling: 
            <code>Insert(Count, item)</code>
            </summary>
            <param name="value">The item to add to the list.</param>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be converted to T.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.System#Collections#IList#Clear">
            <summary>
            Removes all the items from the list, resulting in an empty list.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.System#Collections#IList#Contains(System.Object)">
            <summary>
            Determines if the list contains any item that compares equal to <paramref name="value"/>.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="value">The item to search for.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            Find the first occurrence of an item equal to <paramref name="value"/>
            in the list, and returns the index of that item.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="value">The item to search for.</param>
            <returns>The index of <paramref name="value"/>, or -1 if no item in the 
            list compares equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Insert a new
            item at the given index. 
            </summary>
            <param name="index">The index in the list to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item in the list has index 0.</param>
            <param name="value">The item to insert at the given index.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than Count.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be converted to T.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            Searches the list for the first item that compares equal to <paramref name="value"/>.
            If one is found, it is removed. Otherwise, the list is unchanged.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="value">The item to remove from the list.</param>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be converted to T.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ListBase`1.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>
            Removes the
            item at the given index. 
            </summary>
            <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ListBase`1.Count">
            <summary>
            The property must be overridden by the derived class to return the number of 
            items in the list.
            </summary>
            <value>The number of items in the list.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ListBase`1.Item(System.Int32)">
            <summary>
            The indexer must be overridden by the derived class to get and set
            values of the list at a particular index.
            </summary>
            <param name="index">The index in the list to get or set an item at. The
            first item in the list has index 0, and the last has index Count-1.</param>
            <returns>The item at the given index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ListBase`1.System#Collections#IList#IsFixedSize">
            <summary>
            Returns whether the list is a fixed size. This implementation always returns false.
            </summary>
            <value>Alway false, indicating that the list is not fixed size.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ListBase`1.System#Collections#IList#IsReadOnly">
            <summary>
            Returns whether the list is read only. This implementation returns the value
            from ICollection&lt;T&gt;.IsReadOnly, which is by default, false.
            </summary>
            <value>By default, false, indicating that the list is not read only.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ListBase`1.System#Collections#IList#Item(System.Int32)">
            <summary>
            Gets or sets the
            value at a particular index in the list.
            </summary>
            <param name="index">The index in the list to get or set an item at. The
            first item in the list has index 0, and the last has index Count-1.</param>
            <value>The item at the given index.</value>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be converted to T.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ListRange`1.#ctor(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>
            Create a sub-range view object on the indicate part 
            of the list.
            </summary>
            <param name="wrappedList">List to wrap.</param>
            <param name="start">The start index of the view in the wrapped list.</param>
            <param name="count">The number of items in the view.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.ArrayRange`1">
            <summary>
            The class that is used to implement IList&lt;T&gt; to view a sub-range
            of an array. The object stores a wrapped array, and a start/count indicating
            a sub-range of the array. Insertion/deletions through the sub-range view
            cause the count to change up to the size of the underlying array. Elements
            fall off the end of the underlying array.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ArrayRange`1.#ctor(`0[],System.Int32,System.Int32)">
            <summary>
            Create a sub-range view object on the indicate part 
            of the array.
            </summary>
            <param name="wrappedArray">Array to wrap.</param>
            <param name="start">The start index of the view in the wrapped list.</param>
            <param name="count">The number of items in the view.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.ReadOnlyCollection`1">
            <summary>
            The read-only ICollection&lt;T&gt; implementation that is used by the ReadOnly method.
            Methods that modify the collection throw a NotSupportedException, methods that don't
            modify are fowarded through to the wrapped collection.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReadOnlyCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Create a ReadOnlyCollection wrapped around the given collection.
            </summary>
            <param name="wrappedCollection">Collection to wrap.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReadOnlyCollection`1.MethodModifiesCollection">
            <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.ReadOnlyList`1">
            <summary>
            The read-only IList&lt;T&gt; implementation that is used by the ReadOnly method.
            Methods that modify the list throw a NotSupportedException, methods that don't
            modify are fowarded through to the wrapped list.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReadOnlyList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Create a ReadOnlyList wrapped around the given list.
            </summary>
            <param name="wrappedList">List to wrap.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReadOnlyList`1.MethodModifiesCollection">
            <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.ReadOnlyDictionary`2">
            <summary>
            The private class that implements a read-only wrapped for 
            IDictionary &lt;TKey,TValue&gt;.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Create a read-only dictionary wrapped around the given dictionary.
            </summary>
            <param name="wrappedDictionary">The IDictionary&lt;TKey,TValue&gt; to wrap.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReadOnlyDictionary`2.MethodModifiesCollection">
            <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.TypedEnumerator`1">
            <summary>
             The class that provides a typed IEnumerator&lt;T&gt;
            view onto an untyped IEnumerator interface.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.TypedEnumerator`1.#ctor(System.Collections.IEnumerator)">
            <summary>
            Create a typed IEnumerator&lt;T&gt;
            view onto an untyped IEnumerator interface 
            </summary>
            <param name="wrappedEnumerator">IEnumerator to wrap.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.TypedEnumerable`1">
            <summary>
            The class that provides a typed IEnumerable&lt;T&gt; view
            onto an untyped IEnumerable interface.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.TypedEnumerable`1.#ctor(System.Collections.IEnumerable)">
            <summary>
            Create a typed IEnumerable&lt;T&gt; view
            onto an untyped IEnumerable interface.
            </summary>
            <param name="wrappedEnumerable">IEnumerable interface to wrap.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.TypedCollection`1">
            <summary>
            The class that provides a typed ICollection&lt;T&gt; view
            onto an untyped ICollection interface. The ICollection&lt;T&gt;
            is read-only.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.TypedCollection`1.#ctor(System.Collections.ICollection)">
            <summary>
            Create a typed ICollection&lt;T&gt; view
            onto an untyped ICollection interface.
            </summary>
            <param name="wrappedCollection">ICollection interface to wrap.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.TypedCollection`1.MethodModifiesCollection">
            <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.TypedList`1">
            <summary>
            The class used to create a typed IList&lt;T&gt; view onto
            an untype IList interface.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.TypedList`1.#ctor(System.Collections.IList)">
            <summary>
            Create a typed IList&lt;T&gt; view onto
            an untype IList interface.
            </summary>
            <param name="wrappedList">The IList to wrap.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.UntypedCollection`1">
            <summary>
            The class that is used to provide an untyped ICollection
            view onto a typed ICollection&lt;T&gt; interface.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.UntypedCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Create an untyped ICollection
            view onto a typed ICollection&lt;T&gt; interface.
            </summary>
            <param name="wrappedCollection">The ICollection&lt;T&gt; to wrap.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.UntypedList`1">
            <summary>
            The class that implements a non-generic IList wrapper
            around a generic IList&lt;T&gt; interface.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.UntypedList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Create a non-generic IList wrapper
            around a generic IList&lt;T&gt; interface.
            </summary>
            <param name="wrappedList">The IList&lt;T&gt; interface to wrap.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.UntypedList`1.ConvertToItemType(System.String,System.Object)">
            <summary>
            Convert the given parameter to T. Throw an ArgumentException
            if it isn't.
            </summary>
            <param name="name">parameter name</param>
            <param name="value">parameter value</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.ArrayWrapper`1">
            <summary>
            The class that is used to implement IList&lt;T&gt; to view an array
            in a read-write way. Insertions cause the last item in the array
            to fall off, deletions replace the last item with the default value.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ArrayWrapper`1.#ctor(`0[])">
            <summary>
            Create a list wrapper object on an array.
            </summary>
            <param name="wrappedArray">Array to wrap.</param>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.Algorithms.ArrayWrapper`1.System#Collections#IList#IsFixedSize">
            <summary>
            Return true, to indicate that the list is fixed size.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.LexicographicalComparerClass`1">
            <summary>
            A private class used by the LexicographicalComparer method to compare sequences
            (IEnumerable) of T by there Lexicographical ordering.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.LexicographicalComparerClass`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new instance that comparer sequences of T by their lexicographical
            ordered.
            </summary>
            <param name="itemComparer">The IComparer used to compare individual items of type T.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.ReverseComparerClass`1">
            <summary>
            An IComparer instance that can be used to reverse the sense of 
            a wrapped IComparer instance.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Algorithms.ReverseComparerClass`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            </summary>
            <param name="comparer">The comparer to reverse.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.IdentityComparer`1">
            <summary>
            A class, implementing IEqualityComparer&lt;T&gt;, that compares objects
            for object identity only. Only Equals and GetHashCode can be used;
            this implementation is not appropriate for ordering.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.CollectionEqualityComparer`1">
            <summary>
            A private class used to implement GetCollectionEqualityComparer(). This
            class implements IEqualityComparer&lt;IEnumerable&lt;T&gt;gt; to compare
            two enumerables for equality, where order is significant.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Algorithms.SetEqualityComparer`1">
            <summary>
            A private class used to implement GetSetEqualityComparer(). This
            class implements IEqualityComparer&lt;IEnumerable&lt;T&gt;gt; to compare
            two enumerables for equality, where order is not significant.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Bag`1">
             <summary>
             Bag&lt;T&gt; is a collection that contains items of type T. 
             Unlike a Set, duplicate items (items that compare equal to each other) are allowed in an Bag. 
             </summary>
             <remarks>
             <p>The items are compared in one of two ways. If T implements IComparable&lt;T&gt; 
             then the Equals method of that interface will be used to compare items, otherwise the Equals
             method from Object will be used. Alternatively, an instance of IComparer&lt;T&gt; can be passed
             to the constructor to use to compare items.</p>
             <p>Bag is implemented as a hash table. Inserting, deleting, and looking up an
             an element all are done in approximately constant time, regardless of the number of items in the bag.</p>
             <p>When multiple equal items are stored in the bag, they are stored as a representative item and a count. 
             If equal items can be distinguished, this may be noticable. For example, if a case-insensitive
             comparer is used with a Bag&lt;string&gt;, and both "hello", and "HELLO" are added to the bag, then the
             bag will appear to contain two copies of "hello" (the representative item).</p>
             <p><see cref="T:CodeSmith.Engine.PowerCollections.OrderedBag`1"/> is similar, but uses comparison instead of hashing, maintain
             the items in sorted order, and stores distinct copies of items that compare equal.</p>
            </remarks>
            <seealso cref="T:CodeSmith.Engine.PowerCollections.OrderedBag`1"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.NewPair(`0,System.Int32)">
            <summary>
            Helper function to create a new KeyValuePair struct with an item and a count.
            </summary>
            <param name="item">The item.</param>
            <param name="count">The number of appearances.</param>
            <returns>A new KeyValuePair.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.NewPair(`0)">
            <summary>
            Helper function to create a new KeyValuePair struct with a count of zero.
            </summary>
            <param name="item">The item.</param>
            <returns>A new KeyValuePair.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.#ctor">
             <summary>
             Creates a new Bag. 
             </summary>
            <remarks>
             Items that are null are permitted.
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new Bag. The Equals and GetHashCode methods of the passed comparison object
            will be used to compare items in this bag for equality.
            </summary>
            <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Creates a new Bag. The bag is
             initialized with all the items in the given collection.
             </summary>
            <remarks>
             Items that are null are permitted.
            </remarks>
             <param name="collection">A collection with items to be placed into the Bag.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new Bag. The Equals and GetHashCode methods of the passed comparison object
            will be used to compare items in this bag. The bag is
            initialized with all the items in the given collection.
            </summary>
            <param name="collection">A collection with items to be placed into the Bag.</param>
            <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.#ctor(System.Collections.Generic.IEqualityComparer{System.Collections.Generic.KeyValuePair{`0,System.Int32}},System.Collections.Generic.IEqualityComparer{`0},CodeSmith.Engine.PowerCollections.Hash{System.Collections.Generic.KeyValuePair{`0,System.Int32}},System.Int32)">
            <summary>
            Creates a new Bag given a comparer and a hash that contains the data. Used
            internally for Clone.
            </summary>
            <param name="equalityComparer">IEqualityComparer for the bag.</param>
            <param name="keyEqualityComparer">IEqualityComparer for the key.</param>
            <param name="hash">Data for the bag.</param>
            <param name="count">Size of the bag.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.System#ICloneable#Clone">
            <summary>
            Makes a shallow clone of this bag; i.e., if items of the
            bag are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
            <remarks>Cloning the bag takes time O(N), where N is the number of items in the bag.</remarks>
            <returns>The cloned bag.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.Clone">
            <summary>
            Makes a shallow clone of this bag; i.e., if items of the
            bag are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
            <remarks>Cloning the bag takes time O(N), where N is the number of unquie items in the bag.</remarks>
            <returns>The cloned bag.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.CloneContents">
            <summary>
            Makes a deep clone of this bag. A new bag is created with a clone of
            each element of this bag, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
            <remarks><para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
            <para>Cloning the bag takes time O(N log N), where N is the number of items in the bag.</para></remarks>
            <returns>The cloned bag.</returns>
            <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.NumberOfCopies(`0)">
            <summary>
            Returns the number of copies of <paramref name="item"/> in the bag. 
            </summary>
            <remarks>NumberOfCopies() takes approximately constant time, no matter how many items
            are stored in the bag.</remarks>
            <param name="item">The item to search for in the bag.</param>
            <returns>The number of items in the bag that compare equal to <paramref name="item"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.GetRepresentativeItem(`0,`0@)">
            <summary>
            Returns the representative item stored in the bag that is equal to
            the provided item. Also returns the number of copies of the item in the bag.
            </summary>
            <param name="item">Item to find in the bag.</param>
            <param name="representative">If one or more items equal to <paramref name="item"/> are present in the
            bag, returns the representative item. If no items equal to <paramref name="item"/> are stored in the bag, 
            returns <paramref name="item"/>.</param>
            <returns>The number of items equal to <paramref name="item"/> stored in the bag.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.GetEnumerator">
            <summary>
            Returns an enumerator that enumerates all the items in the bag. 
            If an item is present multiple times in the bag, the representative item is yielded by the
            enumerator multiple times. The order of enumeration is haphazard and may change.
            </summary>
            <remarks>
            <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
            <p>If an item is added to or deleted from the bag while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
            <p>Enumeration all the items in the bag takes time O(N), where N is the number
            of items in the bag.</p>
            </remarks>
            <returns>An enumerator for enumerating all the items in the Bag.</returns>		
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.Contains(`0)">
            <summary>
            Determines if this bag contains an item equal to <paramref name="item"/>. The bag
            is not changed.
            </summary>
            <remarks>Searching the bag for an item takes time O(log N), where N is the number of items in the bag.</remarks>
            <param name="item">The item to search for.</param>
            <returns>True if the bag contains <paramref name="item"/>. False if the bag does not contain <paramref name="item"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.DistinctItems">
            <summary>
            Enumerates all the items in the bag, but enumerates equal items
            just once, even if they occur multiple times in the bag.
            </summary>
            <remarks>If the bag is changed while items are being enumerated, the
            enumeration will terminate with an InvalidOperationException.</remarks>
            <returns>An IEnumerable&lt;T&gt; that enumerates the unique items.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.Add(`0)">
            <summary>
            Adds a new item to the bag. Since bags can contain duplicate items, the item 
            is added even if the bag already contains an item equal to <paramref name="item"/>. In
            this case, the count of items for the representative item is increased by one, but the existing
            represetative item is unchanged.
            </summary>
            <remarks>
            <para>Adding an item takes approximately constant time, regardless of the number of items in the bag.</para></remarks>
            <param name="item">The item to add to the bag.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.AddRepresentative(`0)">
            <summary>
            Adds a new item to the bag. Since bags can contain duplicate items, the item 
            is added even if the bag already contains an item equal to <paramref name="item"/>. In
            this case (unlike Add), the new item becomes the representative item.
            </summary>
            <remarks>
            <para>Adding an item takes approximately constant time, regardless of the number of items in the bag.</para></remarks>
            <param name="item">The item to add to the bag.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.ChangeNumberOfCopies(`0,System.Int32)">
            <summary>
            Changes the number of copies of an existing item in the bag, or adds the indicated number
            of copies of the item to the bag. 
            </summary>
            <remarks>
            <para>Changing the number of copies takes approximately constant time, regardless of the number of items in the bag.</para></remarks>
            <param name="item">The item to change the number of copies of. This may or may not already be present in the bag.</param>
            <param name="numCopies">The new number of copies of the item.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds all the items in <paramref name="collection"/> to the bag. 
            </summary>
            <remarks>
            <para>Adding the collection takes time O(M log N), where N is the number of items in the bag, and M is the 
            number of items in <paramref name="collection"/>.</para></remarks>
            <param name="collection">A collection of items to add to the bag.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.Remove(`0)">
            <summary>
            Searches the bag for one item equal to <paramref name="item"/>, and if found,
            removes it from the bag. If not found, the bag is unchanged. 
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
            <para>Removing an item from the bag takes approximated constant time,
            regardless of the number of items in the bag.</para></remarks>
            <param name="item">The item to remove.</param>
            <returns>True if <paramref name="item"/> was found and removed. False if <paramref name="item"/> was not in the bag.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.RemoveAllCopies(`0)">
            <summary>
            Searches the bag for all items equal to <paramref name="item"/>, and 
            removes all of them from the bag. If not found, the bag is unchanged.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparer instance used
            to create the bag.</para>
            <para>RemoveAllCopies() takes time O(M log N), where N is the total number of items in the bag, and M is
            the number of items equal to <paramref name="item"/>.</para></remarks>
            <param name="item">The item to remove.</param>
            <returns>The number of copies of <paramref name="item"/> that were found and removed. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes all the items in <paramref name="collection"/> from the bag. Items that
            are not present in the bag are ignored.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparer instance used
            to create the bag.</para>
            <para>Removing the collection takes time O(M), where M is the 
            number of items in <paramref name="collection"/>.</para></remarks>
            <param name="collection">A collection of items to remove from the bag.</param>
            <returns>The number of items removed from the bag.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.Clear">
            <summary>
            Removes all items from the bag.
            </summary>
            <remarks>Clearing the bag takes a constant amount of time, regardless of the number of items in it.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.CheckConsistentComparison(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Check that this bag and another bag were created with the same comparison
            mechanism. Throws exception if not compatible.
            </summary>
            <param name="otherBag">Other bag to check comparision mechanism.</param>
            <exception cref="T:System.InvalidOperationException">If otherBag and this bag don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.IsEqualTo(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Determines if this bag is equal to another bag. This bag is equal to
            <paramref name="otherBag"/> if they contain the same number of 
            of copies of equal elements.
            </summary>
            <remarks>IsSupersetOf is computed in time O(N), where N is the number of unique items in 
            this bag.</remarks>
            <param name="otherBag">Bag to compare to</param>
            <returns>True if this bag is equal to <paramref name="otherBag"/>, false otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.IsSupersetOf(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Determines if this bag is a superset of another bag. Neither bag is modified.
            This bag is a superset of <paramref name="otherBag"/> if every element in
            <paramref name="otherBag"/> is also in this bag, at least the same number of
            times.
            </summary>
            <remarks>IsSupersetOf is computed in time O(M), where M is the number of unique items in 
            <paramref name="otherBag"/>.</remarks>
            <param name="otherBag">Bag to compare to.</param>
            <returns>True if this is a superset of <paramref name="otherBag"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.IsProperSupersetOf(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Determines if this bag is a proper superset of another bag. Neither bag is modified.
            This bag is a proper superset of <paramref name="otherBag"/> if every element in
            <paramref name="otherBag"/> is also in this bag, at least the same number of
            times. Additional, this bag must have strictly more items than <paramref name="otherBag"/>.
            </summary>
            <remarks>IsProperSupersetOf is computed in time O(M), where M is the number of unique items in 
            <paramref name="otherBag"/>.</remarks>
            <param name="otherBag">Set to compare to.</param>
            <returns>True if this is a proper superset of <paramref name="otherBag"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.IsSubsetOf(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Determines if this bag is a subset of another ba11 items in this bag.
            </summary>
            <param name="otherBag">Bag to compare to.</param>
            <returns>True if this is a subset of <paramref name="otherBag"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.IsProperSubsetOf(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Determines if this bag is a proper subset of another bag. Neither bag is modified.
            This bag is a subset of <paramref name="otherBag"/> if every element in this bag
            is also in <paramref name="otherBag"/>, at least the same number of
            times. Additional, this bag must have strictly fewer items than <paramref name="otherBag"/>.
            </summary>
            <remarks>IsProperSubsetOf is computed in time O(N), where N is the number of unique items in this bag.</remarks>
            <param name="otherBag">Bag to compare to.</param>
            <returns>True if this is a proper subset of <paramref name="otherBag"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.IsDisjointFrom(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Determines if this bag is disjoint from another bag. Two bags are disjoint
            if no item from one set is equal to any item in the other bag.
            </summary>
            <remarks>
            <para>The answer is computed in time O(N), where N is the size of the smaller set.</para>
            </remarks>
            <param name="otherBag">Bag to check disjointness with.</param>
            <returns>True if the two bags are disjoint, false otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.UnionWith(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. This bag receives
            the union of the two bags, the other bag is unchanged.
            </summary>
            <remarks>
            <para>The union of two bags is computed in time O(M+N), where M and N are the size of the 
            two bags.</para>
            </remarks>
            <param name="otherBag">Bag to union with.</param>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.Union(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. A new bag is 
            created with the union of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
            <remarks>
            <para>The union of two bags is computed in time O(M+N), where M and N are the size of the two bags.</para>
            </remarks>
            <param name="otherBag">Bag to union with.</param>
            <returns>The union of the two bags.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.SumWith(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Computes the sum of this bag with another bag. The sum of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. This bag receives
            the sum of the two bags, the other bag is unchanged.
            </summary>
            <remarks>
            <para>The sum of two bags is computed in time O(M), where M is the size of the 
            other bag..</para>
            </remarks>
            <param name="otherBag">Bag to sum with.</param>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.Sum(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Computes the sum of this bag with another bag. he sum of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. A new bag is 
            created with the sum of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
            <remarks>
            <para>The sum of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to sum with.</param>
            <returns>The sum of the two bags.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.IntersectionWith(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item Minimum(X,Y) times. This bag receives
            the intersection of the two bags, the other bag is unchanged.
            </summary>
            <remarks>
            <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The intersection of two bags is computed in time O(N), where N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to intersection with.</param>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.Intersection(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the intersection contains the item Minimum(X,Y) times. A new bag is 
            created with the intersection of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
            <remarks>
            <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The intersection of two bags is computed in time O(N), where N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to intersection with.</param>
            <returns>The intersection of the two bags.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.DifferenceWith(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag"/>. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X). This bag receives
            the difference of the two bags; the other bag is unchanged.
            </summary>
            <remarks>
            <para>The difference of two bags is computed in time O(M), where M is the size of the 
            other bag.</para>
            </remarks>
            <param name="otherBag">Bag to difference with.</param>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.Difference(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag"/>. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X).  A new bag is 
            created with the difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
            <remarks>
            <para>The difference of two bags is computed in time O(M + N), where M and N are the size
            of the two bags.</para>
            </remarks>
            <param name="otherBag">Bag to difference with.</param>
            <returns>The difference of the two bags.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.SymmetricDifferenceWith(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y) times. This bag receives
            the symmetric difference of the two bags; the other bag is unchanged.
            </summary>
            <remarks>
            <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to symmetric difference with.</param>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Bag`1.SymmetricDifference(CodeSmith.Engine.PowerCollections.Bag{`0})">
            <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y) times. A new bag is 
            created with the symmetric difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
            <remarks>
            <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to symmetric difference with.</param>
            <returns>The symmetric difference of the two bags.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.Bag`1.Comparer">
            <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare items in this bag. 
            </summary>
            <value>If the bag was created using a comparer, that comparer is returned. Otherwise
            the default comparer for T (EqualityComparer&lt;T&gt;.Default) is returned.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.Bag`1.Count">
            <summary>
            Returns the number of items in the bag.
            </summary>
            <remarks>The size of the bag is returned in constant time.</remarks>
            <value>The number of items in the bag.</value>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.BigList`1">
            <summary>
            BigList&lt;T&gt; provides a list of items, in order, with indices of the items ranging from 0 to one less
            than the count of items in the collection. BigList&lt;T&gt; is optimized for efficient operations on large (&gt;100 items)
            lists, especially for insertions, deletions, copies, and concatinations.
            </summary>
            <remarks>
            <para>BigList&lt;T&gt; class is similar in functionality to the standard List&lt;T&gt; class. Both classes
            provide a collection that stores an set of items in order, with indices of the items ranging from 0 to one less
            than the count of items in the collection. Both classes provide the ability to add and remove items from any index,
            and the get or set the item at any index.</para> 
            <para>BigList&lt;T&gt; differs significantly from List&lt;T&gt; in the performance of various operations, 
            especially when the lists become large (several hundred items or more). With List&lt;T&gt;, inserting or removing
            elements from anywhere in a large list except the end is very inefficient -- every item after the point of inserting
            or deletion has to be moved in the list. The BigList&lt;T&gt; class, however, allows for fast insertions
            and deletions anywhere in the list. Furthermore, BigList&lt;T&gt; allows copies of a list, sub-parts
            of a list, and concatinations of two lists to be very fast. When a copy is made of part or all of a BigList,
            two lists shared storage for the parts of the lists that are the same. Only when one of the lists is changed is additional
            memory allocated to store the distinct parts of the lists.</para>
            <para>Of course, there is a small price to pay for this extra flexibility. Although still quite efficient, using an 
            index to get or change one element of a BigList, while still reasonably efficient, is significantly slower than using
            a plain List. Because of this, if you want to process every element of a BigList, using a foreach loop is a lot
            more efficient than using a for loop and indexing the list.</para>
            <para>In general, use a List when the only operations you are using are Add (to the end), foreach,
            or indexing, or you are very sure the list will always remain small (less than 100 items). For large (&gt;100 items) lists
            that do insertions, removals, copies, concatinations, or sub-ranges, BigList will be more efficient than List. 
            In almost all cases, BigList is more efficient and easier to use than LinkedList.</para>
            </remarks>
            <typeparam name="T">The type of items to store in the BigList.</typeparam>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.StopEnumerations">
            <summary>
            Must be called whenever there is a structural change in the tree. Causes
            changeStamp to be changed, which causes any in-progress enumerations
            to throw exceptions.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.CheckEnumerationStamp(System.Int32)">
            <summary>
            Checks the given stamp against the current change stamp. If different, the
            collection has changed during enumeration and an InvalidOperationException
            must be thrown
            </summary>
            <param name="startStamp">changeStamp at the start of the enumeration.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.#ctor">
            <summary>
            Creates a new BigList. The BigList is initially empty.
            </summary>
            <remarks>Creating a empty BigList takes constant time and consumes a very small amount of memory.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new BigList initialized with the items from <paramref name="collection"/>, in order.
            </summary>
            <remarks>Initializing the tree list with the elements of collection takes time O(N), where N is the number of
            items in <paramref name="collection"/>.</remarks>
            <param name="collection">The collection used to initialize the BigList. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            Creates a new BigList initialized with a given number of copies of the items from <paramref name="collection"/>, in order. 
            </summary>
            <remarks>Initializing the tree list with the elements of collection takes time O(N + log K), where N is the number of
            items in <paramref name="collection"/>, and K is the number of copies.</remarks>
            <param name="copies">Number of copies of the collection to use.</param>
            <param name="collection">The collection used to initialize the BigList. </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="copies"/> is negative.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.#ctor(CodeSmith.Engine.PowerCollections.BigList{`0})">
            <summary>
            Creates a new BigList that is a copy of <paramref name="list"/>.
            </summary>
            <remarks>Copying a BigList takes constant time, and little 
            additional memory, since the storage for the items of the two lists is shared. However, changing
            either list will take additional time and memory. Portions of the list are copied when they are changed.</remarks>
            <param name="list">The BigList to copy. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.#ctor(CodeSmith.Engine.PowerCollections.BigList{`0},System.Int32)">
            <summary>
            Creates a new BigList that is several copies of <paramref name="list"/>.
            </summary>
            <remarks>Creating K copies of a BigList takes time O(log K), and O(log K) 
            additional memory, since the storage for the items of the two lists is shared. However, changing
            either list will take additional time and memory. Portions of the list are copied when they are changed.</remarks>
            <param name="copies">Number of copies of the collection to use.</param>
            <param name="list">The BigList to copy. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.#ctor(CodeSmith.Engine.PowerCollections.BigList{`0}.Node)">
            <summary>
            Creates a new BigList from the indicated Node.
            </summary>
            <param name="node">Node that becomes the new root. If null, the new BigList is empty.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Clear">
            <summary>
            Removes all of the items from the BigList.
            </summary>
            <remarks>Clearing a BigList takes constant time.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts a new item at the given index in the BigList. All items at indexes 
            equal to or greater than <paramref name="index"/> move up one index.
            </summary>
            <remarks>The amount of time to insert an item is O(log N), no matter where
            in the list the insertion occurs. Inserting an item at the beginning or end of the 
            list is O(N). 
            </remarks>
            <param name="index">The index to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item has index 0.</param>
            <param name="item">The item to insert at the given index.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than Count.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts a collection of items at the given index in the BigList. All items at indexes 
            equal to or greater than <paramref name="index"/> increase their indices 
            by the number of items inserted.
            </summary>
            <remarks>The amount of time to insert an arbitrary collection in the BigList is O(M + log N), 
            where M is the number of items inserted, and N is the number of items in the list.
            </remarks>
            <param name="index">The index to insert the collection at. After the
            insertion, the first item of the inserted collection is located at this index. The
            first item has index 0.</param>
            <param name="collection">The collection of items to insert at the given index.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than Count.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.InsertRange(System.Int32,CodeSmith.Engine.PowerCollections.BigList{`0})">
            <summary>
            Inserts a BigList of items at the given index in the BigList. All items at indexes 
            equal to or greater than <paramref name="index"/> increase their indices 
            by the number of items inserted.
            </summary>
            <remarks>The amount of time to insert another BigList is O(log N), 
            where N is the number of items in the list, regardless of the number of items in the 
            inserted list. Storage is shared between the two lists until one of them is changed.
            </remarks>
            <param name="index">The index to insert the collection at. After the
            insertion, the first item of the inserted collection is located at this index. The
            first item has index 0.</param>
            <param name="list">The BigList of items to insert at the given index.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than Count.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the given index in the BigList. All items at indexes 
            greater than <paramref name="index"/> move down one index.
            </summary>
            <remarks>The amount of time to delete an item in the BigList is O(log N),
            where N is the number of items in the list. 
            </remarks>
            <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes a range of items at the given index in the Deque. All items at indexes 
            greater than <paramref name="index"/> move down <paramref name="count"/> indices
            in the Deque.
            </summary>
            <remarks>The amount of time to delete <paramref name="count"/> items in the Deque is proportional
            to the distance of index from the closest end of the Deque, plus <paramref name="count"/>: 
            O(count + Min(<paramref name="index"/>, Count - 1 - <paramref name="index"/>)).
            </remarks>
            <param name="index">The index in the list to remove the range at. The
            first item in the list has index 0.</param>
            <param name="count">The number of items to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count, or <paramref name="count"/> is less than zero
            or too large.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Add(`0)">
            <summary>
            Adds an item to the end of the BigList. The indices of all existing items
            in the Deque are unchanged. 
            </summary>
            <remarks>Adding an item takes, on average, constant time.</remarks>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.AddToFront(`0)">
            <summary>
            Adds an item to the beginning of the BigList. The indices of all existing items
            in the Deque are increased by one, and the new item has index zero. 
            </summary>
            <remarks>Adding an item takes, on average, constant time.</remarks>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a collection of items to the end of BigList. The indices of all existing items
            are unchanged. The last item in the added collection becomes the
            last item in the BigList.
            </summary>
            <remarks>This method takes time O(M + log N), where M is the number of items in the 
            <paramref name="collection"/>, and N is the size of the BigList.</remarks>
            <param name="collection">The collection of items to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.AddRangeToFront(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a collection of items to the front of BigList. The indices of all existing items
            in the are increased by the number of items in <paramref name="collection"/>. 
            The first item in the added collection becomes the first item in the BigList.
            </summary>
            <remarks>This method takes time O(M + log N), where M is the number of items in the 
            <paramref name="collection"/>, and N is the size of the BigList.</remarks>
            <param name="collection">The collection of items to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Clone">
            <summary>
            Creates a new BigList that is a copy of this list.
            </summary>
            <remarks>Copying a BigList takes constant time, and little 
            additional memory, since the storage for the items of the two lists is shared. However, changing
            either list will take additional time and memory. Portions of the list are copied when they are changed.</remarks>
            <returns>A copy of the current list</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.System#ICloneable#Clone">
            <summary>
            Creates a new BigList that is a copy of this list.
            </summary>
            <remarks>Copying a BigList takes constant time, and little 
            additional memory, since the storage for the items of the two lists is shared. However, changing
            either list will take additional time and memory. Portions of the list are copied when they are changed.</remarks>
            <returns>A copy of the current list</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.CloneContents">
            <summary>
            Makes a deep clone of this BigList. A new BigList is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then this method is the same as Clone.
            </summary>
            <remarks><para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
            <para>If T is a reference type, cloning the list takes time approximate O(N), where N is the number of items in the list.</para></remarks>
            <returns>The cloned set.</returns>
            <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.AddRange(CodeSmith.Engine.PowerCollections.BigList{`0})">
            <summary>
            Adds a BigList of items to the end of BigList. The indices of all existing items
            are unchanged. The last item in <paramref name="list"/> becomes the
            last item in this list. The added list <paramref name="list"/> is unchanged.
            </summary>
            <remarks>This method takes, on average, constant time, regardless of the size
            of either list. Although conceptually all of the items in <paramref name="list"/> are
            copied, storage is shared between the two lists until changes are made to the 
            shared sections.</remarks>
            <param name="list">The list of items to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.AddRangeToFront(CodeSmith.Engine.PowerCollections.BigList{`0})">
            <summary>
            Adds a BigList of items to the front of BigList. The indices of all existing items
            are increased by the number of items in <paramref name="list"/>. The first item in <paramref name="list"/> 
            becomes the first item in this list. The added list <paramref name="list"/> is unchanged.
            </summary>
            <remarks>This method takes, on average, constant time, regardless of the size
            of either list. Although conceptually all of the items in <paramref name="list"/> are
            copied, storage is shared between the two lists until changes are made to the 
            shared sections.</remarks>
            <param name="list">The list of items to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.op_Addition(CodeSmith.Engine.PowerCollections.BigList{`0},CodeSmith.Engine.PowerCollections.BigList{`0})">
            <summary>
            Concatenates two lists together to create a new list. Both lists being concatenated
            are unchanged. The resulting list contains all the items in <paramref name="first"/>, followed
            by all the items in <paramref name="second"/>.
            </summary>
            <remarks>This method takes, on average, constant time, regardless of the size
            of either list. Although conceptually all of the items in both lists are
            copied, storage is shared until changes are made to the 
            shared sections.</remarks>
            <param name="first">The first list to concatenate.</param>
            <param name="second">The second list to concatenate.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> or <paramref name="second"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.GetRange(System.Int32,System.Int32)">
            <summary>
            Creates a new list that contains a subrange of elements from this list. The
            current list is unchanged.
            </summary>
            <remarks>This method takes take O(log N), where N is the size of the current list. Although
            the sub-range is conceptually copied, storage is shared between the two lists until a change
            is made to the shared items.</remarks>
            <remarks>If a view of a sub-range is desired, instead of a copy, use the
            more efficient <see cref="M:CodeSmith.Engine.PowerCollections.BigList`1.Range(System.Int32,System.Int32)"/> method, which provides a view onto a sub-range of items.</remarks>
            <param name="index">The starting index of the sub-range.</param>
            <param name="count">The number of items in the sub-range. If this is zero,
            the returned list is empty.</param>
            <returns>A new list with the <paramref name="count"/> items that start at <paramref name="index"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Range(System.Int32,System.Int32)">
            <summary>
            Returns a view onto a sub-range of this list. Items are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view, but insertions and deletions in the underlying list do not.
            </summary>
            <remarks>
            <para>If a copy of the sub-range is desired, use the <see cref="M:CodeSmith.Engine.PowerCollections.BigList`1.GetRange(System.Int32,System.Int32)"/> method instead.</para>
            <para>This method can be used to apply an algorithm to a portion of a list. For example:</para>
            <code>Algorithms.ReverseInPlace(list.Range(3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
            <param name="index">The starting index of the view.</param>
            <param name="count">The number of items in the view.</param>
            <returns>A list that is a view onto the given sub-list. </returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> or <paramref name="count"/> is negative.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> + <paramref name="count"/> is greater than the
            size of this list.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.GetEnumerator(System.Int32,System.Int32)">
            <summary>
            Enumerates a range of the items in the list, in order. The item at <paramref name="start"/>
            is enumerated first, then the next item at index 1, and so on. At most <paramref name="maxItems"/>
            items are enumerated. 
            </summary>
            <remarks>Enumerating all of the items in the list take time O(N), where
            N is the number of items being enumerated. Using GetEnumerator() or foreach
            is much more efficient than accessing all items by index.</remarks>
            <param name="start">Index to start enumerating at.</param>
            <param name="maxItems">Max number of items to enumerate.</param>
            <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.GetEnumerator">
            <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on. Usually, the
            foreach statement is used to call this method implicitly.
            </summary>
            <remarks>Enumerating all of the items in the list take time O(N), where
            N is the number of items in the list. Using GetEnumerator() or foreach
            is much more efficient than accessing all items by index.</remarks>
            <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.NodeFromEnumerable(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Given an IEnumerable&lt;T&gt;, create a new Node with all of the 
            items in the enumerable. Returns null if the enumerable has no items.
            </summary>
            <param name="collection">The collection to copy.</param>
            <returns>Returns a Node, not shared or with any shared children, 
            with the items from the collection. If the collection was empty,
            null is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafFromEnumerator(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Consumes up to MAXLEAF items from an Enumerator and places them in a leaf
            node. If the enumerator is at the end, null is returned.
            </summary>
            <param name="enumerator">The enumerator to take items from.</param>
            <returns>A LeafNode with items taken from the enumerator. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.NCopiesOfNode(System.Int32,CodeSmith.Engine.PowerCollections.BigList{`0}.Node)">
            <summary>
            Create a node that has N copies of the given node. 
            </summary>
            <param name="copies">Number of copies. Must be non-negative.</param>
            <param name="node">Node to make copies of.</param>
            <returns>null if node is null or copies is 0. Otherwise, a node consisting of <paramref name="copies"/> copies
            of node.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">copies is negative.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.CheckBalance">
            <summary>
            Check the balance of the current tree and rebalance it if it is more than BALANCEFACTOR
            levels away from fully balanced. Note that rebalancing a tree may leave it two levels away from 
            fully balanced.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Rebalance">
            <summary>
            Rebalance the current tree. Once rebalanced, the depth of the current tree is no more than
            two levels from fully balanced, where fully balanced is defined as having Fibonacci(N+2) or more items
            in a tree of depth N.
            </summary>
            <remarks>The rebalancing algorithm is from "Ropes: an Alternative to Strings", by 
            Boehm, Atkinson, and Plass, in SOFTWARE--PRACTICE AND EXPERIENCE, VOL. 25(12), 1315–1330 (DECEMBER 1995).
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.AddNodeToRebalanceArray(CodeSmith.Engine.PowerCollections.BigList{`0}.Node[],CodeSmith.Engine.PowerCollections.BigList{`0}.Node,System.Boolean)">
            <summary>
            Part of the rebalancing algorithm. Adds a node to the rebalance array. If it is already balanced, add it directly, otherwise
            add its children.
            </summary>
            <param name="rebalanceArray">Rebalance array to insert into.</param>
            <param name="node">Node to add.</param>
            <param name="shared">If true, mark the node as shared before adding, because one
            of its parents was shared.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.AddBalancedNodeToRebalanceArray(CodeSmith.Engine.PowerCollections.BigList{`0}.Node[],CodeSmith.Engine.PowerCollections.BigList{`0}.Node)">
            <summary>
            Part of the rebalancing algorithm. Adds a balanced node to the rebalance array. 
            </summary>
            <param name="rebalanceArray">Rebalance array to insert into.</param>
            <param name="balancedNode">Node to add.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConvertAll``1(System.Converter{`0,``0})">
            <summary>
            Convert the list to a new list by applying a delegate to each item in the collection. The resulting list
            contains the result of applying <paramref name="converter"/> to each item in the list, in
            order. The current list is unchanged.
            </summary>
            <typeparam name="TDest">The type each item is being converted to.</typeparam>
            <param name="converter">A delegate to the method to call, passing each item in <paramref name="converter"/>.</param>
            <returns>The resulting BigList from applying <paramref name="converter"/> to each item in this list.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="converter"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Reverse">
            <summary>
            Reverses the current list in place.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverses the items in the range of <paramref name="count"/> items starting from <paramref name="start"/>, in place.
            </summary>
            <param name="start">The starting index of the range to reverse.</param>
            <param name="count">The number of items in range to reverse.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Sort">
            <summary>
            Sorts the list in place.
            </summary>
            <remarks><para>The Quicksort algorithm is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
            <para>Values are compared by using the IComparable or IComparable&lt;T&gt;
            interface implementation on the type T.</para></remarks>
            <exception cref="T:System.InvalidOperationException">The type T does not implement either the IComparable or
            IComparable&lt;T&gt; interfaces.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the list in place. A supplied IComparer&lt;T&gt; is used
            to compare the items in the list. 
            </summary>
            <remarks>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</remarks>
            <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Sort(System.Comparison{`0})">
            <summary>
            Sorts the list in place. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the list.
            </summary>
            <remarks>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</remarks>
            <param name="comparison">The comparison delegate used to compare items in the collection.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.BinarySearch(`0)">
            <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            in the order defined by the default ordering of the item type; otherwise, 
            incorrect results will be returned.
            </summary>
            <param name="item">The item to search for.</param>
            <returns>Returns the index of the first occurence of <paramref name="item"/> in the list. If the item does not occur
            in the list, the bitwise complement of the first item larger than <paramref name="item"/> in the list is returned. If no item is 
            larger than <paramref name="item"/>, the bitwise complement of Count is returned.</returns>
            <exception cref="T:System.InvalidOperationException">The type T does not implement either the IComparable or
            IComparable&lt;T&gt; interfaces.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering defined by the passed IComparer&lt;T&gt; interface; otherwise, 
            incorrect results will be returned.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="comparer">The IComparer&lt;T&gt; interface used to sort the list.</param>
            <returns>Returns the index of the first occurence of <paramref name="item"/> in the list. If the item does not occur
            in the list, the bitwise complement of the first item larger than <paramref name="item"/> in the list is returned. If no item is 
            larger than <paramref name="item"/>, the bitwise complement of Count is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.BinarySearch(`0,System.Comparison{`0})">
            <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering defined by the passed Comparison&lt;T&gt; delegate; otherwise, 
            incorrect results will be returned.
            </summary>
            <param name="item">The item to search for.</param>
            <param name="comparison">The comparison delegate used to sort the list.</param>
            <returns>Returns the index of the first occurence of <paramref name="item"/> in the list. If the item does not occur
            in the list, the bitwise complement of the first item larger than <paramref name="item"/> in the list is returned. If no item is 
            larger than <paramref name="item"/>, the bitwise complement of Count is returned.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.BigList`1.Count">
            <summary>
            Gets the number of items stored in the BigList. The indices of the items
            range from 0 to Count-1.
            </summary>
            <remarks>Getting the number of items in the BigList takes constant time.</remarks>
            <value>The number of items in the BigList.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.BigList`1.Item(System.Int32)">
            <summary>
            Gets or sets an item in the list, by index.
            </summary>
            <remarks><para> Gettingor setting an item takes time O(log N), where N is the number of items
            in the list.</para>
            <para>To process each of the items in the list, using GetEnumerator() or a foreach loop is more efficient
            that accessing each of the elements by index.</para></remarks>
            <param name="index">The index of the item to get or set. The first item in the list
            has index 0, the last item has index Count-1.</param>
            <returns>The value of the item at the given index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than zero or 
            greater than or equal to Count.</exception>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.BigList`1.Node">
            <summary>
            The base class for the two kinds of nodes in the tree: Concat nodes
            and Leaf nodes.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.MarkShared">
            <summary>
            Marks this node as shared by setting the shared variable.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.GetAt(System.Int32)">
            <summary>
            Returns the items at the given index in this node.
            </summary>
            <param name="index">0-based index, relative to this node.</param>
            <returns>Item at that index.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.Subrange(System.Int32,System.Int32)">
            <summary>
            Returns a node that has a sub-range of items from this node. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
            <param name="first">Inclusive first element, relative to this node.</param>
            <param name="last">Inclusize last element, relative to this node.</param>
            <returns>Node with the given sub-range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.SetAt(System.Int32,`0)">
            <summary>
            Changes the item at the given index. Never changes this node,
            but always returns a new node with the given item changed.
            </summary>
            <param name="index">Index, relative to this node, to change.</param>
            <param name="item">New item to place at the given index.</param>
            <returns>A new node with the given item changed.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.SetAtInPlace(System.Int32,`0)">
            <summary>
            Changes the item at the given index. May change this node,
            or return a new node with the given item changed.
            </summary>
            <param name="index">Index, relative to this node, to change.</param>
            <param name="item">New item to place at the given index.</param>
            <returns>A node with the give item changed. If it can be done in place
            then "this" is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.Append(CodeSmith.Engine.PowerCollections.BigList{`0}.Node,System.Boolean)">
            <summary>
            Append a node after this node. Never changes this node, but returns
            a new node with the given appending done.
            </summary>
            <param name="node">Node to append.</param>
            <param name="nodeIsUnused">If true, the given node is not used
            in any current list, so it may be change, overwritten, or destroyed
            if convenient. If false, the given node is in use. It should be marked
            as shared if is is used within the return value.</param>
            <returns>A new node with the give node appended to this node.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.AppendInPlace(CodeSmith.Engine.PowerCollections.BigList{`0}.Node,System.Boolean)">
            <summary>
            Append a node after this node. May change this node, or return 
            a new node.
            </summary>
            <param name="node">Node to append.</param>
            <param name="nodeIsUnused">If true, the given node is not used
            in any current list, so it may be change, overwritten, or destroyed
            if convenient. If false, the given node is in use. It should be marked
            as shared if is is used within the return value.</param>
            <returns>A node with the give node appended to this node. May be a new
            node or the current node.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.AppendInPlace(`0)">
            <summary>
            Append a item after this node. May change this node, or return 
            a new node. Equivalent to AppendInPlace(new LeafNode(item), true), but
            may be more efficient because a new LeafNode might not be allocated.
            </summary>
            <param name="item">Item to append.</param>
            <returns>A node with the given item appended to this node. May be a new
            node or the current node.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Remove a range of items from this node. Never changes this node, but returns
            a new node with the removing done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
            <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
            <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
            <returns>A new node with the sub-range removed.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.RemoveRangeInPlace(System.Int32,System.Int32)">
            <summary>
            Remove a range of items from this node. May change this node, or returns
            a new node with the given appending done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
            <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
            <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
            <returns>A node with the sub-range removed. If done in-place, returns
            "this".</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.Insert(System.Int32,CodeSmith.Engine.PowerCollections.BigList{`0}.Node,System.Boolean)">
            <summary>
            Inserts a node inside this node. Never changes this node, but returns
            a new node with the given appending done.
            </summary>
            <param name="index">Index, relative to this node, to insert at. Must 
            be in bounds.</param>
            <param name="node">Node to insert.</param>
            <param name="nodeIsUnused">If true, the given node is not used
            in any current list, so it may be change, overwritten, or destroyed
            if convenient. If false, the given node is in use. It should be marked
            as shared if is is used within the return value.</param>
            <returns>A new node with the give node inserted.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.InsertInPlace(System.Int32,`0)">
            <summary>
            Inserts an item inside this node. May change this node, or return
            a new node with the given appending done. Equivalent to 
            InsertInPlace(new LeafNode(item), true), but may be more efficient.
            </summary>
            <param name="index">Index, relative to this node, to insert at. Must 
            be in bounds.</param>
            <param name="item">Item to insert.</param>
            <returns>A node with the give item inserted. If done in-place, returns
            "this".</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.InsertInPlace(System.Int32,CodeSmith.Engine.PowerCollections.BigList{`0}.Node,System.Boolean)">
            <summary>
            Inserts a node inside this node. May change this node, or return
            a new node with the given appending done.
            </summary>
            <param name="index">Index, relative to this node, to insert at. Must 
            be in bounds.</param>
            <param name="node">Node to insert.</param>
            <param name="nodeIsUnused">If true, the given node is not used
            in any current list, so it may be change, overwritten, or destroyed
            if convenient. If false, the given node is in use. It should be marked
            as shared if is is used within the return value.</param>
            <returns>A node with the given item inserted. If done in-place, returns
            "this".</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.Prepend(CodeSmith.Engine.PowerCollections.BigList{`0}.Node,System.Boolean)">
            <summary>
            Prefpend a node before this node. Never changes this node, but returns
            a new node with the given prepending done.
            </summary>
            <param name="node">Node to prepend.</param>
            <param name="nodeIsUnused">If true, the given node is not used
            in any current list, so it may be change, overwritten, or destroyed
            if convenient. If false, the given node is in use. It should be marked
            as shared if is is used within the return value.</param>
            <returns>A new node with the give node prepended to this node.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.PrependInPlace(CodeSmith.Engine.PowerCollections.BigList{`0}.Node,System.Boolean)">
            <summary>
            Prepend a node before this node. May change this node, or return 
            a new node.
            </summary>
            <param name="node">Node to prepend.</param>
            <param name="nodeIsUnused">If true, the given node is not used
            in any current list, so it may be change, overwritten, or destroyed
            if convenient. If false, the given node is in use. It should be marked
            as shared if is is used within the return value.</param>
            <returns>A node with the give node prepended to this node. May be a new
            node or the current node.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.PrependInPlace(`0)">
            <summary>
            Prepend a item before this node. May change this node, or return 
            a new node. Equivalent to PrependInPlace(new LeafNode(item), true), but
            may be more efficient because a new LeafNode might not be allocated.
            </summary>
            <param name="item">Item to prepend.</param>
            <returns>A node with the given item prepended to this node. May be a new
            node or the current node.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.IsBalanced">
            <summary>
            Determine if this node is balanced. A node is balanced if the number
            of items is greater than
            Fibonacci(Depth+2). Balanced nodes are never rebalanced unless
            they go out of balance again.
            </summary>
            <returns>True if the node is balanced by this definition.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.Node.IsAlmostBalanced">
            <summary>
            Determine if this node is almost balanced. A node is almost balanced if t
            its depth is at most one greater than a fully balanced node with the same count.
            </summary>
            <returns>True if the node is almost balanced by this definition.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.BigList`1.Node.Count">
            <summary>
            The number of items stored in the node (or below it).
            </summary>
            <value>The number of items in the node or below.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.BigList`1.Node.Shared">
            <summary>
            Is this node shared by more that one list (or within a single)
            lists. If true, indicates that this node, and any nodes below it,
            may never be modified. Never becomes false after being set to 
            true.
            </summary>
            <value></value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.BigList`1.Node.Depth">
            <summary>
            Gets the depth of this node. A leaf node has depth 0, 
            a concat node with two leaf children has depth 1, etc.
            </summary>
            <value>The depth of this node.</value>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode">
            <summary>
            The LeafNode class is the type of node that lives at the leaf of a tree and holds
            the actual items stored in the list. Each leaf holds at least 1, and at most MAXLEAF
            items in the items array. The number of items stored is found in "count", which may
            be less than "items.Length".
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.items">
            <summary>
            Array that stores the items in the nodes. Always has a least "count" elements,
            but may have more as padding.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.#ctor(`0)">
            <summary>
            Creates a LeafNode that holds a single item.
            </summary>
            <param name="item">Item to place into the leaf node.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.#ctor(System.Int32,`0[])">
            <summary>
            Creates a new leaf node with the indicates count of item and the
            </summary>
            <param name="count">Number of items. Can't be zero.</param>
            <param name="newItems">The array of items. The LeafNode takes
            possession of this array.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.GetAt(System.Int32)">
            <summary>
            Returns the items at the given index in this node.
            </summary>
            <param name="index">0-based index, relative to this node.</param>
            <returns>Item at that index.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.SetAtInPlace(System.Int32,`0)">
            <summary>
            Changes the item at the given index. May change this node,
            or return a new node with the given item changed.
            </summary>
            <param name="index">Index, relative to this node, to change.</param>
            <param name="item">New item to place at the given index.</param>
            <returns>A node with the give item changed. If it can be done in place
            then "this" is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.SetAt(System.Int32,`0)">
            <summary>
            Changes the item at the given index. Never changes this node,
            but always returns a new node with the given item changed.
            </summary>
            <param name="index">Index, relative to this node, to change.</param>
            <param name="item">New item to place at the given index.</param>
            <returns>A new node with the given item changed.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.MergeLeafInPlace(CodeSmith.Engine.PowerCollections.BigList{`0}.Node)">
            <summary>
            If other is a leaf node, and the resulting size would be less than MAXLEAF, merge
            the other leaf node into this one (after this one) and return true.
            </summary>
            <param name="other">Other node to possible merge.</param>
            <returns>If <paramref name="other"/> could be merged into this node, returns
            true. Otherwise returns false and the current node is unchanged.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.MergeLeaf(CodeSmith.Engine.PowerCollections.BigList{`0}.Node)">
            <summary>
            If other is a leaf node, and the resulting size would be less than MAXLEAF, merge
            the other leaf node with this one (after this one) and return a new node with 
            the merged items. Does not modify this.
            If no merging, return null.
            </summary>
            <param name="other">Other node to possible merge.</param>
            <returns>If the nodes could be merged, returns the new node. Otherwise
            returns null.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.PrependInPlace(`0)">
            <summary>
            Prepend a item before this node. May change this node, or return 
            a new node. Equivalent to PrependInPlace(new LeafNode(item), true), but
            may be more efficient because a new LeafNode might not be allocated.
            </summary>
            <param name="item">Item to prepend.</param>
            <returns>A node with the given item prepended to this node. May be a new
            node or the current node.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.AppendInPlace(`0)">
            <summary>
            Append a item after this node. May change this node, or return 
            a new node. Equivalent to AppendInPlace(new LeafNode(item), true), but
            may be more efficient because a new LeafNode might not be allocated.
            </summary>
            <param name="item">Item to append.</param>
            <returns>A node with the given item appended to this node. May be a new
            node or the current node.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.AppendInPlace(CodeSmith.Engine.PowerCollections.BigList{`0}.Node,System.Boolean)">
            <summary>
            Append a node after this node. May change this node, or return 
            a new node.
            </summary>
            <param name="node">Node to append.</param>
            <param name="nodeIsUnused">If true, the given node is not used
            in any current list, so it may be change, overwritten, or destroyed
            if convenient. If false, the given node is in use. It should be marked
            as shared if is is used within the return value.</param>
            <returns>A node with the give node appended to this node. May be a new
            node or the current node.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.InsertInPlace(System.Int32,`0)">
            <summary>
            Inserts an item inside this node. May change this node, or return
            a new node with the given appending done. Equivalent to 
            InsertInPlace(new LeafNode(item), true), but may be more efficient.
            </summary>
            <param name="index">Index, relative to this node, to insert at. Must 
            be in bounds.</param>
            <param name="item">Item to insert.</param>
            <returns>A node with the give item inserted. If done in-place, returns
            "this".</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.InsertInPlace(System.Int32,CodeSmith.Engine.PowerCollections.BigList{`0}.Node,System.Boolean)">
            <summary>
            Inserts a node inside this node. May change this node, or return
            a new node with the given appending done.
            </summary>
            <param name="index">Index, relative to this node, to insert at. Must 
            be in bounds.</param>
            <param name="node">Node to insert.</param>
            <param name="nodeIsUnused">If true, the given node is not used
            in any current list, so it may be change, overwritten, or destroyed
            if convenient. If false, the given node is in use. It should be marked
            as shared if is is used within the return value.</param>
            <returns>A node with the given item inserted. If done in-place, returns
            "this".</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.Insert(System.Int32,CodeSmith.Engine.PowerCollections.BigList{`0}.Node,System.Boolean)">
            <summary>
            Inserts a node inside this node. Never changes this node, but returns
            a new node with the given appending done.
            </summary>
            <param name="index">Index, relative to this node, to insert at. Must 
            be in bounds.</param>
            <param name="node">Node to insert.</param>
            <param name="nodeIsUnused">If true, the given node is not used
            in any current list, so it may be change, overwritten, or destroyed
            if convenient. If false, the given node is in use. It should be marked
            as shared if is is used within the return value.</param>
            <returns>A new node with the give node inserted.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.RemoveRangeInPlace(System.Int32,System.Int32)">
            <summary>
            Remove a range of items from this node. May change this node, or returns
            a new node with the given appending done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
            <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
            <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
            <returns>A node with the sub-range removed. If done in-place, returns
            "this".</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Remove a range of items from this node. Never changes this node, but returns
            a new node with the removing done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
            <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
            <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
            <returns>A new node with the sub-range removed.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.LeafNode.Subrange(System.Int32,System.Int32)">
            <summary>
            Returns a node that has a sub-range of items from this node. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
            <param name="first">Inclusive first element, relative to this node.</param>
            <param name="last">Inclusize last element, relative to this node.</param>
            <returns>Node with the given sub-range.</returns>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode">
            <summary>
            A ConcatNode is an interior (non-leaf) node that represents the concatination of
            the left and right child nodes. Both children must always be non-null.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.left">
            <summary>
            The left and right child nodes. They are never null.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.right">
            <summary>
            The left and right child nodes. They are never null.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.depth">
            <summary>
            The depth of this node -- the maximum length path to 
            a leaf. If this node has two children that are leaves, the
            depth in 1.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.#ctor(CodeSmith.Engine.PowerCollections.BigList{`0}.Node,CodeSmith.Engine.PowerCollections.BigList{`0}.Node)">
            <summary>
            Create a new ConcatNode with the given children.
            </summary>
            <param name="left">The left child. May not be null.</param>
            <param name="right">The right child. May not be null.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.NewNode(CodeSmith.Engine.PowerCollections.BigList{`0}.Node,CodeSmith.Engine.PowerCollections.BigList{`0}.Node)">
            <summary>
            Create a new node with the given children. Mark unchanged
            children as shared. There are four
            possible cases:
            1. If one of the new children is null, the other new child is returned.
            2. If neither child has changed, then this is marked as shared as returned.
            3. If one child has changed, the other child is marked shared an a new node is returned.
            4. If both children have changed, a new node is returned.
            </summary>
            <param name="newLeft">New left child.</param>
            <param name="newRight">New right child.</param>
            <returns>New node with the given children. Returns null if and only if both
            new children are null.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.NewNodeInPlace(CodeSmith.Engine.PowerCollections.BigList{`0}.Node,CodeSmith.Engine.PowerCollections.BigList{`0}.Node)">
            <summary>
            Updates a node with the given new children. If one of the new children is
            null, the other is returned. If both are null, null is returned.
            </summary>
            <param name="newLeft">New left child.</param>
            <param name="newRight">New right child.</param>
            <returns>Node with the given children. Usually, but not always, this. Returns
            null if and only if both new children are null.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.GetAt(System.Int32)">
            <summary>
            Returns the items at the given index in this node.
            </summary>
            <param name="index">0-based index, relative to this node.</param>
            <returns>Item at that index.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.SetAtInPlace(System.Int32,`0)">
            <summary>
            Changes the item at the given index. May change this node,
            or return a new node with the given item changed.
            </summary>
            <param name="index">Index, relative to this node, to change.</param>
            <param name="item">New item to place at the given index.</param>
            <returns>A node with the give item changed. If it can be done in place
            then "this" is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.SetAt(System.Int32,`0)">
            <summary>
            Changes the item at the given index. Never changes this node,
            but always returns a new node with the given item changed.
            </summary>
            <param name="index">Index, relative to this node, to change.</param>
            <param name="item">New item to place at the given index.</param>
            <returns>A new node with the given item changed.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.PrependInPlace(`0)">
            <summary>
            Prepend a item before this node. May change this node, or return 
            a new node. Equivalent to PrependInPlace(new LeafNode(item), true), but
            may be more efficient because a new LeafNode might not be allocated.
            </summary>
            <param name="item">Item to prepend.</param>
            <returns>A node with the given item prepended to this node. May be a new
            node or the current node.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.AppendInPlace(`0)">
            <summary>
            Append a item after this node. May change this node, or return 
            a new node. Equivalent to AppendInPlace(new LeafNode(item), true), but
            may be more efficient because a new LeafNode might not be allocated.
            </summary>
            <param name="item">Item to append.</param>
            <returns>A node with the given item appended to this node. May be a new
            node or the current node.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.AppendInPlace(CodeSmith.Engine.PowerCollections.BigList{`0}.Node,System.Boolean)">
            <summary>
            Append a node after this node. May change this node, or return 
            a new node.
            </summary>
            <param name="node">Node to append.</param>
            <param name="nodeIsUnused">If true, the given node is not used
            in any current list, so it may be change, overwritten, or destroyed
            if convenient. If false, the given node is in use. It should be marked
            as shared if is is used within the return value.</param>
            <returns>A node with the give node appended to this node. May be a new
            node or the current node.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.InsertInPlace(System.Int32,`0)">
            <summary>
            Inserts an item inside this node. May change this node, or return
            a new node with the given appending done. Equivalent to 
            InsertInPlace(new LeafNode(item), true), but may be more efficient.
            </summary>
            <param name="index">Index, relative to this node, to insert at. Must 
            be in bounds.</param>
            <param name="item">Item to insert.</param>
            <returns>A node with the give item inserted. If done in-place, returns
            "this".</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.InsertInPlace(System.Int32,CodeSmith.Engine.PowerCollections.BigList{`0}.Node,System.Boolean)">
            <summary>
            Inserts a node inside this node. May change this node, or return
            a new node with the given appending done.
            </summary>
            <param name="index">Index, relative to this node, to insert at. Must 
            be in bounds.</param>
            <param name="node">Node to insert.</param>
            <param name="nodeIsUnused">If true, the given node is not used
            in any current list, so it may be change, overwritten, or destroyed
            if convenient. If false, the given node is in use. It should be marked
            as shared if is is used within the return value.</param>
            <returns>A node with the given item inserted. If done in-place, returns
            "this".</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.Insert(System.Int32,CodeSmith.Engine.PowerCollections.BigList{`0}.Node,System.Boolean)">
            <summary>
            Inserts a node inside this node. Never changes this node, but returns
            a new node with the given appending done.
            </summary>
            <param name="index">Index, relative to this node, to insert at. Must 
            be in bounds.</param>
            <param name="node">Node to insert.</param>
            <param name="nodeIsUnused">If true, the given node is not used
            in any current list, so it may be change, overwritten, or destroyed
            if convenient. If false, the given node is in use. It should be marked
            as shared if is is used within the return value.</param>
            <returns>A new node with the give node inserted.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.RemoveRangeInPlace(System.Int32,System.Int32)">
            <summary>
            Remove a range of items from this node. May change this node, or returns
            a new node with the given appending done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
            <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
            <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
            <returns>A node with the sub-range removed. If done in-place, returns
            "this".</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Remove a range of items from this node. Never changes this node, but returns
            a new node with the removing done. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
            <param name="first">Inclusive index of first item in sub-range, relative
            to this node.</param>
            <param name="last">Inclusize index of last item in sub-range, relative
            to this node.</param>
            <returns>A new node with the sub-range removed.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.Subrange(System.Int32,System.Int32)">
            <summary>
            Returns a node that has a sub-range of items from this node. The
            sub-range may not be empty, but may extend outside the node. 
            In other words, first might be less than zero or last might be greater
            than count. But, last can't be less than zero and first can't be
            greater than count. Also, last must be greater than or equal to last.
            </summary>
            <param name="first">Inclusive first element, relative to this node.</param>
            <param name="last">Inclusize last element, relative to this node.</param>
            <returns>Node with the given sub-range.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.BigList`1.ConcatNode.Depth">
            <summary>
            The depth of this node -- the maximum length path to 
            a leaf. If this node has two children that are leaves, the
            depth in 1.
            </summary>
            <value>The depth of this node.</value>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.BigList`1.BigListRange">
            <summary>
            The class that is used to implement IList&lt;T&gt; to view a sub-range
            of a BigList. The object stores a wrapped list, and a start/count indicating
            a sub-range of the list. Insertion/deletions through the sub-range view
            cause the count to change also; insertions and deletions directly on
            the wrapped list do not.
            </summary>
            <remarks>This is different from Algorithms.Range in a very few respects:
            it is specialized to only wrap BigList, and it is a lot more efficient in enumeration.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.BigList`1.BigListRange.#ctor(CodeSmith.Engine.PowerCollections.BigList{`0},System.Int32,System.Int32)">
            <summary>
            Create a sub-range view object on the indicate part 
            of the list. 
            </summary>
            <param name="wrappedList">List to wrap.</param>
            <param name="start">The start index of the view in the wrapped list.</param>
            <param name="count">The number of items in the view.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Comparers">
            <summary>
            A collection of methods to create IComparer and IEqualityComparer instances in various ways.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Comparers.ComparerFromComparison``1(System.Comparison{``0})">
            <summary>
            Given an Comparison on a type, returns an IComparer on that type. 
            </summary>
            <typeparam name="T">T to compare.</typeparam>
            <param name="comparison">Comparison delegate on T</param>
            <returns>IComparer that uses the comparison.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Comparers.ComparerKeyValueFromComparerKey``2(System.Collections.Generic.IComparer{``0})">
            <summary>
            Given an IComparer on TKey, returns an IComparer on
            key-value Pairs. 
            </summary>
            <typeparam name="TKey">TKey of the pairs</typeparam>
            <typeparam name="TValue">TValue of the apris</typeparam>
            <param name="keyComparer">IComparer on TKey</param>
            <returns>IComparer for comparing key-value pairs.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Comparers.EqualityComparerKeyValueFromComparerKey``2(System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Given an IEqualityComparer on TKey, returns an IEqualityComparer on
            key-value Pairs. 
            </summary>
            <typeparam name="TKey">TKey of the pairs</typeparam>
            <typeparam name="TValue">TValue of the apris</typeparam>
            <param name="keyEqualityComparer">IComparer on TKey</param>
            <returns>IEqualityComparer for comparing key-value pairs.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Comparers.ComparerPairFromKeyValueComparers``2(System.Collections.Generic.IComparer{``0},System.Collections.Generic.IComparer{``1})">
            <summary>
            Given an IComparer on TKey and TValue, returns an IComparer on
            key-value Pairs of TKey and TValue, comparing first keys, then values. 
            </summary>
            <typeparam name="TKey">TKey of the pairs</typeparam>
            <typeparam name="TValue">TValue of the apris</typeparam>
            <param name="keyComparer">IComparer on TKey</param>
            <param name="valueComparer">IComparer on TValue</param>
            <returns>IComparer for comparing key-value pairs.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Comparers.ComparerKeyValueFromComparisonKey``2(System.Comparison{``0})">
            <summary>
            Given an Comparison on TKey, returns an IComparer on
            key-value Pairs. 
            </summary>
            <typeparam name="TKey">TKey of the pairs</typeparam>
            <typeparam name="TValue">TValue of the apris</typeparam>
            <param name="keyComparison">Comparison delegate on TKey</param>
            <returns>IComparer for comparing key-value pairs.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Comparers.DefaultComparer``1">
            <summary>
            Given an element type, check that it implements IComparable&lt;T&gt; or IComparable, then returns
            a IComparer that can be used to compare elements of that type.
            </summary>
            <returns>The IComparer&lt;T&gt; instance.</returns>
            <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;T&gt;.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Comparers.DefaultKeyValueComparer``2">
            <summary>
            Given an key and value type, check that TKey implements IComparable&lt;T&gt; or IComparable, then returns
            a IComparer that can be used to compare KeyValuePairs of those types.
            </summary>
            <returns>The IComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; instance.</returns>
            <exception cref="T:System.InvalidOperationException">TKey does not implement IComparable&lt;T&gt;.</exception>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Comparers.KeyValueEqualityComparer`2">
            <summary>
            Class to change an IEqualityComparer&lt;TKey&gt; to an IEqualityComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; 
            Only the keys are compared.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Comparers.KeyValueComparer`2">
            <summary>
            Class to change an IComparer&lt;TKey&gt; to an IComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; 
            Only the keys are compared.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Comparers.PairComparer`2">
            <summary>
            Class to change an IComparer&lt;TKey&gt; and IComparer&lt;TValue&gt; to an IComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; 
            Keys are compared, followed by values.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Comparers.ComparisonComparer`1">
            <summary>
            Class to change an Comparison&lt;T&gt; to an IComparer&lt;T&gt;.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Comparers.ComparisonKeyValueComparer`2">
            <summary>
            Class to change an Comparison&lt;TKey&gt; to an IComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.
            GetHashCode cannot be used on this class.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Deque`1">
            <summary>
            <para>The Deque class implements a type of list known as a Double Ended Queue. A Deque
            is quite similar to a List, in that items have indices (starting at 0), and the item at any
            index can be efficiently retrieved. The difference between a List and a Deque lies in the
            efficiency of inserting elements at the beginning. In a List, items can be efficiently added
            to the end, but inserting an item at the beginning of the List is slow, taking time 
            proportional to the size of the List. In a Deque, items can be added to the beginning 
            or end equally efficiently, regardless of the number of items in the Deque. As a trade-off
            for this increased flexibility, Deque is somewhat slower than List (but still constant time) when
            being indexed to get or retrieve elements. </para>
            </summary>
            <remarks>
            <para>The Deque class can also be used as a more flexible alternative to the Queue 
            and Stack classes. Deque is as efficient as Queue and Stack for adding or removing items, 
            but is more flexible: it allows access
            to all items in the queue, and allows adding or removing from either end.</para>
            <para>Deque is implemented as a ring buffer, which is grown as necessary. The size
            of the buffer is doubled whenever the existing capacity is too small to hold all the
            elements.</para>
            </remarks>
            <typeparam name="T">The type of items stored in the Deque.</typeparam>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.StopEnumerations">
            <summary>
            Must be called whenever there is a structural change in the tree. Causes
            changeStamp to be changed, which causes any in-progress enumerations
            to throw exceptions.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.CheckEnumerationStamp(System.Int32)">
            <summary>
            Checks the given stamp against the current change stamp. If different, the
            collection has changed during enumeration and an InvalidOperationException
            must be thrown
            </summary>
            <param name="startStamp">changeStamp at the start of the enumeration.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.#ctor">
            <summary>
            Create a new Deque that is initially empty.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a new Deque initialized with the items from the passed collection,
            in order.
            </summary>
            <param name="collection">A collection of items to initialize the Deque with.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies all the items in the Deque into an array.
            </summary>
            <param name="array">Array to copy to.</param>
            <param name="arrayIndex">Starting index in <paramref name="array"/> to copy to.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.TrimToSize">
            <summary>
            Trims the amount of memory used by the Deque by changing
            the Capacity to be equal to Count. If no more items will be added
            to the Deque, calling TrimToSize will reduce the amount of memory
            used by the Deque.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.Clear">
            <summary>
            Removes all items from the Deque.
            </summary>
            <remarks>Clearing the Deque takes a small constant amount of time, regardless of
            how many items are currently in the Deque.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.GetEnumerator">
            <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on. If the items
            are added to or removed from the Deque during enumeration, the 
            enumeration ends with an InvalidOperationException.
            </summary>
            <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
            <exception cref="T:System.InvalidOperationException">The Deque has an item added or deleted during the enumeration.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.CreateInitialBuffer(`0)">
            <summary>
            Creates the initial buffer and initialized the Deque to contain one initial
            item.
            </summary>
            <param name="firstItem">First and only item for the Deque.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.Insert(System.Int32,`0)">
            <summary>
            Inserts a new item at the given index in the Deque. All items at indexes 
            equal to or greater than <paramref name="index"/> move up one index
            in the Deque.
            </summary>
            <remarks>The amount of time to insert an item in the Deque is proportional
            to the distance of index from the closest end of the Deque: 
            O(Min(<paramref name="index"/>, Count - <paramref name="index"/>)).
            Thus, inserting an item at the front or end of the Deque is always fast; the middle of
            of the Deque is the slowest place to insert.
            </remarks>
            <param name="index">The index in the Deque to insert the item at. After the
            insertion, the inserted item is located at this index. The
            front item in the Deque has index 0.</param>
            <param name="item">The item to insert at the given index.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than Count.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts a collection of items at the given index in the Deque. All items at indexes 
            equal to or greater than <paramref name="index"/> increase their indices in the Deque
            by the number of items inserted.
            </summary>
            <remarks>The amount of time to insert a collection in the Deque is proportional
            to the distance of index from the closest end of the Deque, plus the number of items
            inserted (M): 
            O(M + Min(<paramref name="index"/>, Count - <paramref name="index"/>)).
            </remarks>
            <param name="index">The index in the Deque to insert the collection at. After the
            insertion, the first item of the inserted collection is located at this index. The
            front item in the Deque has index 0.</param>
            <param name="collection">The collection of items to insert at the given index.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than Count.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the given index in the Deque. All items at indexes 
            greater than <paramref name="index"/> move down one index
            in the Deque.
            </summary>
            <remarks>The amount of time to delete an item in the Deque is proportional
            to the distance of index from the closest end of the Deque: 
            O(Min(<paramref name="index"/>, Count - 1 - <paramref name="index"/>)).
            Thus, deleting an item at the front or end of the Deque is always fast; the middle of
            of the Deque is the slowest place to delete.
            </remarks>
            <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes a range of items at the given index in the Deque. All items at indexes 
            greater than <paramref name="index"/> move down <paramref name="count"/> indices
            in the Deque.
            </summary>
            <remarks>The amount of time to delete <paramref name="count"/> items in the Deque is proportional
            to the distance to the closest end of the Deque: 
            O(Min(<paramref name="index"/>, Count - <paramref name="index"/> - <paramref name="count"/>)).
            </remarks>
            <param name="index">The index in the list to remove the range at. The
            first item in the list has index 0.</param>
            <param name="count">The number of items to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count, or <paramref name="count"/> is less than zero
            or too large.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.IncreaseBuffer">
            <summary>
            Increase the amount of buffer space. When calling this method, the Deque
            must not be empty. If start and end are equal, that indicates a completely
            full Deque.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.AddToFront(`0)">
            <summary>
            Adds an item to the front of the Deque. The indices of all existing items
            in the Deque are increased by 1. This method is 
            equivalent to <c>Insert(0, item)</c> but is a little more
            efficient.
            </summary>
            <remarks>Adding an item to the front of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.AddManyToFront(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a collection of items to the front of the Deque. The indices of all existing items
            in the Deque are increased by the number of items inserted. The first item in the added collection becomes the
            first item in the Deque. 
            </summary>
            <remarks>This method takes time O(M), where M is the number of items in the 
            <paramref name="collection"/>.</remarks>
            <param name="collection">The collection of items to add.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.AddToBack(`0)">
            <summary>
            Adds an item to the back of the Deque. The indices of all existing items
            in the Deque are unchanged. This method is 
            equivalent to <c>Insert(Count, item)</c> but is a little more
            efficient.
            </summary>
            <remarks>Adding an item to the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.Add(`0)">
            <summary>
            Adds an item to the back of the Deque. The indices of all existing items
            in the Deque are unchanged. This method is 
            equivalent to <c>AddToBack(item)</c>.
            </summary>
            <remarks>Adding an item to the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.AddManyToBack(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a collection of items to the back of the Deque. The indices of all existing items
            in the Deque are unchanged. The last item in the added collection becomes the
            last item in the Deque.
            </summary>
            <remarks>This method takes time O(M), where M is the number of items in the 
            <paramref name="collection"/>.</remarks>
            <param name="collection">The collection of item to add.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.RemoveFromFront">
            <summary>
            Removes an item from the front of the Deque. The indices of all existing items
            in the Deque are decreased by 1. This method is 
            equivalent to <c>RemoveAt(0)</c> but is a little more
            efficient.
            </summary>
            <remarks>Removing an item from the front of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
            <returns>The item that was removed.</returns>
            <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.RemoveFromBack">
            <summary>
            Removes an item from the back of the Deque. The indices of all existing items
            in the Deque are unchanged. This method is 
            equivalent to <c>RemoveAt(Count-1)</c> but is a little more
            efficient.
            </summary>
            <remarks>Removing an item from the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
            <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.GetAtFront">
            <summary>
            Retreives the item currently at the front of the Deque. The Deque is 
            unchanged. This method is 
            equivalent to <c>deque[0]</c> (except that a different exception is thrown).
            </summary>
            <remarks>Retreiving the item at the front of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
            <returns>The item at the front of the Deque.</returns>
            <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.GetAtBack">
            <summary>
            Retreives the item currently at the back of the Deque. The Deque is 
            unchanged. This method is 
            equivalent to <c>deque[deque.Count - 1]</c> (except that a different exception is thrown).
            </summary>
            <remarks>Retreiving the item at the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
            <returns>The item at the back of the Deque.</returns>
            <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.Clone">
            <summary>
            Creates a new Deque that is a copy of this one.
            </summary>
            <remarks>Copying a Deque takes O(N) time, where N is the number of items in this Deque..</remarks>
            <returns>A copy of the current deque.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.System#ICloneable#Clone">
            <summary>
            Creates a new Deque that is a copy of this one.
            </summary>
            <remarks>Copying a Deque takes O(N) time, where N is the number of items in this Deque..</remarks>
            <returns>A copy of the current deque.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Deque`1.CloneContents">
            <summary>
            Makes a deep clone of this Deque. A new Deque is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
            <remarks><para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
            <para>Cloning the Deque takes time O(N), where N is the number of items in the Deque.</para></remarks>
            <returns>The cloned Deque.</returns>
            <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.Deque`1.Count">
            <summary>
            Gets the number of items currently stored in the Deque. The last item
            in the Deque has index Count-1.
            </summary>
            <remarks>Getting the count of items in the Deque takes a small constant
            amount of time.</remarks>
            <value>The number of items stored in this Deque.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.Deque`1.Capacity">
            <summary>
            Gets or sets the capacity of the Deque. The Capacity is the number of
            items that this Deque can hold without expanding its internal buffer. Since
            Deque will automatically expand its buffer when necessary, in almost all cases
            it is unnecessary to worry about the capacity. However, if it is known that a
            Deque will contain exactly 1000 items eventually, it can slightly improve 
            efficiency to set the capacity to 1000 up front, so that the Deque does not
            have to expand automatically.
            </summary>
            <value>The number of items that this Deque can hold without expanding its
            internal buffer.</value>
            <exception cref="T:System.ArgumentOutOfRangeException">The capacity is being set
            to less than Count, or to too large a value.</exception>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.Deque`1.Item(System.Int32)">
            <summary>
            Gets or sets an item at a particular index in the Deque. 
            </summary>
            <remarks>Getting or setting the item at a particular index takes a small constant amount
            of time, no matter what index is used.</remarks>
            <param name="index">The index of the item to retrieve or change. The front item has index 0, and
            the back item has index Count-1.</param>
            <returns>The value at the indicated index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The index is less than zero or greater than or equal
            to Count.</exception>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.DictionaryBase`2">
            <summary>
            DictionaryBase is a base class that can be used to more easily implement the
            generic IDictionary&lt;T&gt; and non-generic IDictionary interfaces.
            </summary>
            <remarks>
            <para>To use DictionaryBase as a base class, the derived class must override
            Count, GetEnumerator, TryGetValue, Clear, Remove, and the indexer set accessor. </para>
            </remarks>
            <typeparam name="TKey">The key type of the dictionary.</typeparam>
            <typeparam name="TValue">The value type of the dictionary.</typeparam>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.#ctor">
            <summary>
            Creates a new DictionaryBase. 
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.Clear">
            <summary>
            Clears the dictionary. This method must be overridden in the derived class.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.Remove(`0)">
            <summary>
            Removes a key from the dictionary. This method must be overridden in the derived class.
            </summary>
            <param name="key">Key to remove from the dictionary.</param>
            <returns>True if the key was found, false otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.TryGetValue(`0,`1@)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. If so, the value
            associated with that key is returned through the value parameter. This method must be
            overridden by the derived class.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="value">Returns the value associated with key, if true was returned.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.Add(`0,`1)">
            <summary>
            Adds a new key-value pair to the dictionary. 
            </summary>
            <remarks>The default implementation of this method
            checks to see if the key already exists using 
            ContainsKey, then calls the indexer setter if the key doesn't
            already exist. </remarks>
            <param name="key">Key to add.</param>
            <param name="value">Value to associated with the key.</param>
            <exception cref="T:System.ArgumentException">key is already present in the dictionary</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.ContainsKey(`0)">
            <summary>
            Determines whether a given key is found
            in the dictionary.
            </summary>
            <remarks>The default implementation simply calls TryGetValue and returns
            what it returns.</remarks>
            <param name="key">Key to look for in the dictionary.</param>
            <returns>True if the key is present in the dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.ToString">
            <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
            <returns>The string representation of the dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.AsReadOnly">
            <summary>
            Provides a read-only view of this dictionary. The returned IDictionary&lt;TKey,TValue&gt; provides
            a view of the dictionary that prevents modifications to the dictionary. Use the method to provide
            access to the dictionary without allowing changes. Since the returned object is just a view,
            changes to the dictionary will be reflected in the view.
            </summary>
            <returns>An IIDictionary&lt;TKey,TValue&gt; that provides read-only access to the dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds a key-value pair to the collection. This implementation calls the Add method
            with the Key and Value from the item.
            </summary>
            <param name="item">A KeyValuePair contains the Key and Value to add.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines if a dictionary contains a given KeyValuePair. This implementation checks to see if the
            dictionary contains the given key, and if the value associated with the key is equal to (via object.Equals)
            the value.
            </summary>
            <param name="item">A KeyValuePair containing the Key and Value to check for.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines if a dictionary contains a given KeyValuePair, and if so, removes it. This implementation checks to see if the
            dictionary contains the given key, and if the value associated with the key is equal to (via object.Equals)
            the value. If so, the key-value pair is removed.
            </summary>
            <param name="item">A KeyValuePair containing the Key and Value to check for.</param>
            <returns>True if the item was found and removed. False otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.CheckGenericType``1(System.String,System.Object)">
            <summary>
            Check that the given parameter is of the expected generic type. Throw an ArgumentException
            if it isn't.
            </summary>
            <typeparam name="ExpectedType">Expected type of the parameter</typeparam>
            <param name="name">parameter name</param>
            <param name="value">parameter value</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            Adds a key-value pair to the collection. If key or value are not of the expected types, an
            ArgumentException is thrown. If both key and value are of the expected types, the (overridden)
            Add method is called with the key and value to add.
            </summary>
            <param name="key">Key to add to the dictionary.</param>
            <param name="value">Value to add to the dictionary.</param>
            <exception cref="T:System.ArgumentException">key or value are not of the expected type for this dictionary.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.System#Collections#IDictionary#Clear">
            <summary>
            Clears this dictionary. Calls the (overridden) Clear method.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. The dictionary
            is not changed. Calls the (overridden) ContainsKey method. If key is not of the correct
            TKey for the dictionary, false is returned.
            </summary>
            <param name="key">The key to search for.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            Removes the key (and associated value) from the collection that is equal to the passed in key. If
            no key in the dictionary is equal to the passed key, the 
            dictionary is unchanged. Calls the (overridden) Remove method. If key is not of the correct
            TKey for the dictionary, the dictionary is unchanged.
            </summary>
            <param name="key">The key to remove.</param>
            <exception cref="T:System.ArgumentException">key could not be converted to TKey.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Returns an enumerator that enumerates all the entries in the dictionary. Each entry is 
            returned as a DictionaryEntry.
            The entries are enumerated in the same orders as the (overridden) GetEnumerator
            method.
            </summary>
            <returns>An enumerator for enumerating all the elements in the OrderedDictionary.</returns>		
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that enumerates all the entries in the dictionary. Each entry is 
            returned as a DictionaryEntry.
            The entries are enumerated in the same orders as the (overridden) GetEnumerator
            method.
            </summary>
            <returns>An enumerator for enumerating all the elements in the OrderedDictionary.</returns>		
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.DebuggerDisplayString">
            <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
            <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.DictionaryBase`2.Item(`0)">
            <summary>
            The indexer of the dictionary. This is used to store keys and values and
            retrieve values from the dictionary. The setter
            accessor must be overridden in the derived class.
            </summary>
            <param name="key">Key to find in the dictionary.</param>
            <returns>The value associated with the key.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown from the get accessor if the key
            was not found in the dictionary.</exception>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.DictionaryBase`2.Keys">
            <summary>
            Returns a collection of the keys in this dictionary. 
            </summary>
            <value>A read-only collection of the keys in this dictionary.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.DictionaryBase`2.Values">
            <summary>
            Returns a collection of the values in this dictionary. The ordering of 
            values in this collection is the same as that in the Keys collection.
            </summary>
            <value>A read-only collection of the values in this dictionary.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.DictionaryBase`2.System#Collections#IDictionary#IsFixedSize">
            <summary>
            Returns whether this dictionary is fixed size. This implemented always returns false.
            </summary>
            <value>Always returns false.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.DictionaryBase`2.System#Collections#IDictionary#IsReadOnly">
            <summary>
            Returns if this dictionary is read-only. This implementation always returns false.
            </summary>
            <value>Always returns false.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.DictionaryBase`2.System#Collections#IDictionary#Keys">
            <summary>
            Returns a collection of all the keys in the dictionary. The values in this collection will
            be enumerated in the same order as the (overridden) GetEnumerator method.
            </summary>
            <value>The collection of keys.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.DictionaryBase`2.System#Collections#IDictionary#Values">
            <summary>
            Returns a collection of all the values in the dictionary. The values in this collection will
            be enumerated in the same order as the (overridden) GetEnumerator method.
            </summary>
            <value>The collection of values.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.DictionaryBase`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            Gets or sets the value associated with a given key. When getting a value, if this
            key is not found in the collection, then null is returned. When setting
            a value, the value replaces any existing value in the dictionary. If either the key or value
            are not of the correct type for this dictionary, an ArgumentException is thrown.
            </summary>
            <value>The value associated with the key, or null if the key was not present.</value>
            <exception cref="T:System.ArgumentException">key could not be converted to TKey, or value could not be converted to TValue.</exception>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.DictionaryBase`2.KeysCollection">
            <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Keys collection. The collection is read-only.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1">
            <summary>
            ReadOnlyCollectionBase is a base class that can be used to more easily implement the
            generic ICollection&lt;T&gt; and non-generic ICollection interfaces for a read-only collection:
            a collection that does not allow adding or removing elements.
            </summary>
            <remarks>
            <para>To use ReadOnlyCollectionBase as a base class, the derived class must override
            the Count and GetEnumerator methods. </para>
            <para>ICollection&lt;T&gt;.Contains need not be implemented by the
            derived class, but it should be strongly considered, because the ReadOnlyCollectionBase implementation
            may not be very efficient.</para>
            </remarks>
            <typeparam name="T">The item type of the collection.</typeparam>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.#ctor">
            <summary>
            Creates a new ReadOnlyCollectionBase. 
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.MethodModifiesCollection">
            <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.ToString">
            <summary>
            Shows the string representation of the collection. The string representation contains
            a list of the items in the collection.
            </summary>
            <returns>The string representation of the collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.Exists(System.Predicate{`0})">
            <summary>
            Determines if the collection contains any item that satisfies the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>True if the collection contains one or more items that satisfy the condition
            defined by <paramref name="predicate"/>. False if the collection does not contain
            an item that satisfies <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.TrueForAll(System.Predicate{`0})">
            <summary>
            Determines if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>True if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate"/>, or if the collection is empty. False if one or more items
            in the collection do not satisfy <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.CountWhere(System.Predicate{`0})">
            <summary>
            Counts the number of items in the collection that satisfy the condition
            defined by <paramref name="predicate"/>.
            </summary>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>The number of items in the collection that satisfy <paramref name="predicate"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.FindAll(System.Predicate{`0})">
            <summary>
            Enumerates the items in the collection that satisfy the condition defined
            by <paramref name="predicate"/>.
            </summary>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <returns>An IEnumerable&lt;T&gt; that enumerates the items that satisfy the condition.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.ForEach(System.Action{`0})">
            <summary>
            Performs the specified action on each item in this collection.
            </summary>
            <param name="action">An Action delegate which is invoked for each item in this collection.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.ConvertAll``1(System.Converter{`0,``0})">
            <summary>
            Convert this collection of items by applying a delegate to each item in the collection. The resulting enumeration
            contains the result of applying <paramref name="converter"/> to each item in this collection, in
            order.
            </summary>
            <typeparam name="TOutput">The type each item is being converted to.</typeparam>
            <param name="converter">A delegate to the method to call, passing each item in this collection.</param>
            <returns>An IEnumerable&lt;TOutput^gt; that enumerates the resulting collection from applying <paramref name="converter"/> to each item in this collection in
            order.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="converter"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            This method throws an NotSupportedException
            stating the collection is read-only.
            </summary>
            <param name="item">Item to be added to the collection.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.System#Collections#Generic#ICollection{T}#Clear">
            <summary>
            This method throws an NotSupportedException
            stating the collection is read-only.
            </summary>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <summary>
            This method throws an NotSupportedException
            stating the collection is read-only.
            </summary>
            <param name="item">Item to be removed from the collection.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.Contains(`0)">
            <summary>
            Determines if the collection contains a particular item. This default implementation
            iterates all of the items in the collection via GetEnumerator, testing each item
            against <paramref name="item"/> using IComparable&lt;T&gt;.Equals or
            Object.Equals.
            </summary>
            <remarks>You should strongly consider overriding this method to provide
            a more efficient implementation.</remarks>
            <param name="item">The item to check for in the collection.</param>
            <returns>True if the collection contains <paramref name="item"/>, false otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies all the items in the collection into an array. Implemented by
            using the enumerator returned from GetEnumerator to get all the items
            and copy them to the provided array.
            </summary>
            <param name="array">Array to copy to.</param>
            <param name="arrayIndex">Starting index in <paramref name="array"/> to copy to.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.ToArray">
            <summary>
            Creates an array of the correct size, and copies all the items in the 
            collection into the array, by calling CopyTo.
            </summary>
            <returns>An array containing all the elements in the collection, in order.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.GetEnumerator">
            <summary>
            Must be overridden to enumerate all the members of the collection.
            </summary>
            <returns>A generic IEnumerator&lt;T&gt; that can be used
            to enumerate all the items in the collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies all the items in the collection into an array. Implemented by
            using the enumerator returned from GetEnumerator to get all the items
            and copy them to the provided array.
            </summary>
            <param name="array">Array to copy to.</param>
            <param name="index">Starting index in <paramref name="array"/> to copy to.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Provides an IEnumerator that can be used to iterate all the members of the
            collection. This implementation uses the IEnumerator&lt;T&gt; that was overridden
            by the derived classes to enumerate the members of the collection.
            </summary>
            <returns>An IEnumerator that can be used to iterate the collection.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.DebuggerDisplayString">
            <summary>
            Display the contents of the collection in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
            <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.Count">
            <summary>
            Must be overridden to provide the number of items in the collection.
            </summary>
            <value>The number of items in the collection.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Indicates whether the collection is read-only. Returns the value
            of readOnly that was provided to the constructor.
            </summary>
            <value>Always true.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Indicates whether the collection is synchronized.
            </summary>
            <value>Always returns false, indicating that the collection is not synchronized.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyCollectionBase`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Indicates the synchronization object for this collection.
            </summary>
            <value>Always returns this.</value>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.KeysCollection.#ctor(CodeSmith.Engine.PowerCollections.DictionaryBase{`0,`1})">
            <summary>
            Constructor.
            </summary>
            <param name="myDictionary">The dictionary this is associated with.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.DictionaryBase`2.ValuesCollection">
            <summary>
            A private class that implements ICollection&lt;TValue&gt; and ICollection for the
            Values collection. The collection is read-only.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.DictionaryBase`2.DictionaryEnumeratorWrapper">
            <summary>
            A class that wraps a IDictionaryEnumerator around an IEnumerator that
            enumerates KeyValuePairs. This is useful in implementing IDictionary, because
            IEnumerator can be implemented with an iterator, but IDictionaryEnumerator cannot.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.DictionaryBase`2.DictionaryEnumeratorWrapper.#ctor(System.Collections.Generic.IEnumerator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Constructor.
            </summary>
            <param name="enumerator">The enumerator of KeyValuePairs that is being wrapped.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Hash`1">
             <summary>
             The base implementation for various collections classes that use hash tables
             as part of their implementation. This class should not (and can not) be 
             used directly by end users; it's only for internal use by the collections package. The Hash
             does not handle duplicate values.
             </summary>
             <remarks>
             The Hash manages items of type T, and uses a IComparer&lt;ItemTYpe&gt; that
             hashes compares items to hash items into the table.  
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructor. Create a new hash table.
            </summary>
            <param name="equalityComparer">The comparer to use to compare items. </param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.GetEnumerationStamp">
            <summary>
            Gets the current enumeration stamp. Call CheckEnumerationStamp later
            with this value to throw an exception if the hash table is changed.
            </summary>
            <returns>The current enumeration stamp.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.StopEnumerations">
            <summary>
            Must be called whenever there is a structural change in the tree. Causes
            changeStamp to be changed, which causes any in-progress enumerations
            to throw exceptions.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.CheckEnumerationStamp(System.Int32)">
            <summary>
            Checks the given stamp against the current change stamp. If different, the
            collection has changed during enumeration and an InvalidOperationException
            must be thrown
            </summary>
            <param name="startStamp">changeStamp at the start of the enumeration.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.GetFullHash(`0)">
            <summary>
            Gets the full hash code for an item.
            </summary>
            <param name="item">Item to get hash code for.</param>
            <returns>The full hash code. It is never zero.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.GetHashValuesFromFullHash(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Get the initial bucket number and skip amount from the full hash value.
            </summary>
            <param name="hash">The full hash value.</param>
            <param name="initialBucket">Returns the initial bucket. Always in the range 0..(totalSlots - 1).</param>
            <param name="skip">Returns the skip values. Always odd in the range 0..(totalSlots - 1).</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.GetHashValues(`0,System.Int32@,System.Int32@)">
            <summary>
            Gets the full hash value, initial bucket number, and skip amount for an item.
            </summary>
            <param name="item">Item to get hash value of.</param>
            <param name="initialBucket">Returns the initial bucket. Always in the range 0..(totalSlots - 1).</param>
            <param name="skip">Returns the skip values. Always odd in the range 0..(totalSlots - 1).</param>
            <returns>The full hash value. This is never zero.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.EnsureEnoughSlots(System.Int32)">
            <summary>
            Make sure there are enough slots in the hash table that <paramref name="additionalItems"/>
            items can be inserted into the table.
            </summary>
            <param name="additionalItems">Number of additional items we are inserting.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.ShrinkIfNeeded">
            <summary>
            Check if the number of items in the table is small enough that
            we should shrink the table again.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.GetSecondaryShift(System.Int32)">
            <summary>
            Given the size of a hash table, compute the "secondary shift" value -- the shift
            that is used to determine the skip amount for collision resolution.
            </summary>
            <param name="newSize">The new size of the table.</param>
            <returns>The secondary skip amount.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.ResizeTable(System.Int32)">
            <summary>
            Resize the hash table to the given new size, moving all items into the
            new hash table.
            </summary>
            <param name="newSize">The new size of the hash table. Must be a power
            of two.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.Insert(`0,System.Boolean,`0@)">
            <summary>
            Insert a new item into the hash table. If a duplicate item exists, can replace or
            do nothing.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="replaceOnDuplicate">If true, duplicate items are replaced. If false, nothing
            is done if a duplicate already exists.</param>
            <param name="previous">If a duplicate was found, returns it (whether replaced or not).</param>
            <returns>True if no duplicate existed, false if a duplicate was found.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.Delete(`0,`0@)">
            <summary>
            Deletes an item from the hash table. 
            </summary>
            <param name="item">Item to search for and delete.</param>
            <param name="itemDeleted">If true returned, the actual item stored in the hash table (must be 
            equal to <paramref name="item"/>, but may not be identical.</param>
            <returns>True if item was found and deleted, false if item wasn't found.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.Find(`0,System.Boolean,`0@)">
            <summary>
            Find an item in the hash table. If found, optionally replace it with the
            finding item.
            </summary>
            <param name="find">Item to find.</param>
            <param name="replace">If true, replaces the equal item in the hash table
            with <paramref name="item"/>.</param>
            <param name="item">Returns the equal item found in the table, if true was returned.</param>
            <returns>True if the item was found, false otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.GetEnumerator">
            <summary>
            Enumerate all of the items in the hash table. The items
            are enumerated in a haphazard, unpredictable order.
            </summary>
            <returns>An IEnumerator&lt;T&gt; that enumerates the items
            in the hash table.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerate all of the items in the hash table. The items
            are enumerated in a haphazard, unpredictable order.
            </summary>
            <returns>An IEnumerator that enumerates the items
            in the hash table.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.Clone(System.Converter{`0,`0})">
            <summary>
            Creates a clone of this hash table.
            </summary>
            <param name="cloneItem">If non-null, this function is applied to each item when cloning. It must be the 
            case that this function does not modify the hash code or equality function.</param>
            <returns>A shallow clone that contains the same items.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialize the hash table. Called from the serialization infrastructure.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Called on deserialization. We cannot deserialize now, because hash codes
            might not be correct now. We do real deserialization in the OnDeserialization call.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)">
            <summary>
            Deserialize the hash table. Called from the serialization infrastructure when 
            the object graph has finished deserializing.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.Hash`1.ElementCount">
            <summary>
            Get the number of items in the hash table.
            </summary>
            <value>The number of items stored in the hash table.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.Hash`1.SlotCount">
            <summary>
            Get the number of slots in the hash table. Exposed internally
            for testing purposes.
            </summary>
            <value>The number of slots in the hash table.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.Hash`1.LoadFactor">
            <summary>
            Get or change the load factor. Changing the load factor may cause
            the size of the table to grow or shrink accordingly.
            </summary>
            <value></value>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Hash`1.Slot">
            <summary>
            The structure that has each slot in the hash table. Each slot has three parts:
            1. The collision bit. Indicates whether some item visited this slot but had to
            keep looking because the slot was full. 
            2. 31-bit full hash value of the item. If zero, the slot is empty.
            3. The item itself.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Hash`1.Slot.Clear">
            <summary>
            Clear this slot, leaving the collision bit alone.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.Hash`1.Slot.HashValue">
            <summary>
            The full hash value associated with the value in this slot, or zero
            if the slot is empty.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.Hash`1.Slot.Empty">
            <summary>
            Is this slot empty?
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.Hash`1.Slot.Collision">
            <summary>
            The "Collision" bit indicates that some value hit this slot and
            collided, so had to try another slot.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.MultiDictionary`2">
             <summary>
             <para>The MultiDictionary class that associates values with a key. Unlike an Dictionary,
             each key can have multiple values associated with it. When indexing an MultiDictionary, instead
             of a single value associated with a key, you retrieve an enumeration of values.</para>
             <para>When constructed, you can chose to allow the same value to be associated with a key multiple
             times, or only one time. </para>
             </summary>
             <typeparam name="TKey">The type of the keys.</typeparam>
             <typeparam name="TValue">The of values associated with the keys.</typeparam>
            <seealso cref="T:System.Collections.Generic.Dictionary`2"/>
            <seealso cref="T:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2"/>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2">
            <summary>
            MultiDictionaryBase is a base class that can be used to more easily implement a class
            that associates multiple values to a single key. The class implements the generic
            IDictionary&lt;TKey, ICollection&lt;TValue&gt;&gt; interface.
            </summary>
            <remarks>
            <para>To use MultiDictionaryBase as a base class, the derived class must override
            Count, Clear, Add, Remove(TKey), Remove(TKey,TValue), Contains(TKey,TValue), 
            EnumerateKeys, and TryEnumerateValuesForKey. </para>
            <para>It may wish consider overriding CountValues, CountAllValues, ContainsKey,
            and EqualValues, but these are not required.
            </para>
            </remarks>
            <typeparam name="TKey">The key type of the dictionary.</typeparam>
            <typeparam name="TValue">The value type of the dictionary.</typeparam>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.#ctor">
            <summary>
            Creates a new MultiDictionaryBase. 
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.Clear">
            <summary>
            Clears the dictionary. This method must be overridden in the derived class.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.EnumerateKeys">
            <summary>
            Enumerate all the keys in the dictionary. This method must be overridden by a derived
            class.
            </summary>
            <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the collection that
            have at least one value associated with them.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
            <summary>
            Enumerate all of the values associated with a given key. This method must be overridden
            by the derived class. If the key exists and has values associated with it, an enumerator for those
            values is returned throught <paramref name="values"/>. If the key does not exist, false is returned.
            </summary>
            <param name="key">The key to get values for.</param>
            <param name="values">If true is returned, this parameter receives an enumerators that
            enumerates the values associated with that key.</param>
            <returns>True if the key exists and has values associated with it. False otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.Add(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
            <summary>
            Adds a key-value pair to the collection. The value part of the pair must be a collection
            of values to associate with the key. If values are already associated with the given
            key, the new values are added to the ones associated with that key.
            </summary>
            <param name="item">A KeyValuePair contains the Key and Value collection to add.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.System#Collections#Generic#IDictionary{TKey@System#Collections#Generic#ICollection{TValue}}#Add(`0,System.Collections.Generic.ICollection{`1})">
            <summary>
            Implements IDictionary&lt;TKey, IEnumerable&lt;TValue&gt;&gt;.Add. If the 
            key is already present, and ArgumentException is thrown. Otherwise, a
            new key is added, and new values are associated with that key.
            </summary>
            <param name="key">Key to add.</param>
            <param name="values">Values to associate with that key.</param>
            <exception cref="T:System.ArgumentException">The key is already present in the dictionary.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.AddMany(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            <para>Adds new values to be associated with a key. If duplicate values are permitted, this
            method always adds new key-value pairs to the dictionary.</para>
            <para>If duplicate values are not permitted, and <paramref name="key"/> already has a value
            equal to one of <paramref name="values"/> associated with it, then that value is replaced,
            and the number of values associate with <paramref name="key"/> is unchanged.</para>
            </summary>
            <param name="key">The key to associate with.</param>
            <param name="values">A collection of values to associate with <paramref name="key"/>.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.Add(`0,`1)">
            <summary>
            Adds a new key-value pair to the dictionary.  This method must be overridden in the derived class.
            </summary>
            <param name="key">Key to add.</param>
            <param name="value">Value to associated with the key.</param>
            <exception cref="T:System.ArgumentException">key is already present in the dictionary</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.Remove(`0)">
            <summary>
            Removes a key from the dictionary. This method must be overridden in the derived class.
            </summary>
            <param name="key">Key to remove from the dictionary.</param>
            <returns>True if the key was found, false otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.Remove(`0,`1)">
            <summary>
            Removes a key-value pair from the dictionary. This method must be overridden in the derived class.
            </summary>
            <param name="key">Key to remove from the dictionary.</param>
            <param name="value">Associated value to remove from the dictionary.</param>
            <returns>True if the key-value pair was found, false otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.Remove(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
            <summary>
            Removes a set of values from a given key. If all values associated with a key are
            removed, then the key is removed also.
            </summary>
            <param name="pair">A KeyValuePair contains a key and a set of values to remove from that key.</param>
            <returns>True if at least one values was found and removed.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.RemoveMany(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Removes a collection of values from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
            <param name="key">A key to remove values from.</param>
            <param name="values">A collection of values to remove.</param>
            <returns>The number of values that were present and removed. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all of the keys (and any associated values) in a collection
            of keys. If a key is not present in the dictionary, nothing happens.
            </summary>
            <param name="keyCollection">A collection of key values to remove.</param>
            <returns>The number of keys from the collection that were present and removed.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.System#Collections#Generic#IDictionary{TKey@System#Collections#Generic#ICollection{TValue}}#TryGetValue(`0,System.Collections.Generic.ICollection{`1}@)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. If so, all the values
            associated with that key are returned through the values parameter. This method must be
            overridden by the derived class.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="values">Returns all values associated with key, if true was returned.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.ContainsKey(`0)">
            <summary>
            Determines whether a given key is found in the dictionary.
            </summary>
            <remarks>The default implementation simply calls TryEnumerateValuesForKey.
            It may be appropriate to override this method to 
            provide a more efficient implementation.</remarks>
            <param name="key">Key to look for in the dictionary.</param>
            <returns>True if the key is present in the dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.Contains(`0,`1)">
            <summary>
            Determines if this dictionary contains a key-value pair equal to <paramref name="key"/> and 
            <paramref name="value"/>. The dictionary is not changed. This method must be overridden in the derived class.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="value">The value to search for.</param>
            <returns>True if the dictionary has associated <paramref name="value"/> with <paramref name="key"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
            <summary>
            Determines if this dictionary contains the given key and all of the values associated with that key..
            </summary>
            <param name="pair">A key and collection of values to search for.</param>
            <returns>True if the dictionary has associated all of the values in <paramref name="pair"/>.Value with <paramref name="pair"/>.Key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.EqualValues(`1,`1)">
            <summary>
            If the derived class does not use the default comparison for values, this
            methods should be overridden to compare two values for equality. This is
            used for the correct implementation of ICollection.Contains on the Values
            and KeyValuePairs collections.
            </summary>
            <param name="value1">First value to compare.</param>
            <param name="value2">Second value to compare.</param>
            <returns>True if the values are equal.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.CountValues(`0)">
            <summary>
            Gets a count of the number of values associated with a key. The
            default implementation is slow; it enumerators all of the values
            (using TryEnumerateValuesForKey) to count them. A derived class
            may be able to supply a more efficient implementation.
            </summary>
            <param name="key">The key to count values for.</param>
            <returns>The number of values associated with <paramref name="key"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.CountAllValues">
            <summary>
            Gets a total count of values in the collection. This default implementation
            is slow; it enumerates all of the keys in the dictionary and calls CountValues on each.
            A derived class may be able to supply a more efficient implementation.
            </summary>
            <returns>The total number of values associated with all keys in the dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.Replace(`0,`1)">
            <summary>
            Replaces all values associated with <paramref name="key"/> with the single value <paramref name="value"/>.
            </summary>
            <remarks>This implementation simply calls Remove, followed by Add.</remarks>
            <param name="key">The key to associate with.</param>
            <param name="value">The new values to be associated with <paramref name="key"/>.</param>
            <returns>Returns true if some values were removed. Returns false if <paramref name="key"/> was not
            present in the dictionary before Replace was called.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.ReplaceMany(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Replaces all values associated with <paramref name="key"/> with a new collection
            of values. If the collection does not permit duplicate values, and <paramref name="values"/> has duplicate
            items, then only the last of duplicates is added.
            </summary>
            <param name="key">The key to associate with.</param>
            <param name="values">The new values to be associated with <paramref name="key"/>.</param>
            <returns>Returns true if some values were removed. Returns false if <paramref name="key"/> was not
            present in the dictionary before Replace was called.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.ToString">
            <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
            <returns>The string representation of the dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.DebuggerDisplayString">
            <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
            <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.GetEnumerator">
            <summary>
            Enumerate all the keys in the dictionary, and for each key, the collection of values for that key.
            </summary>
            <returns>An enumerator to enumerate all the key, ICollection&lt;value&gt; pairs in the dictionary.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.Count">
            <summary>
            Gets the number of keys in the dictionary. This property must be overridden
            in the derived class.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.Keys">
            <summary>
            Gets a read-only collection all the keys in this dictionary.
            </summary>
            <value>An readonly ICollection&lt;TKey&gt; of all the keys in this dictionary.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.Values">
            <summary>
            Gets a read-only collection of all the values in the dictionary. 
            </summary>
            <returns>A read-only ICollection&lt;TValue&gt; of all the values in the dictionary.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.System#Collections#Generic#IDictionary{TKey@System#Collections#Generic#ICollection{TValue}}#Values">
            <summary>
            Gets a read-only collection of all the value collections in the dictionary. 
            </summary>
            <returns>A read-only ICollection&lt;IEnumerable&lt;TValue&gt;&gt; of all the values in the dictionary.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.KeyValuePairs">
            <summary>
            Gets a read-only collection of all key-value pairs in the dictionary. If a key has multiple
            values associated with it, then a key-value pair is present for each value associated
            with the key.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.Item(`0)">
            <summary>
            Returns a collection of all of the values in the dictionary associated with <paramref name="key"/>,
            or changes the set of values associated with <paramref name="key"/>.
            If the key is not present in the dictionary, an ICollection enumerating no
            values is returned. The returned collection of values is read-write, and can be used to 
            modify the collection of values associated with the key.
            </summary>
            <param name="key">The key to get the values associated with.</param>
            <value>An ICollection&lt;TValue&gt; with all the values associated with <paramref name="key"/>.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.System#Collections#Generic#IDictionary{TKey@System#Collections#Generic#ICollection{TValue}}#Item(`0)">
            <summary>
            Gets a collection of all the values in the dictionary associated with <paramref name="key"/>,
            or changes the set of values associated with <paramref name="key"/>.
            If the key is not present in the dictionary, a KeyNotFound exception is thrown.
            </summary>
            <param name="key">The key to get the values associated with.</param>
            <value>An IEnumerable&lt;TValue&gt; that enumerates all the values associated with <paramref name="key"/>.</value>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The given key is not present in the dictionary.</exception>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.ValuesForKeyCollection">
            <summary>
            A private class that provides the ICollection&lt;TValue&gt; for a particular key. This is the collection
            that is returned from the indexer. The collections is read-write, live, and can be used to add, remove,
            etc. values from the multi-dictionary.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.ValuesForKeyCollection.#ctor(CodeSmith.Engine.PowerCollections.MultiDictionaryBase{`0,`1},`0)">
            <summary>
            Constructor. Initializes this collection.
            </summary>
            <param name="myDictionary">Dictionary we're using.</param>
            <param name="key">The key we're looking at.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.ValuesForKeyCollection.Clear">
            <summary>
            Remove the key and all values associated with it.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.ValuesForKeyCollection.Add(`1)">
            <summary>
            Add a new values to this key.
            </summary>
            <param name="item">New values to add.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.ValuesForKeyCollection.Remove(`1)">
            <summary>
            Remove a value currently associated with key.
            </summary>
            <param name="item">Value to remove.</param>
            <returns>True if item was assocaited with key, false otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.ValuesForKeyCollection.NoValues">
            <summary>
            A simple function that returns an IEnumerator&lt;TValue&gt; that
            doesn't yield any values. A helper.
            </summary>
            <returns>An IEnumerator&lt;TValue&gt; that yields no values.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.ValuesForKeyCollection.GetEnumerator">
            <summary>
            Enumerate all the values associated with key.
            </summary>
            <returns>An IEnumerator&lt;TValue&gt; that enumerates all the values associated with key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.ValuesForKeyCollection.Contains(`1)">
            <summary>
            Determines if the given values is associated with key.
            </summary>
            <param name="item">Value to check for.</param>
            <returns>True if value is associated with key, false otherwise.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.ValuesForKeyCollection.Count">
            <summary>
            Get the number of values associated with the key.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.KeysCollection">
            <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Keys collection. The collection is read-only.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.KeysCollection.#ctor(CodeSmith.Engine.PowerCollections.MultiDictionaryBase{`0,`1})">
            <summary>
            Constructor.
            </summary>
            <param name="myDictionary">The dictionary this is associated with.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.ValuesCollection">
            <summary>
            A private class that implements ICollection&lt;TValue&gt; and ICollection for the
            Values collection. The collection is read-only.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.EnumerableValuesCollection">
            <summary>
            A private class that implements ICollection&lt;ICollection&lt;TValue&gt;&gt; and ICollection for the
            Values collection on IDictionary. The collection is read-only.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.MultiDictionaryBase`2.KeyValuePairsCollection">
            <summary>
            A private class that implements ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; and ICollection for the
            KeyValuePairs collection. The collection is read-only.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.#ctor(System.Boolean)">
            <summary>
            Create a new MultiDictionary. The default ordering of keys and values are used. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
            <remarks>The default ordering of keys and values will be used, as defined by TKey and TValue's implementation
            of IComparable&lt;T&gt; (or IComparable if IComparable&lt;T&gt; is not implemented). If a different ordering should be
            used, other constructors allow a custom Comparer or IComparer to be passed to changed the ordering.</remarks>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <exception cref="T:System.InvalidOperationException">TKey or TValue does not implement either IComparable&lt;T&gt; or IComparable.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a new MultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <param name="keyEqualityComparer">An IEqualityComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
            <exception cref="T:System.InvalidOperationException">TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Create a new MultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <param name="keyEqualityComparer">An IEqualityComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
            <param name="valueEqualityComparer">An IEqualityComparer&lt;TValue&gt; instance that will be used to compare values.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1},System.Collections.Generic.IEqualityComparer{CodeSmith.Engine.PowerCollections.MultiDictionary{`0,`1}.KeyAndValues},CodeSmith.Engine.PowerCollections.Hash{CodeSmith.Engine.PowerCollections.MultiDictionary{`0,`1}.KeyAndValues})">
            <summary>
            Create a new MultiDictionary. Private constructor, for use by Clone().
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.Add(`0,`1)">
            <summary>
            <para>Adds a new value to be associated with a key. If duplicate values are permitted, this
            method always adds a new key-value pair to the dictionary.</para>
            <para>If duplicate values are not permitted, and <paramref name="key"/> already has a value
            equal to <paramref name="value"/> associated with it, then that value is replaced with <paramref name="value"/>,
            and the number of values associate with <paramref name="key"/> is unchanged.</para>
            </summary>
            <param name="key">The key to associate with.</param>
            <param name="value">The value to associated with <paramref name="key"/>.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.Remove(`0,`1)">
            <summary>
            Removes a given value from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
            <param name="key">A key to remove a value from.</param>
            <param name="value">The value to remove.</param>
            <returns>True if <paramref name="value"/> was associated with <paramref name="key"/> (and was
            therefore removed). False if <paramref name="value"/> was not associated with <paramref name="key"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.Remove(`0)">
            <summary>
            Removes a key and all associated values from the dictionary. If the
            key is not present in the dictionary, it is unchanged and false is returned.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>True if the key was present and was removed. Returns 
            false if the key was not present.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.Clear">
            <summary>
            Removes all keys and values from the dictionary.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.EqualValues(`1,`1)">
            <summary>
            Determine if two values are equal.
            </summary>
            <param name="value1">First value to compare.</param>
            <param name="value2">Second value to compare.</param>
            <returns>True if the values are equal.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.Contains(`0,`1)">
            <summary>
            Checks to see if <paramref name="value"/> is associated with <paramref name="key"/>
            in the dictionary.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value to check.</param>
            <returns>True if <paramref name="value"/> is associated with <paramref name="key"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.ContainsKey(`0)">
            <summary>
            Checks to see if the key is present in the dictionary and has
            at least one value associated with it.
            </summary>
            <param name="key">The key to check.</param>
            <returns>True if <paramref name="key"/> is present and has at least
            one value associated with it. Returns false otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.EnumerateKeys">
            <summary>
            Enumerate all the keys in the dictionary. 
            </summary>
            <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the dictionary that
            have at least one value associated with them.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.EnumerateValues(CodeSmith.Engine.PowerCollections.MultiDictionary{`0,`1}.KeyAndValues)">
            <summary>
             Enumerate the values in the a KeyAndValues structure. Can't return
            the array directly because:
              a) The array might be larger than the count.
              b) We can't allow clients to down-cast to the array and modify it.
              c) We have to abort enumeration if the hash changes.
            </summary>
            <param name="keyAndValues">Item with the values to enumerate..</param>
            <returns>An enumerable that enumerates the items in the KeyAndValues structure.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. If so, all the values
            associated with that key are returned through the values parameter. 
            </summary>
            <param name="key">The key to search for.</param>
            <param name="values">Returns all values associated with key, if true was returned.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.CountValues(`0)">
            <summary>
            Gets the number of values associated with a given key.
            </summary>
            <param name="key">The key to count values of.</param>
            <returns>The number of values associated with <paramref name="key"/>. If <paramref name="key"/>
            is not present in the dictionary, zero is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.Clone">
            <summary>
            Makes a shallow clone of this dictionary; i.e., if keys or values of the
            dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
            then each element is copied as if by simple assignment.
            </summary>
            <remarks>Cloning the dictionary takes time O(N), where N is the number of key-value pairs in the dictionary.</remarks>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.System#ICloneable#Clone">
            <summary>
            Implements ICloneable.Clone. Makes a shallow clone of this dictionary; i.e., if keys or values are reference types, then they are not cloned.
            </summary>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.NonCloneableType(System.Type)">
            <summary>
            Throw an InvalidOperationException indicating that this type is not cloneable.
            </summary>
            <param name="t">Type to test.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.CloneContents">
            <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
            a value type, then each element is copied as if by simple assignment.
            </summary>
            <remarks><para>If TKey or TValue is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
            <para>Cloning the dictionary takes time O(N log N), where N is the number of key-value pairs in the dictionary.</para></remarks>
            <returns>The cloned dictionary.</returns>
            <exception cref="T:System.InvalidOperationException">TKey or TValue is a reference type that does not implement ICloneable.</exception>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.MultiDictionary`2.KeyComparer">
            <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare keys in this dictionary. 
            </summary>
            <value>If the dictionary was created using a comparer, that comparer is returned. Otherwise
            the default comparer for TKey (EqualityComparer&lt;TKey&gt;.Default) is returned.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.MultiDictionary`2.ValueComparer">
            <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare values in this dictionary. 
            </summary>
            <value>If the dictionary was created using a comparer, that comparer is returned. Otherwise
            the default comparer for TValue (EqualityComparer&lt;TValue&gt;.Default) is returned.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.MultiDictionary`2.Count">
            <summary>
            Gets the number of key-value pairs in the dictionary. Each value associated
            with a given key is counted. If duplicate values are permitted, each duplicate
            value is included in the count.
            </summary>
            <value>The number of key-value pairs in the dictionary.</value>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.MultiDictionary`2.KeyAndValues">
            <summary>
            A structure to hold the key and the values associated with the key.
            The number of values must always be 1 or greater in a version that is stored, but 
            can be zero in a dummy version used only for lookups.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.PowerCollections.MultiDictionary`2.KeyAndValues.Key">
            <summary>
            The key.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.PowerCollections.MultiDictionary`2.KeyAndValues.Count">
            <summary>
            The number of values. Always at least 1 except in a dummy version for lookups.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.PowerCollections.MultiDictionary`2.KeyAndValues.Values">
            <summary>
            An array of values. 
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.KeyAndValues.#ctor(`0)">
            <summary>
            Create a dummy KeyAndValues with just the key, for lookups.
            </summary>
            <param name="key">The key to use.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.MultiDictionary`2.KeyAndValues.Copy(CodeSmith.Engine.PowerCollections.MultiDictionary{`0,`1}.KeyAndValues)">
            <summary>
            Make a copy of a KeyAndValues, copying the array.
            </summary>
            <param name="x">KeyAndValues to copy.</param>
            <returns>A copied version.</returns>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.MultiDictionary`2.KeyAndValuesEqualityComparer">
            <summary>
            This class implements IEqualityComparer for KeysAndValues, allowing them to be
            compared by their keys. An IEqualityComparer on keys is required.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.OrderedBag`1">
             <summary>
             OrderedBag&lt;T&gt; is a collection that contains items of type T. 
             The item are maintained in a sorted order. Unlike a OrderedSet, duplicate items (items that
             compare equal to each other) are allows in an OrderedBag.
             </summary>
             <remarks>
             <p>The items are compared in one of three ways. If T implements IComparable&lt;TKey&gt; or IComparable,
             then the CompareTo method of that interface will be used to compare items. Alternatively, a comparison
             function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
             <p>OrderedBag is implemented as a balanced binary tree. Inserting, deleting, and looking up an
             an element all are done in log(N) + M time, where N is the number of keys in the tree, and M is the current number
             of copies of the element being handled.</p>
             <p><see cref="T:CodeSmith.Engine.PowerCollections.Bag`1"/> is similar, but uses hashing instead of comparison, and does not maintain
             the keys in sorted order.</p>
            </remarks>
            <seealso cref="T:CodeSmith.Engine.PowerCollections.Bag`1"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.#ctor">
             <summary>
             Creates a new OrderedBag. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this bag.
             </summary>
            <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
             <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.#ctor(System.Comparison{`0})">
            <summary>
            Creates a new OrderedBag. The passed delegate will be used to compare items in this bag.
            </summary>
            <param name="comparison">A delegate to a method that will be used to compare items.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new OrderedBag. The Compare method of the passed comparison object
            will be used to compare items in this bag.
            </summary>
            <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
            <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Creates a new OrderedBag. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this bag. The bag is
             initialized with all the items in the given collection.
             </summary>
            <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
             <param name="collection">A collection with items to be placed into the OrderedBag.</param>
             <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Comparison{`0})">
            <summary>
            Creates a new OrderedBag. The passed delegate will be used to compare items in this bag.
            The bag is initialized with all the items in the given collection.
            </summary>
            <param name="collection">A collection with items to be placed into the OrderedBag.</param>
            <param name="comparison">A delegate to a method that will be used to compare items.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new OrderedBag. The Compare method of the passed comparison object
            will be used to compare items in this bag. The bag is
            initialized with all the items in the given collection.
            </summary>
            <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
            <param name="collection">A collection with items to be placed into the OrderedBag.</param>
            <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.#ctor(System.Collections.Generic.IComparer{`0},CodeSmith.Engine.PowerCollections.RedBlackTree{`0})">
            <summary>
            Creates a new OrderedBag given a comparer and a tree that contains the data. Used
            internally for Clone.
            </summary>
            <param name="comparer">Comparer for the bag.</param>
            <param name="tree">Data for the bag.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.System#ICloneable#Clone">
            <summary>
            Makes a shallow clone of this bag; i.e., if items of the
            bag are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
            <remarks>Cloning the bag takes time O(N), where N is the number of items in the bag.</remarks>
            <returns>The cloned bag.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.Clone">
            <summary>
            Makes a shallow clone of this bag; i.e., if items of the
            bag are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
            <remarks>Cloning the bag takes time O(N), where N is the number of items in the bag.</remarks>
            <returns>The cloned bag.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.CloneContents">
            <summary>
            Makes a deep clone of this bag. A new bag is created with a clone of
            each element of this bag, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
            <remarks><para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
            <para>Cloning the bag takes time O(N log N), where N is the number of items in the bag.</para></remarks>
            <returns>The cloned bag.</returns>
            <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.NumberOfCopies(`0)">
            <summary>
            Returns the number of copies of <paramref name="item"/> in the bag. More precisely, returns
            the number of items in the bag that compare equal to <paramref name="item"/>.
            </summary>
            <remarks>NumberOfCopies() takes time O(log N + M), where N is the total number of items in the
            bag, and M is the number of copies of <paramref name="item"/> in the bag.</remarks>
            <param name="item">The item to search for in the bag.</param>
            <returns>The number of items in the bag that compare equal to <paramref name="item"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.GetEnumerator">
            <summary>
            Returns an enumerator that enumerates all the items in the bag. 
            The items are enumerated in sorted order.
            </summary>
            <remarks>
            <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
            <p>If an item is added to or deleted from the bag while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
            <p>Enumeration all the items in the bag takes time O(N), where N is the number
            of items in the bag.</p>
            </remarks>
            <returns>An enumerator for enumerating all the items in the OrderedBag.</returns>		
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.Contains(`0)">
            <summary>
            Determines if this bag contains an item equal to <paramref name="item"/>. The bag
            is not changed.
            </summary>
            <remarks>Searching the bag for an item takes time O(log N), where N is the number of items in the bag.</remarks>
            <param name="item">The item to search for.</param>
            <returns>True if the bag contains <paramref name="item"/>. False if the bag does not contain <paramref name="item"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.GetEqualItems(`0)">
            <summary>
            <para>Enumerates all of the items in this bag that are equal to <paramref name="item"/>, according to the 
            comparison mechanism that was used when the bag was created. The bag
            is not changed.</para>
            <para>If the bag does contain an item equal to <paramref name="item"/>, then the enumeration contains
            no items.</para>
            </summary>
            <remarks>Enumeration the items in the bag equal to <paramref name="item"/> takes time O(log N + M), where N 
            is the total number of items in the bag, and M is the number of items equal to <paramref name="item"/>.</remarks>
            <param name="item">The item to search for.</param>
            <returns>An IEnumerable&lt;T&gt; that enumerates all the items in the bag equal to <paramref name="item"/>. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.DistinctItems">
            <summary>
            Enumerates all the items in the bag, but enumerates equal items
            just once, even if they occur multiple times in the bag.
            </summary>
            <remarks>If the bag is changed while items are being enumerated, the
            enumeration will terminate with an InvalidOperationException.</remarks>
            <returns>An IEnumerable&lt;T&gt; that enumerates the unique items.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.LastIndexOf(`0)">
            <summary>
            Get the index of the given item in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. If multiple
            equal items exist, the largest index of the equal items is returned.
            </summary>
            <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
            <param name="item">The item to get the index of.</param>
            <returns>The index of the last item in the sorted bag equal to <paramref name="item"/>, or -1 if the item is not present
            in the set.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.IndexOf(`0)">
            <summary>
            Get the index of the given item in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. If multiple
            equal items exist, the smallest index of the equal items is returned.
            </summary>
            <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
            <param name="item">The item to get the index of.</param>
            <returns>The index of the first item in the sorted bag equal to <paramref name="item"/>, or -1 if the item is not present
            in the set.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.Add(`0)">
            <summary>
            Adds a new item to the bag. Since bags can contain duplicate items, the item 
            is added even if the bag already contains an item equal to <paramref name="item"/>. In
            this case, the new item is placed after all equal items already present in the bag.
            </summary>
            <remarks>
            <para>Adding an item takes time O(log N), where N is the number of items in the bag.</para></remarks>
            <param name="item">The item to add to the bag.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds all the items in <paramref name="collection"/> to the bag. 
            </summary>
            <remarks>
            <para>Adding the collection takes time O(M log N), where N is the number of items in the bag, and M is the 
            number of items in <paramref name="collection"/>.</para></remarks>
            <param name="collection">A collection of items to add to the bag.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.Remove(`0)">
            <summary>
            Searches the bag for one item equal to <paramref name="item"/>, and if found,
            removes it from the bag. If not found, the bag is unchanged. If more than one item
            equal to <paramref name="item"/>, the item that was last inserted is removed.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
            <para>Removing an item from the bag takes time O(log N), where N is the number of items in the bag.</para></remarks>
            <param name="item">The item to remove.</param>
            <returns>True if <paramref name="item"/> was found and removed. False if <paramref name="item"/> was not in the bag.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.RemoveAllCopies(`0)">
            <summary>
            Searches the bag for all items equal to <paramref name="item"/>, and 
            removes all of them from the bag. If not found, the bag is unchanged.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
            <para>RemoveAllCopies() takes time O(M log N), where N is the total number of items in the bag, and M is
            the number of items equal to <paramref name="item"/>.</para></remarks>
            <param name="item">The item to remove.</param>
            <returns>The number of copies of <paramref name="item"/> that were found and removed. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes all the items in <paramref name="collection"/> from the bag. Items not
            present in the bag are ignored.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
            <para>Removing the collection takes time O(M log N), where N is the number of items in the bag, and M is the 
            number of items in <paramref name="collection"/>.</para></remarks>
            <param name="collection">A collection of items to remove from the bag.</param>
            <returns>The number of items removed from the bag.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.Clear">
            <summary>
            Removes all items from the bag.
            </summary>
            <remarks>Clearing the bag takes a constant amount of time, regardless of the number of items in it.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.CheckEmpty">
            <summary>
            If the collection is empty, throw an invalid operation exception.
            </summary>
            <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.GetFirst">
            <summary>
            Returns the first item in the bag: the item
            that would appear first if the bag was enumerated. This is also
            the smallest item in the bag.
            </summary>
            <remarks>GetFirst() takes time O(log N), where N is the number of items in the bag.</remarks>
            <returns>The first item in the bag. If more than one item
            is smallest, the first one added is returned.</returns>
            <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.GetLast">
            <summary>
            Returns the last item in the bag: the item
            that would appear last if the bag was enumerated. This is also the largest
            item in the bag.
            </summary>
            <remarks>GetLast() takes time O(log N), where N is the number of items in the bag.</remarks>
            <returns>The last item in the bag. If more than one item
            is largest, the last one added is returned.</returns>
            <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.RemoveFirst">
            <summary>
            Removes the first item in the bag. This is also the smallest
            item in the bag.
            </summary>
            <remarks>RemoveFirst() takes time O(log N), where N is the number of items in the bag.</remarks>
            <returns>The item that was removed, which was the smallest item in the bag. </returns>
            <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.RemoveLast">
            <summary>
            Removes the last item in the bag. This is also the largest item in the bag.
            </summary>
            <remarks>RemoveLast() takes time O(log N), where N is the number of items in the bag.</remarks>
            <returns>The item that was removed, which was the largest item in the bag. </returns>
            <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.CheckConsistentComparison(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Check that this bag and another bag were created with the same comparison
            mechanism. Throws exception if not compatible.
            </summary>
            <param name="otherBag">Other bag to check comparision mechanism.</param>
            <exception cref="T:System.InvalidOperationException">If otherBag and this bag don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.IsSupersetOf(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Determines if this bag is a superset of another bag. Neither bag is modified.
            This bag is a superset of <paramref name="otherBag"/> if every element in
            <paramref name="otherBag"/> is also in this bag, at least the same number of
            times.
            </summary>
            <remarks>IsSupersetOf is computed in time O(M log N), where M is the size of the 
            <paramref name="otherBag"/>, and N is the size of the this set.</remarks>
            <param name="otherBag">OrderedBag to compare to.</param>
            <returns>True if this is a superset of <paramref name="otherBag"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.IsProperSupersetOf(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Determines if this bag is a proper superset of another bag. Neither bag is modified.
            This bag is a proper superset of <paramref name="otherBag"/> if every element in
            <paramref name="otherBag"/> is also in this bag, at least the same number of
            times. Additional, this bag must have strictly more items than <paramref name="otherBag"/>.
            </summary>
            <remarks>IsProperSupersetOf is computed in time O(M log N), where M is the number of unique items in 
            <paramref name="otherBag"/>.</remarks>
            <param name="otherBag">OrderedBag to compare to.</param>
            <returns>True if this is a proper superset of <paramref name="otherBag"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.IsSubsetOf(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Determines if this bag is a subset of another bag. Neither bag is modified.
            This bag is a subset of <paramref name="otherBag"/> if every element in this bag
            is also in <paramref name="otherBag"/>, at least the same number of
            times.
            </summary>
            <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref name="otherBag"/>, and N is the size of the this bag.</remarks>
            <param name="otherBag">OrderedBag to compare to.</param>
            <returns>True if this is a subset of <paramref name="otherBag"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.IsProperSubsetOf(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Determines if this bag is a proper subset of another bag. Neither bag is modified.
            This bag is a subset of <paramref name="otherBag"/> if every element in this bag
            is also in <paramref name="otherBag"/>, at least the same number of
            times. Additional, this bag must have strictly fewer items than <paramref name="otherBag"/>.
            </summary>
            <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref nameb="otherBag"/>, and N is the size of the this bag.</remarks>
            <param name="otherBag">OrderedBag to compare to.</param>
            <returns>True if this is a proper subset of <paramref name="otherBag"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.IsDisjointFrom(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Determines if this bag is disjoint from another bag. Two bags are disjoint
            if no item from one set is equal to any item in the other bag.
            </summary>
            <remarks>
            <para>The answer is computed in time O(N), where N is the size of the smaller set.</para>
            </remarks>
            <param name="otherBag">Bag to check disjointness with.</param>
            <returns>True if the two bags are disjoint, false otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.IsEqualTo(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Determines if this bag is equal to another bag. This bag is equal to
            <paramref name="otherBag"/> if they contain the same items, each the
            same number of times.
            </summary>
            <remarks>IsEqualTo is computed in time O(N), where N is the number of items in 
            this bag.</remarks>
            <param name="otherBag">OrderedBag to compare to</param>
            <returns>True if this bag is equal to <paramref name="otherBag"/>, false otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.UnionWith(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. This bag receives
            the union of the two bags, the other bag is unchanged.
            </summary>
            <remarks>
            <para>The union of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to union with.</param>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.Union(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. A new bag is 
            created with the union of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
            <remarks>
            <para>The union of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to union with.</param>
            <returns>The union of the two bags.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.SumWith(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Computes the sum of this bag with another bag. The sum of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. This bag receives
            the sum of the two bags, the other bag is unchanged.
            </summary>
            <remarks>
            <para>The sum of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to sum with.</param>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.Sum(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Computes the sum of this bag with another bag. he sum of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. A new bag is 
            created with the sum of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
            <remarks>
            <para>The sum of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to sum with.</param>
            <returns>The sum of the two bags.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.IntersectionWith(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item Minimum(X,Y) times. This bag receives
            the intersection of the two bags, the other bag is unchanged.
            </summary>
            <remarks>
            <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The intersection of two bags is computed in time O(N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to intersection with.</param>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.Intersection(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item Minimum(X,Y) times. A new bag is 
            created with the intersection of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
            <remarks>
            <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The intersection of two bags is computed in time O(N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to intersection with.</param>
            <returns>The intersection of the two bags.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.DifferenceWith(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag"/>. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X). This bag receives
            the difference of the two bags; the other bag is unchanged.
            </summary>
            <remarks>
            <para>The difference of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to difference with.</param>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.Difference(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag"/>. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X).  A new bag is 
            created with the difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
            <remarks>
            <para>The difference of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to difference with.</param>
            <returns>The difference of the two bags.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.SymmetricDifferenceWith(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y times). This bag receives
            the symmetric difference of the two bags; the other bag is unchanged.
            </summary>
            <remarks>
            <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to symmetric difference with.</param>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.SymmetricDifference(CodeSmith.Engine.PowerCollections.OrderedBag{`0})">
            <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y times). A new bag is 
            created with the symmetric difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
            <remarks>
            <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
            </remarks>
            <param name="otherBag">Bag to symmetric difference with.</param>
            <returns>The symmetric difference of the two bags.</returns>
            <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag"/> don't use the same method for comparing items.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherBag"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.AsList">
            <summary>
            Get a read-only list view of the items in this ordered bag. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedBag.
            </summary>
            <returns>A read-only IList&lt;T&gt; view onto this OrderedBag.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.Reversed">
             <summary>
             Returns a View collection that can be used for enumerating the items in the bag in 
             reversed order.
             </summary>
            <remarks>
            <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.Reversed()) {
                // process item
             }
            </code></p>
             <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
            <p>Calling Reverse does not copy the data in the tree, and the operation takes constant time.</p>
            </remarks>
             <returns>An OrderedBag.View of items in reverse order.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.Range(`0,System.Boolean,`0,System.Boolean)">
             <summary>
             Returns a View collection that can be used for enumerating a range of the items in the bag.
             Only items that are greater than <paramref name="from"/> and 
             less than <paramref name="to"/> are included. The items are enumerated in sorted order.
             Items equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive"/> and <paramref name="toInclusive"/> parameters.
             </summary>
            <remarks>
            <p>If <paramref name="from"/> is greater than or equal to <paramref name="to"/>, the returned collection is empty. </p>
            <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.Range(from, true, to, false)) {
                // process item
             }
            </code></p>
             <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
            <p>Calling Range does not copy the data in the tree, and the operation takes constant time.</p>
            </remarks>
             <param name="from">The lower bound of the range.</param>
             <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
             <param name="to">The upper bound of the range. </param>
             <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
             <returns>An OrderedBag.View of items in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.RangeFrom(`0,System.Boolean)">
             <summary>
             Returns a View collection that can be used for enumerating a range of the items in the bag.
             Only items that are greater than (and optionally, equal to) <paramref name="from"/> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="from"/> can be included
             or excluded depending on the <paramref name="fromInclusive"/> parameter.
             </summary>
            <remarks>
            <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.RangeFrom(from, true)) {
                // process item
             }
            </code></p>
             <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
            <p>Calling RangeFrom does not copy the data in the tree, and the operation takes constant time.</p>
            </remarks>
             <param name="from">The lower bound of the range.</param>
             <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
             <returns>An OrderedBag.View of items in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.RangeTo(`0,System.Boolean)">
             <summary>
             Returns a View collection that can be used for enumerating a range of the items in the bag.
             Only items that are less than (and optionally, equal to) <paramref name="to"/> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to"/> can be included
             or excluded depending on the <paramref name="toInclusive"/> parameter.
             </summary>
            <remarks>
            <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.RangeTo(to, false)) {
                // process item
             }
            </code></p>
             <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
            <p>Calling RangeTo does not copy the data in the tree, and the operation takes constant time.</p>
            </remarks>
             <param name="to">The upper bound of the range. </param>
             <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
             <returns>An OrderedBag.View of items in the given range.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedBag`1.Comparer">
            <summary>
            Returns the IComparer&lt;T&gt; used to compare items in this bag. 
            </summary>
            <value>If the bag was created using a comparer, that comparer is returned. If the bag was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for T (Comparer&lt;T&gt;.Default) is returned.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedBag`1.Count">
            <summary>
            Returns the number of items in the bag.
            </summary>
            <remarks>The size of the bag is returned in constant time.</remarks>
            <value>The number of items in the bag.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedBag`1.Item(System.Int32)">
            <summary>
            Get the item by its index in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
            <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
            <param name="index">The index to get the item by.</param>
            <returns>The item at the given index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.OrderedBag`1.ListView">
            <summary>
            The nested class that provides a read-only list view
            of all or part of the collection.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1">
            <summary>
            ReadOnlyListBase is an abstract class that can be used as a base class for a read-only collection that needs 
            to implement the generic IList&lt;T&gt; and non-generic IList collections. The derived class needs
            to override the Count property and the get part of the indexer. The implementation
            of all the other methods in IList&lt;T&gt; and IList are handled by ListBase.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.#ctor">
            <summary>
            Creates a new ReadOnlyListBase.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.MethodModifiesCollection">
            <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.GetEnumerator">
            <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on.
            </summary>
            <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.Contains(`0)">
            <summary>
            Determines if the list contains any item that compares equal to <paramref name="item"/>.
            The implementation simply checks whether IndexOf(item) returns a non-negative value.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="item">The item to search for.</param>
            <returns>True if the list contains an item that compares equal to <paramref name="item"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.CopyTo(`0[])">
            <summary>
            Copies all the items in the list, in order, to <paramref name="array"/>,
            starting at index 0.
            </summary>
            <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies all the items in the list, in order, to <paramref name="array"/>,
            starting at <paramref name="arrayIndex"/>.
            </summary>
            <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count + arrayIndex.</param>
            <param name="arrayIndex">The starting index in <paramref name="array"/>
            to copy to.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from the list to <paramref name="array"/>,
            starting at <paramref name="arrayIndex"/>.
            </summary>
            <param name="index">The starting index in the source list of the range to copy.</param>
            <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count + arrayIndex.</param>
            <param name="arrayIndex">The starting index in <paramref name="array"/>
            to copy to.</param>
            <param name="count">The number of items to copy.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.Find(System.Predicate{`0})">
            <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
            <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate"/>,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.TryFind(System.Predicate{`0},`0@)"/>.</remarks>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <returns>The first item that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, the default value for T is returned.</returns>
            <seealso cref="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.TryFind(System.Predicate{`0},`0@)"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.TryFind(System.Predicate{`0},`0@)">
            <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate"/>. 
            </summary>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <param name="foundItem">If true is returned, this parameter receives the first item in the list
            that satifies the condition defined by <paramref name="predicate"/>.</param>
            <returns>True if an item that  satisfies the condition <paramref name="predicate"/> was found. False 
            if no item in the list satisfies that condition.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.FindLast(System.Predicate{`0})">
            <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
            <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate"/>,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.TryFindLast(System.Predicate{`0},`0@)"/>.</remarks>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <returns>The last item that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, the default value for T is returned.</returns>
            <seealso cref="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.TryFindLast(System.Predicate{`0},`0@)"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.TryFindLast(System.Predicate{`0},`0@)">
            <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate"/>. 
            </summary>
            <param name="predicate">A delegate that defines the condition to check for.</param>
            <param name="foundItem">If true is returned, this parameter receives the last item in the list
            that satifies the condition defined by <paramref name="predicate"/>.</param>
            <returns>True if an item that  satisfies the condition <paramref name="predicate"/> was found. False 
            if no item in the list satisfies that condition.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.FindIndex(System.Predicate{`0})">
            <summary>
            Finds the index of the first item in the list that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, -1 is returned.
            </summary>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <returns>The index of the first item that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.FindIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index"/> to the end, that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, -1 is returned.
            </summary>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <param name="index">The starting index of the range to check.</param>
            <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Finds the index of the first item, in the range of <paramref name="count"/> items starting from <paramref name="index"/>, that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, -1 is returned.
            </summary>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <param name="index">The starting index of the range to check.</param>
            <param name="count">The number of items in range to check.</param>
            <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.FindLastIndex(System.Predicate{`0})">
            <summary>
            Finds the index of the last item in the list that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, -1 is returned.
            </summary>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <returns>The index of the last item that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.FindLastIndex(System.Int32,System.Predicate{`0})">
            <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index"/>, that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, -1 is returned.
            </summary>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <param name="index">The ending index of the range to check.</param>
            <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>
            Finds the index of the last item, in the range of <paramref name="count"/> items ending at <paramref name="index"/>, that satisfies the condition
            defined by <paramref name="predicate"/>. If no item matches the condition, -1 is returned.
            </summary>
            <param name="predicate">A delegate that defined the condition to check for.</param>
            <param name="index">The ending index of the range to check.</param>
            <param name="count">The number of items in range to check.</param>
            <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate"/>. If no item satisfies that
            condition, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.IndexOf(`0)">
            <summary>
            Finds the index of the first item in the list that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <returns>The index of the first item in the list that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.IndexOf(`0,System.Int32)">
            <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index"/> to the end,  
            that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <param name="index">The starting index of the range to check.</param>
            <returns>The index of the first item in the given range that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Finds the index of the first item, in the range of <paramref name="count"/> items starting from <paramref name="index"/>,  
            that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <param name="index">The starting index of the range to check.</param>
            <param name="count">The number of items in range to check.</param>
            <returns>The index of the first item in the given range that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.LastIndexOf(`0)">
            <summary>
            Finds the index of the last item in the list that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <returns>The index of the last item in the list that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.LastIndexOf(`0,System.Int32)">
            <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index"/>, that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search fror.</param>
            <param name="index">The ending index of the range to check.</param>
            <returns>The index of the last item in the given range that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Finds the index of the last item, in the range of <paramref name="count"/> items ending at <paramref name="index"/>, 
            that is equal to <paramref name="item"/>. 
            </summary>
            <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
            <param name="item">The item to search for.</param>
            <param name="index">The ending index of the range to check.</param>
            <param name="count">The number of items in range to check.</param>
            <returns>The index of the last item in the given range that that is equal to <paramref name="item"/>.  If no item is equal
            to <paramref name="item"/>, -1 is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.Range(System.Int32,System.Int32)">
            <summary>
            Returns a view onto a sub-range of this list. Items are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. 
            </summary>
            <remarks>
            <para>This method can be used to apply an algorithm to a portion of a list. For example:</para>
            <code>Algorithms.Reverse(deque.Range(3, 6))</code>
            will return the reverse opf the 6 items beginning at index 3.</remarks>
            <param name="start">The starting index of the view.</param>
            <param name="count">The number of items in the view.</param>
            <returns>A list that is a view onto the given sub-part of this list. </returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> or <paramref name="count"/> is negative.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start"/> + <paramref name="count"/> is greater than the
            size of the list.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <summary>
            Inserts a new item at the given index. This implementation throws a NotSupportedException
            indicating that the list is read-only.
            </summary>
            <param name="index">The index in the list to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item in the list has index 0.</param>
            <param name="item">The item to insert at the given index.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.System#Collections#Generic#IList{T}#RemoveAt(System.Int32)">
            <summary>
            Removes the item at the given index.  This implementation throws a NotSupportedException
            indicating that the list is read-only.
            </summary>
            <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.System#Collections#IList#Add(System.Object)">
            <summary>
            Adds an item to the end of the list. This implementation throws a NotSupportedException
            indicating that the list is read-only.
            </summary>
            <param name="value">The item to add to the list.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.System#Collections#IList#Clear">
            <summary>
            Removes all the items from the list, resulting in an empty list. This implementation throws a NotSupportedException
            indicating that the list is read-only.
            </summary>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.System#Collections#IList#Contains(System.Object)">
            <summary>
            Determines if the list contains any item that compares equal to <paramref name="value"/>.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="value">The item to search for.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            Find the first occurrence of an item equal to <paramref name="value"/>
            in the list, and returns the index of that item.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="value">The item to search for.</param>
            <returns>The index of <paramref name="value"/>, or -1 if no item in the 
            list compares equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Insert a new item at the given index. This implementation throws a NotSupportedException
            indicating that the list is read-only.
            </summary>
            <param name="index">The index in the list to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item in the list has index 0.</param>
            <param name="value">The item to insert at the given index.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            Searches the list for the first item that compares equal to <paramref name="value"/>.
            If one is found, it is removed. Otherwise, the list is unchanged.  This implementation throws a NotSupportedException
            indicating that the list is read-only.
            </summary>
            <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
            <param name="value">The item to remove from the list.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>
            Removes the item at the given index. This implementation throws a NotSupportedException
            indicating that the list is read-only.
            </summary>
            <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.Count">
            <summary>
            The property must be overridden by the derived class to return the number of 
            items in the list.
            </summary>
            <value>The number of items in the list.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.Item(System.Int32)">
            <summary>
            The get part of the indexer must be overridden by the derived class to get 
            values of the list at a particular index.
            </summary>
            <param name="index">The index in the list to get or set an item at. The
            first item in the list has index 0, and the last has index Count-1.</param>
            <returns>The item at the given index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.System#Collections#IList#IsFixedSize">
            <summary>
            Returns whether the list is a fixed size. This implementation always returns true.
            </summary>
            <value>Alway true, indicating that the list is fixed size.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.System#Collections#IList#IsReadOnly">
            <summary>
            Returns whether the list is read only. This implementation always returns true.
            </summary>
            <value>Alway true, indicating that the list is read-only.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyListBase`1.System#Collections#IList#Item(System.Int32)">
            <summary>
            Gets or sets the value at a particular index in the list.
            </summary>
            <param name="index">The index in the list to get or set an item at. The
            first item in the list has index 0, and the last has index Count-1.</param>
            <value>The item at the given index.</value>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="value"/> cannot be converted to T.</exception>
            <exception cref="T:System.NotSupportedException">Always thrown from the setter, indicating that the list
            is read-only.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.ListView.#ctor(CodeSmith.Engine.PowerCollections.OrderedBag{`0},CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.RangeTester,System.Boolean,System.Boolean)">
            <summary>
            Create a new list view wrapped the given set.
            </summary>
            <param name="myBag">The ordered bag to wrap.</param>
            <param name="rangeTester">Range tester that defines the range being used.</param>
            <param name="entireTree">If true, then rangeTester defines the entire tree. Used to optimize some operations.</param>
            <param name="reversed">Is the view enuemerated in reverse order?</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.OrderedBag`1.View">
             <summary>
             The OrderedBag&lt;T&gt;.View class is used to look at a subset of the items
             inside an ordered bag. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
            <remarks>
             <p>Views are dynamic. If the underlying bag changes, the view changes in sync. If a change is made
             to the view, the underlying bag changes accordingly.</p>
            <p>Typically, this class is used in conjunction with a foreach statement to enumerate the items 
             in a subset of the OrderedBag. For example:</p>
            <code>
             foreach(T item in bag.Range(from, to)) {
                // process item
             }
            </code>
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.#ctor(CodeSmith.Engine.PowerCollections.OrderedBag{`0},CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.RangeTester,System.Boolean,System.Boolean)">
            <summary>
            Initialize the view.
            </summary>
            <param name="myBag">OrderedBag being viewed</param>
            <param name="rangeTester">Range tester that defines the range being used.</param>
            <param name="entireTree">If true, then rangeTester defines the entire tree.</param>
            <param name="reversed">Is the view enuemerated in reverse order?</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.ItemInView(`0)">
            <summary>
            Determine if the given item lies within the bounds of this view.
            </summary>
            <param name="item">Item to test.</param>
            <returns>True if the item is within the bounds of this view.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.GetEnumerator">
            <summary>
            Enumerate all the items in this view.
            </summary>
            <returns>An IEnumerator&lt;T&gt; with the items in this view.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.Clear">
            <summary>
            Removes all the items within this view from the underlying bag.
            </summary>
            <example>The following removes all the items that start with "A" from an OrderedBag.
            <code>
            bag.Range("A", "B").Clear();
            </code>
            </example>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.Add(`0)">
            <summary>
            Adds a new item to the bag underlying this View. If the bag already contains an item equal to
            <paramref name="item"/>, that item is replaces with <paramref name="item"/>. If
            <paramref name="item"/> is outside the range of this view, an InvalidOperationException
            is thrown.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
            <para>Adding an item takes time O(log N), where N is the number of items in the bag.</para></remarks>
            <param name="item">The item to add.</param>
            <returns>True if the bag already contained an item equal to <paramref name="item"/> (which was replaced), false 
            otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.Remove(`0)">
            <summary>
            Searches the underlying bag for an item equal to <paramref name="item"/>, and if found,
            removes it from the bag. If not found, the bag is unchanged. If the item is outside
            the range of this view, the bag is unchanged.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
            <para>Removing an item from the bag takes time O(log N), where N is the number of items in the bag.</para></remarks>
            <param name="item">The item to remove.</param>
            <returns>True if <paramref name="item"/> was found and removed. False if <paramref name="item"/> was not in the bag, or
            was outside the range of this view.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.Contains(`0)">
            <summary>
            Determines if this view of the bag contains an item equal to <paramref name="item"/>. The bag
            is not changed. If 
            </summary>
            <remarks>Searching the bag for an item takes time O(log N), where N is the number of items in the bag.</remarks>
            <param name="item">The item to search for.</param>
            <returns>True if the bag contains <paramref name="item"/>, and <paramref name="item"/> is within
            the range of this view. False otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.IndexOf(`0)">
            <summary>
            Get the first index of the given item in the view. The smallest item in the view has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
            <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
            <param name="item">The item to get the index of.</param>
            <returns>The index of the first item in the view equal to <paramref name="item"/>, or -1 if the item is not present
            in the view.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.LastIndexOf(`0)">
            <summary>
            Get the last index of the given item in the view. The smallest item in the view has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
            <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
            <param name="item">The item to get the index of.</param>
            <returns>The index of the last item in the view equal to <paramref name="item"/>, or -1 if the item is not present
            in the view.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.AsList">
            <summary>
            Get a read-only list view of the items in this view. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedSet.
            </summary>
            <returns>A read-only IList&lt;T&gt; view onto this view.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.Reversed">
            <summary>
            Creates a new View that has the same items as this view, in the reversed order.
            </summary>
            <returns>A new View that has the reversed order of this view, with the same upper 
            and lower bounds.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.GetFirst">
            <summary>
            Returns the first item in this view: the item
            that would appear first if the view was enumerated. 
            </summary>
            <remarks>GetFirst() takes time O(log N), where N is the number of items in the bag.</remarks>
            <returns>The first item in the view. </returns>
            <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.GetLast">
            <summary>
            Returns the last item in the view: the item
            that would appear last if the view was enumerated. 
            </summary>
            <remarks>GetLast() takes time O(log N), where N is the number of items in the bag.</remarks>
            <returns>The last item in the view. </returns>
            <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.Count">
            <summary>
            Number of items in this view.
            </summary>
            <value>Number of items that lie within the bounds the view.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedBag`1.View.Item(System.Int32)">
            <summary>
            Get the item by its index in the sorted order. The smallest item in the view has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
            <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
            <param name="index">The index to get the item by.</param>
            <returns>The item at the given index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.OrderedDictionary`2">
             <summary>
             OrderedDictionary&lt;TKey, TValue&gt; is a collection that maps keys of type TKey
             to values of type TValue. The keys are maintained in a sorted order, and at most one value
             is permitted for each key.
             </summary>
             <remarks>
             <p>The keys are compared in one of three ways. If TKey implements IComparable&lt;TKey&gt; or IComparable,
             then the CompareTo method of that interface will be used to compare elements. Alternatively, a comparison
             function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
             <p>OrderedDictionary is implemented as a balanced binary tree. Inserting, deleting, and looking up an
             an element all are done in log(N) type, where N is the number of keys in the tree.</p>
             <p><see cref="T:System.Collections.Generic.Dictionary`2"/> is similar, but uses hashing instead of comparison, and does not maintain
             the keys in sorted order.</p>
            </remarks>
            <seealso cref="T:System.Collections.Generic.Dictionary`2"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.NewPair(`0,`1)">
            <summary>
            Helper function to create a new KeyValuePair struct.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns>A new KeyValuePair.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.NewPair(`0)">
            <summary>
            Helper function to create a new KeyValuePair struct with a default value.
            </summary>
            <param name="key">The key.</param>
            <returns>A new KeyValuePair.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.#ctor">
            <summary>
            Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey&gt;
            or IComparable. 
            The CompareTo method of this interface will be used to compare keys in this dictionary.
            </summary>
            <exception cref="T:System.InvalidOperationException">TKey does not implement IComparable&lt;TKey&gt;.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new OrderedDictionary. The Compare method of the passed comparison object
            will be used to compare keys in this dictionary.
            </summary>
            <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;TKey&gt; will never
            be called, and need not be implemented.</remarks>
            <param name="comparer">An instance of IComparer&lt;TKey&gt; that will be used to compare keys.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.#ctor(System.Comparison{`0})">
            <summary>
            Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary.
            </summary>
            <param name="comparison">A delegate to a method that will be used to compare keys.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            <para>Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey&gt;
            or IComparable. 
            The CompareTo method of this interface will be used to compare keys in this dictionary.</para>
            <para>A collection and keys and values (typically another dictionary) is used to initialized the 
            contents of the dictionary.</para>
            </summary>
            <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
            <exception cref="T:System.InvalidOperationException">TKey does not implement IComparable&lt;TKey&gt;.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IComparer{`0})">
            <summary>
            <para>Creates a new OrderedDictionary. The Compare method of the passed comparison object
            will be used to compare keys in this dictionary.</para>
            <para>A collection and keys and values (typically another dictionary) is used to initialized the 
            contents of the dictionary.</para>
            </summary>
            <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;TKey&gt; will never
            be called, and need not be implemented.</remarks>
            <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
            <param name="comparer">An instance of IComparer&lt;TKey&gt; that will be used to compare keys.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Comparison{`0})">
            <summary>
            <para>Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary.</para>
            <para>A collection and keys and values (typically another dictionary) is used to initialized the 
            contents of the dictionary.</para>
            </summary>
            <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
            <param name="comparison">A delegate to a method that will be used to compare keys.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Creates a new OrderedDictionary. The passed comparer 
            will be used to compare key-value pairs in this dictionary. Used internally  
            from other constructors.
            </summary>
            <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
            <param name="keyComparer">An IComparer that will be used to compare keys.</param>
            <param name="pairComparer">An IComparer that will be used to compare key-value pairs.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{System.Collections.Generic.KeyValuePair{`0,`1}},CodeSmith.Engine.PowerCollections.RedBlackTree{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Creates a new OrderedDictionary. The passed comparison delegate 
            will be used to compare keys in this dictionary, and the given tree is used. Used internally for Clone().
            </summary>
            <param name="keyComparer">An IComparer that will be used to compare keys.</param>
            <param name="pairComparer">A delegate to a method that will be used to compare key-value pairs.</param>
            <param name="tree">RedBlackTree that contains the data for the dictionary.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.Clone">
            <summary>
            Makes a shallow clone of this dictionary; i.e., if keys or values of the
            dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
            then each element is copied as if by simple assignment.
            </summary>
            <remarks>Cloning the dictionary takes time O(N), where N is the number of keys in the dictionary.</remarks>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.NonCloneableType(System.Type)">
            <summary>
            Throw an InvalidOperationException indicating that this type is not cloneable.
            </summary>
            <param name="t">Type to test.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.CloneContents">
            <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
            a value type, then each element is copied as if by simple assignment.
            </summary>
            <remarks><para>If TKey or TValue is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
            <para>Cloning the dictionary takes time O(N log N), where N is the number of keys in the dictionary.</para></remarks>
            <returns>The cloned dictionary.</returns>
            <exception cref="T:System.InvalidOperationException">TKey or TValue is a reference type that does not implement ICloneable.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.Reversed">
             <summary>
             Returns a View collection that can be used for enumerating the keys and values in the collection in 
             reversed order.
             </summary>
            <remarks>
            <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Reversed()) {
                // process pair
             }
            </code></p>
             <p>If an entry is added to or deleted from the dictionary while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
            <p>Calling Reverse does not copy the data in the dictionary, and the operation takes constant time.</p>
            </remarks>
             <returns>An OrderedDictionary.View of key-value pairs in reverse order.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.Range(`0,System.Boolean,`0,System.Boolean)">
             <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than <paramref name="from"/> and 
             less than <paramref name="to"/> are included. The keys are enumerated in sorted order.
             Keys equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive"/> and <paramref name="toInclusive"/> parameters.
             </summary>
            <remarks>
            <p>If <paramref name="from"/> is greater than or equal to <paramref name="to"/>, the returned collection is empty. </p>
            <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
            <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, true, to, false)) {
                // process pair
             }
            </code>
            <p>Calling Range does not copy the data in the dictionary, and the operation takes constant time.</p></remarks>
             <param name="from">The lower bound of the range.</param>
             <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
             <param name="to">The upper bound of the range. </param>
             <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
             <returns>An OrderedDictionary.View of key-value pairs in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.RangeFrom(`0,System.Boolean)">
             <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than (and optionally, equal to) <paramref name="from"/> are included. 
             The keys are enumerated in sorted order. Keys equal to <paramref name="from"/> can be included
             or excluded depending on the <paramref name="fromInclusive"/> parameter.
             </summary>
            <remarks>
            <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
            <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, true)) {
                // process pair
             }
            </code>
            <p>Calling RangeFrom does not copy of the data in the dictionary, and the operation takes constant time.</p>
            </remarks>
             <param name="from">The lower bound of the range.</param>
             <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
             <returns>An OrderedDictionary.View of key-value pairs in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.RangeTo(`0,System.Boolean)">
             <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only items that are less than (and optionally, equal to) <paramref name="to"/> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to"/> can be included
             or excluded depending on the <paramref name="toInclusive"/> parameter.
             </summary>
            <remarks>
            <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
            <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, false)) {
                // process pair
             }
            </code>
            <p>Calling RangeTo does not copy the data in the dictionary, and the operation takes constant time.</p>
            </remarks>
             <param name="to">The upper bound of the range. </param>
             <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
             <returns>An OrderedDictionary.View of key-value pairs in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.Remove(`0)">
            <summary>
            Removes the key (and associated value) from the collection that is equal to the passed in key. If
            no key in the dictionary is equal to the passed key, false is returned and the 
            dictionary is unchanged.
            </summary>
            <remarks>Equality between keys is determined by the comparison instance or delegate used
            to create the dictionary.</remarks>
            <param name="key">The key to remove.</param>
            <returns>True if the key was found and removed. False if the key was not found.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.Clear">
            <summary>
            Removes all keys and values from the dictionary.
            </summary>
            <remarks>Clearing the dictionary takes a constant amount of time, regardless of the number of keys in it.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.GetValueElseAdd(`0,`1@)">
            <summary>
            Finds a key in the dictionary. If the dictionary already contains
            a key equal to the passed key, then the existing value is returned via value. If the dictionary
            doesn't contain that key, then value is associated with that key.
            </summary>
            <remarks><para> between keys is determined by the comparison instance or delegate used
            to create the dictionary.</para>
            <para>This method takes time O(log N), where N is the number of keys in the dictionary. If a value is added, It is more efficient than
            calling TryGetValue followed by Add, because the dictionary is not searched twice.</para></remarks>
            <param name="key">The new key. </param>
            <param name="value">The new value to associated with that key, if the key isn't present. If the key was present, 
            returns the exist value associated with that key.</param>
            <returns>True if key was already present, false if key wasn't present (and a new value was added).</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.Add(`0,`1)">
            <summary>
            Adds a new key and value to the dictionary. If the dictionary already contains
            a key equal to the passed key, then an ArgumentException is thrown
            </summary>
            <remarks>
            <para>Equality between keys is determined by the comparison instance or delegate used
            to create the dictionary.</para>
            <para>Adding an key and value takes time O(log N), where N is the number of keys in the dictionary.</para></remarks>
            <param name="key">The new key. "null" is a valid key value.</param>
            <param name="value">The new value to associated with that key.</param>
            <exception cref="T:System.ArgumentException">key is already present in the dictionary</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.Replace(`0,`1)">
            <summary>
            Changes the value associated with a given key. If the dictionary does not contain
            a key equal to the passed key, then an ArgumentException is thrown.
            </summary>
            <remarks>
            <p>Unlike adding or removing an element, changing the value associated with a key
            can be performed while an enumeration (foreach) on the the dictionary is in progress.</p>
            <p>Equality between keys is determined by the comparison instance or delegate used
            to create the dictionary.</p>
            <p>Replace takes time O(log N), where N is the number of entries in the dictionary.</p></remarks>
            <param name="key">The new key. </param>
            <param name="value">The new value to associated with that key.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">key is not present in the dictionary</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.AddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds multiple key-value pairs to a dictionary. If a key exists in both the current instance and dictionaryToAdd,
            then the value is updated with the value from <cref name="keysAndValues"/> (no exception is thrown).
            Since IDictionary&lt;TKey,TValue&gt; inherits from IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;, this
            method can be used to merge one dictionary into another.
            </summary>
            <remarks>AddMany takes time O(M log (N+M)), where M is the size of <paramref name="keysAndValues"/>, and N is the size of
            this dictionary.</remarks>
            <param name="keysAndValues">A collection of keys and values whose contents are added to the current dictionary.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes all the keys found in another collection (such as an array or List&lt;TKey&gt;). Each key in keyCollectionToRemove
            is removed from the dictionary. Keys that are not present are ignored.
            </summary>
            <remarks>RemoveMany takes time O(M log N), where M is the size of keyCollectionToRemove, and N is this
            size of this collection.</remarks>
            <returns>The number of keys removed from the dictionary.</returns>
            <param name="keyCollectionToRemove">A collection of keys to remove from the dictionary.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.ContainsKey(`0)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. The dictionary
            is not changed.
            </summary>
            <remarks>Searching the dictionary for a key takes time O(log N), where N is the number of keys in the dictionary.</remarks>
            <param name="key">The key to search for.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. If so, the value
            associated with that key is returned through the value parameter.
            </summary>
            <remarks>TryGetValue takes time O(log N), where N is the number of entries in the dictionary.</remarks>
            <param name="key">The key to search for.</param>
            <param name="value">Returns the value associated with key, if true was returned.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.GetEnumerator">
            <summary>
            Returns an enumerator that enumerates all the entries in the dictionary. Each entry is 
            returned as a KeyValuePair&lt;TKey,TValue&gt;.
            The entries are enumerated in the sorted order of the keys.
            </summary>
            <remarks>
            <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the elements of the dictionary, which uses this method implicitly.</p>
            <p>If an element is added to or deleted from the dictionary while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
            <p>Enumeration all the entries in the dictionary takes time O(N log N), where N is the number
            of entries in the dictionary.</p>
            </remarks>
            <returns>An enumerator for enumerating all the elements in the OrderedDictionary.</returns>		
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.System#ICloneable#Clone">
            <summary>
            Implements ICloneable.Clone. Makes a shallow clone of this dictionary; i.e., if keys or values are reference types, then they are not cloned.
            </summary>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.Comparer">
            <summary>
            Returns the IComparer&lt;T&gt; used to compare keys in this dictionary. 
            </summary>
            <value>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for TKey (Comparer&lt;TKey&gt;.Default) is returned.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with a given key. When getting a value, if this
            key is not found in the collection, then an ArgumentException is thrown. When setting
            a value, the value replaces any existing value in the dictionary.
            </summary>
            <remarks>The indexer takes time O(log N), where N is the number of entries in the dictionary.</remarks>
            <value>The value associated with the key</value>
            <exception cref="T:System.ArgumentException">A value is being retrieved, and the key is not present in the dictionary.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.Count">
            <summary>
            Returns the number of keys in the dictionary.
            </summary>
            <remarks>The size of the dictionary is returned in constant time..</remarks>
            <value>The number of keys in the dictionary.</value>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.View">
             <summary>
             The OrderedDictionary&lt;TKey,TValue&gt;.View class is used to look at a subset of the keys and values
             inside an ordered dictionary. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
            <remarks>
             <p>Views are dynamic. If the underlying dictionary changes, the view changes in sync. If a change is made
             to the view, the underlying dictionary changes accordingly.</p>
            <p>Typically, this class is used in conjunction with a foreach statement to enumerate the keys
             and values in a subset of the OrderedDictionary. For example:</p>
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, to)) {
                // process pair
             }
            </code>
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.View.#ctor(CodeSmith.Engine.PowerCollections.OrderedDictionary{`0,`1},CodeSmith.Engine.PowerCollections.RedBlackTree{System.Collections.Generic.KeyValuePair{`0,`1}}.RangeTester,System.Boolean,System.Boolean)">
            <summary>
            Initialize the View.
            </summary>
            <param name="myDictionary">Associated OrderedDictionary to be viewed.</param>
            <param name="rangeTester">Range tester that defines the range being used.</param>
            <param name="entireTree">If true, then rangeTester defines the entire tree.</param>
            <param name="reversed">Is the view enuemerated in reverse order?</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.View.KeyInView(`0)">
            <summary>
            Determine if the given key lies within the bounds of this view.
            </summary>
            <param name="key">Key to test.</param>
            <returns>True if the key is within the bounds of this view.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.View.GetEnumerator">
            <summary>
            Enumerate all the keys and values in this view.
            </summary>
            <returns>An IEnumerator of KeyValuePairs with the keys and views in this view.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.View.ContainsKey(`0)">
            <summary>
            Tests if the key is present in the part of the dictionary being viewed.
            </summary>
            <param name="key">Key to check for.</param>
            <returns>True if the key is within this view. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.View.TryGetValue(`0,`1@)">
            <summary>
            Determines if this view contains a key equal to <paramref name="key"/>. If so, the value
            associated with that key is returned through the value parameter. 
            </summary>
            <param name="key">The key to search for.</param>
            <param name="value">Returns the value associated with key, if true was returned.</param>
            <returns>True if the key is within this view. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.View.Remove(`0)">
            <summary>
            Removes the key (and associated value) from the underlying dictionary of this view. that is equal to the passed in key. If
            no key in the view is equal to the passed key, the dictionary and view are unchanged.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>True if the key was found and removed. False if the key was not found.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.View.Clear">
            <summary>
            Removes all the keys and values within this view from the underlying OrderedDictionary.
            </summary>
            <example>The following removes all the keys that start with "A" from an OrderedDictionary.
            <code>
            dictionary.Range("A", "B").Clear();
            </code>
            </example>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.View.Reversed">
            <summary>
            Creates a new View that has the same keys and values as this, in the reversed order.
            </summary>
            <returns>A new View that has the reversed order of this view.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.View.Count">
            <summary>
            Number of keys in this view.
            </summary>
            <value>Number of keys that lie within the bounds the view.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedDictionary`2.View.Item(`0)">
            <summary>
            Gets or sets the value associated with a given key. When getting a value, if this
            key is not found in the collection, then an ArgumentException is thrown. When setting
            a value, the value replaces any existing value in the dictionary. When setting a value, the 
            key must be within the range of keys being viewed.
            </summary>
            <value>The value associated with the key.</value>
            <exception cref="T:System.ArgumentException">A value is being retrieved, and the key is not present in the dictionary, 
            or a value is being set, and the key is outside the range of keys being viewed by this View.</exception>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2">
             <summary>
             <para>The OrderedMultiDictionary class that associates values with a key. Unlike an OrderedDictionary,
             each key can have multiple values associated with it. When indexing an OrderedMultidictionary, instead
             of a single value associated with a key, you retrieve an enumeration of values.</para>
             <para>All of the key are stored in sorted order. Also, the values associated with a given key 
             are kept in sorted order as well.</para>
             <para>When constructed, you can chose to allow the same value to be associated with a key multiple
             times, or only one time. </para>
             </summary>
             <typeparam name="TKey">The type of the keys.</typeparam>
             <typeparam name="TValue">The of values associated with the keys.</typeparam>
            <seealso cref="T:CodeSmith.Engine.PowerCollections.MultiDictionary`2"/>
            <seealso cref="T:CodeSmith.Engine.PowerCollections.OrderedDictionary`2"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.NewPair(`0,`1)">
            <summary>
            Helper function to create a new KeyValuePair struct.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns>A new KeyValuePair.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.NewPair(`0)">
            <summary>
            Helper function to create a new KeyValuePair struct with a default value.
            </summary>
            <param name="key">The key.</param>
            <returns>A new KeyValuePair.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.KeyRange(`0)">
            <summary>
            Get a RangeTester that maps to the range of all items with the 
            given key.
            </summary>
            <param name="key">Key in the given range.</param>
            <returns>A RangeTester delegate that selects the range of items with that range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.DoubleBoundedKeyRangeTester(`0,System.Boolean,`0,System.Boolean)">
            <summary>
            Gets a range tester that defines a range by first and last items.
            </summary>
            <param name="first">The lower bound.</param>
            <param name="firstInclusive">True if the lower bound is inclusive, false if exclusive.</param>
            <param name="last">The upper bound.</param>
            <param name="lastInclusive">True if the upper bound is inclusive, false if exclusive.</param>
            <returns>A RangeTester delegate that tests for a key in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.LowerBoundedKeyRangeTester(`0,System.Boolean)">
            <summary>
            Gets a range tester that defines a range by a lower bound.
            </summary>
            <param name="first">The lower bound.</param>
            <param name="inclusive">True if the lower bound is inclusive, false if exclusive.</param>
            <returns>A RangeTester delegate that tests for a key in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.UpperBoundedKeyRangeTester(`0,System.Boolean)">
            <summary>
            Gets a range tester that defines a range by upper bound.
            </summary>
            <param name="last">The upper bound.</param>
            <param name="inclusive">True if the upper bound is inclusive, false if exclusive.</param>
            <returns>A RangeTester delegate that tests for a key in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean)">
            <summary>
            Create a new OrderedMultiDictionary. The default ordering of keys and values are used. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
            <remarks>The default ordering of keys and values will be used, as defined by TKey and TValue's implementation
            of IComparable&lt;T&gt; (or IComparable if IComparable&lt;T&gt; is not implemented). If a different ordering should be
            used, other constructors allow a custom Comparer or IComparer to be passed to changed the ordering.</remarks>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <exception cref="T:System.InvalidOperationException">TKey or TValue does not implement either IComparable&lt;T&gt; or IComparable.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Comparison{`0})">
            <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <param name="keyComparison">A delegate to a method that will be used to compare keys.</param>
            <exception cref="T:System.InvalidOperationException">TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Comparison{`0},System.Comparison{`1})">
            <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <param name="keyComparison">A delegate to a method that will be used to compare keys.</param>
            <param name="valueComparison">A delegate to a method that will be used to compare values.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <param name="keyComparer">An IComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
            <exception cref="T:System.InvalidOperationException">TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{`1})">
            <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <param name="keyComparer">An IComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
            <param name="valueComparer">An IComparer&lt;TValue&gt; instance that will be used to compare values.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Int32,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{`1},System.Collections.Generic.IComparer{System.Collections.Generic.KeyValuePair{`0,`1}},CodeSmith.Engine.PowerCollections.RedBlackTree{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Create a new OrderedMultiDictionary. Used internally for cloning.
            </summary>
            <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
            <param name="keyCount">Number of keys.</param>
            <param name="keyComparer">An IComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
            <param name="valueComparer">An IComparer&lt;TValue&gt; instance that will be used to compare values.</param>
            <param name="comparer">Comparer of key-value pairs.</param>
            <param name="tree">The red-black tree used to store the data.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.Add(`0,`1)">
            <summary>
            <para>Adds a new value to be associated with a key. If duplicate values are permitted, this
            method always adds a new key-value pair to the dictionary.</para>
            <para>If duplicate values are not permitted, and <paramref name="key"/> already has a value
            equal to <paramref name="value"/> associated with it, then that value is replaced with <paramref name="value"/>,
            and the number of values associate with <paramref name="key"/> is unchanged.</para>
            </summary>
            <param name="key">The key to associate with.</param>
            <param name="value">The value to associated with <paramref name="key"/>.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.Remove(`0,`1)">
            <summary>
            Removes a given value from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
            <param name="key">A key to remove a value from.</param>
            <param name="value">The value to remove.</param>
            <returns>True if <paramref name="value"/> was associated with <paramref name="key"/> (and was
            therefore removed). False if <paramref name="value"/> was not associated with <paramref name="key"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.Remove(`0)">
            <summary>
            Removes a key and all associated values from the dictionary. If the
            key is not present in the dictionary, it is unchanged and false is returned.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>True if the key was present and was removed. Returns 
            false if the key was not present.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.Clear">
            <summary>
            Removes all keys and values from the dictionary.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.EqualValues(`1,`1)">
            <summary>
            Determine if two values are equal.
            </summary>
            <param name="value1">First value to compare.</param>
            <param name="value2">Second value to compare.</param>
            <returns>True if the values are equal.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.Contains(`0,`1)">
            <summary>
            Checks to see if <paramref name="value"/> is associated with <paramref name="key"/>
            in the dictionary.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value to check.</param>
            <returns>True if <paramref name="value"/> is associated with <paramref name="key"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.ContainsKey(`0)">
            <summary>
            Checks to see if the key is present in the dictionary and has
            at least one value associated with it.
            </summary>
            <param name="key">The key to check.</param>
            <returns>True if <paramref name="key"/> is present and has at least
            one value associated with it. Returns false otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.EnumerateKeys(CodeSmith.Engine.PowerCollections.RedBlackTree{System.Collections.Generic.KeyValuePair{`0,`1}}.RangeTester,System.Boolean)">
            <summary>
            A private helper method that returns an enumerable that
            enumerates all the keys in a range.
            </summary>
            <param name="rangeTester">Defines the range to enumerate.</param>
            <param name="reversed">Should the keys be enumerated in reverse order?</param>
            <returns>An IEnumerable&lt;TKey&gt; that enumerates the keys in the given range.
            in the dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.EnumerateValuesForKey(`0)">
            <summary>
            A private helper method for the indexer to return an enumerable that
            enumerates all the values for a key. This is separate method because indexers
            can't use the yield return construct.
            </summary>
            <param name="key"></param>
            <returns>An IEnumerable&lt;TValue&gt; that can be used to enumerate all the
            values associated with <paramref name="key"/>. If <paramref name="key"/> is not present,
            an enumerable that enumerates no items is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. If so, all the values
            associated with that key are returned through the values parameter. 
            </summary>
            <param name="key">The key to search for.</param>
            <param name="values">Returns all values associated with key, if true was returned.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.EnumerateKeys">
            <summary>
            Enumerate all of the keys in the dictionary.
            </summary>
            <returns>An IEnumerator&lt;TKey&gt; of all of the keys in the dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.CountValues(`0)">
            <summary>
            Gets the number of values associated with a given key.
            </summary>
            <param name="key">The key to count values of.</param>
            <returns>The number of values associated with <paramref name="key"/>. If <paramref name="key"/>
            is not present in the dictionary, zero is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.CountAllValues">
            <summary>
            Gets a total count of values in the collection. 
            </summary>
            <returns>The total number of values associated with all keys in the dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.Clone">
            <summary>
            Makes a shallow clone of this dictionary; i.e., if keys or values of the
            dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
            then each element is copied as if by simple assignment.
            </summary>
            <remarks>Cloning the dictionary takes time O(N), where N is the number of key-value pairs in the dictionary.</remarks>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.System#ICloneable#Clone">
            <summary>
            Implements ICloneable.Clone. Makes a shallow clone of this dictionary; i.e., if keys or values are reference types, then they are not cloned.
            </summary>
            <returns>The cloned dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.NonCloneableType(System.Type)">
            <summary>
            Throw an InvalidOperationException indicating that this type is not cloneable.
            </summary>
            <param name="t">Type to test.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.CloneContents">
            <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
            a value type, then each element is copied as if by simple assignment.
            </summary>
            <remarks><para>If TKey or TValue is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
            <para>Cloning the dictionary takes time O(N log N), where N is the number of key-value pairs in the dictionary.</para></remarks>
            <returns>The cloned dictionary.</returns>
            <exception cref="T:System.InvalidOperationException">TKey or TValue is a reference type that does not implement ICloneable.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.Reversed">
             <summary>
             Returns a View collection that can be used for enumerating the keys and values in the collection in 
             reversed order.
             </summary>
            <remarks>
            <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Reversed()) {
                // process pair
             }
            </code></p>
             <p>If an entry is added to or deleted from the dictionary while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
            <p>Calling Reverse does not copy the data in the dictionary, and the operation takes constant time.</p>
            </remarks>
             <returns>An OrderedDictionary.View of key-value pairs in reverse order.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.Range(`0,System.Boolean,`0,System.Boolean)">
             <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than <paramref name="from"/> and 
             less than <paramref name="to"/> are included. The keys are enumerated in sorted order.
             Keys equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive"/> and <paramref name="toInclusive"/> parameters.
             </summary>
            <remarks>
            <p>If <paramref name="from"/> is greater than or equal to <paramref name="to"/>, the returned collection is empty. </p>
            <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
            <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, true, to, false)) {
                // process pair
             }
            </code>
            <p>Calling Range does not copy the data in the dictionary, and the operation takes constant time.</p></remarks>
             <param name="from">The lower bound of the range.</param>
             <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
             <param name="to">The upper bound of the range. </param>
             <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
             <returns>An OrderedMultiDictionary.View of key-value pairs in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.RangeFrom(`0,System.Boolean)">
             <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than (and optionally, equal to) <paramref name="from"/> are included. 
             The keys are enumerated in sorted order. Keys equal to <paramref name="from"/> can be included
             or excluded depending on the <paramref name="fromInclusive"/> parameter.
             </summary>
            <remarks>
            <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
            <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, true)) {
                // process pair
             }
            </code>
            <p>Calling RangeFrom does not copy of the data in the dictionary, and the operation takes constant time.</p>
            </remarks>
             <param name="from">The lower bound of the range.</param>
             <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
             <returns>An OrderedMultiDictionary.View of key-value pairs in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.RangeTo(`0,System.Boolean)">
             <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only items that are less than (and optionally, equal to) <paramref name="to"/> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to"/> can be included
             or excluded depending on the <paramref name="toInclusive"/> parameter.
             </summary>
            <remarks>
            <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
            <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, false)) {
                // process pair
             }
            </code>
            <p>Calling RangeTo does not copy the data in the dictionary, and the operation takes constant time.</p>
            </remarks>
             <param name="to">The upper bound of the range. </param>
             <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
             <returns>An OrderedMultiDictionary.View of key-value pairs in the given range.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.KeyComparer">
            <summary>
            Returns the IComparer&lt;T&gt; used to compare keys in this dictionary. 
            </summary>
            <value>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for TKey (Comparer&lt;TKey&gt;.Default) is returned.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.ValueComparer">
            <summary>
            Returns the IComparer&lt;T&gt; used to compare values in this dictionary. 
            </summary>
            <value>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for TValue (Comparer&lt;TValue&gt;.Default) is returned.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.Count">
            <summary>
            Gets the number of key-value pairs in the dictionary. Each value associated
            with a given key is counted. If duplicate values are permitted, each duplicate
            value is included in the count.
            </summary>
            <value>The number of key-value pairs in the dictionary.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.KeyValuePairs">
            <summary>
            Gets a read-only collection of all key-value pairs in the dictionary. If a key has multiple
            values associated with it, then a key-value pair is present for each value associated
            with the key.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.KeyValuePairsCollection">
            <summary>
            A private class that implements ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; and ICollection for the
            KeyValuePairs collection. The collection is read-only.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.View">
             <summary>
             The OrderedMultiDictionary&lt;TKey,TValue&gt;.View class is used to look at a subset of the keys and values
             inside an ordered multi-dictionary. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
            <remarks>
             <p>Views are dynamic. If the underlying dictionary changes, the view changes in sync. If a change is made
             to the view, the underlying dictionary changes accordingly.</p>
            <p>Typically, this class is used in conjunction with a foreach statement to enumerate the keys
             and values in a subset of the OrderedMultiDictionary. For example:</p>
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, to)) {
                // process pair
             }
            </code>
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.View.#ctor(CodeSmith.Engine.PowerCollections.OrderedMultiDictionary{`0,`1},CodeSmith.Engine.PowerCollections.RedBlackTree{System.Collections.Generic.KeyValuePair{`0,`1}}.RangeTester,System.Boolean,System.Boolean)">
            <summary>
            Initialize the View.
            </summary>
            <param name="myDictionary">Associated OrderedMultiDictionary to be viewed.</param>
            <param name="rangeTester">Range tester that defines the range being used.</param>
            <param name="entireTree">If true, then rangeTester defines the entire tree.</param>
            <param name="reversed">Is the view enuemerated in reverse order?</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.View.KeyInView(`0)">
            <summary>
            Determine if the given key lies within the bounds of this view.
            </summary>
            <param name="key">Key to test.</param>
            <returns>True if the key is within the bounds of this view.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.View.EnumerateKeys">
            <summary>
            Enumerate all the keys in the dictionary. 
            </summary>
            <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the collection that
            have at least one value associated with them.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.View.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
            <summary>
            Enumerate all of the values associated with a given key. If the key exists and has values associated with it, an enumerator for those
            values is returned throught <paramref name="values"/>. If the key does not exist, false is returned.
            </summary>
            <param name="key">The key to get values for.</param>
            <param name="values">If true is returned, this parameter receives an enumerators that
            enumerates the values associated with that key.</param>
            <returns>True if the key exists and has values associated with it. False otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.View.ContainsKey(`0)">
            <summary>
            Tests if the key is present in the part of the dictionary being viewed.
            </summary>
            <param name="key">Key to check</param>
            <returns>True if the key is within this view. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.View.Contains(`0,`1)">
            <summary>
            Tests if the key-value pair is present in the part of the dictionary being viewed.
            </summary>
            <param name="key">Key to check for.</param>
            <param name="value">Value to check for.</param>
            <returns>True if the key-value pair is within this view. </returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.View.CountValues(`0)">
            <summary>
            Gets the number of values associated with a given key.
            </summary>
            <param name="key">The key to count values of.</param>
            <returns>The number of values associated with <paramref name="key"/>. If <paramref name="key"/>
            is not present in this view, zero is returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.View.Add(`0,`1)">
            <summary>
            Adds the given key-value pair to the underlying dictionary of this view.
            If <paramref name="key"/> is not within the range of this view, an
            ArgumentException is thrown.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <exception cref="T:System.ArgumentException"><paramref name="key"/> is not 
            within the range of this view.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.View.Remove(`0)">
            <summary>
            Removes the key (and associated value) from the underlying dictionary of this view. If
            no key in the view is equal to the passed key, the dictionary and view are unchanged.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>True if the key was found and removed. False if the key was not found.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.View.Remove(`0,`1)">
            <summary>
            Removes the key and value from the underlying dictionary of this view. that is equal to the passed in key. If
            no key in the view is equal to the passed key, or has the given value associated with it, the dictionary and view are unchanged.
            </summary>
            <param name="key">The key to remove.</param>
            <param name="value">The value to remove.</param>
            <returns>True if the key-value pair was found and removed. False if the key-value pair was not found.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.View.Clear">
            <summary>
            Removes all the keys and values within this view from the underlying OrderedMultiDictionary.
            </summary>
            <example>The following removes all the keys that start with "A" from an OrderedMultiDictionary.
            <code>
            dictionary.Range("A", "B").Clear();
            </code>
            </example>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.View.Reversed">
            <summary>
            Creates a new View that has the same keys and values as this, in the reversed order.
            </summary>
            <returns>A new View that has the reversed order of this view.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedMultiDictionary`2.View.Count">
            <summary>
            Number of keys in this view.
            </summary>
            <value>Number of keys that lie within the bounds the view.</value>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.OrderedSet`1">
             <summary>
             OrderedSet&lt;T&gt; is a collection that contains items of type T. 
             The item are maintained in a sorted order, and duplicate items are not allowed. Each item has
             an index in the set: the smallest item has index 0, the next smallest item has index 1,
             and so forth.
             </summary>
             <remarks>
             <p>The items are compared in one of three ways. If T implements IComparable&lt;TKey&gt; or IComparable,
             then the CompareTo method of that interface will be used to compare items. Alternatively, a comparison
             function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
             <p>OrderedSet is implemented as a balanced binary tree. Inserting, deleting, and looking up an
             an element all are done in log(N) type, where N is the number of keys in the tree.</p>
             <p><see cref="T:CodeSmith.Engine.PowerCollections.Set`1"/> is similar, but uses hashing instead of comparison, and does not maintain
             the items in sorted order.</p>
            </remarks>
            <seealso cref="T:CodeSmith.Engine.PowerCollections.Set`1"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.#ctor">
             <summary>
             Creates a new OrderedSet. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this set.
             </summary>
            <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
             <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.#ctor(System.Comparison{`0})">
            <summary>
            Creates a new OrderedSet. The passed delegate will be used to compare items in this set.
            </summary>
            <param name="comparison">A delegate to a method that will be used to compare items.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new OrderedSet. The Compare method of the passed comparison object
            will be used to compare items in this set.
            </summary>
            <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
            <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Creates a new OrderedSet. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this set. The set is
             initialized with all the items in the given collection.
             </summary>
            <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
             <param name="collection">A collection with items to be placed into the OrderedSet.</param>
             <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Comparison{`0})">
            <summary>
            Creates a new OrderedSet. The passed delegate will be used to compare items in this set.
            The set is initialized with all the items in the given collection.
            </summary>
            <param name="collection">A collection with items to be placed into the OrderedSet.</param>
            <param name="comparison">A delegate to a method that will be used to compare items.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new OrderedSet. The Compare method of the passed comparison object
            will be used to compare items in this set. The set is
            initialized with all the items in the given collection.
            </summary>
            <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
            <param name="collection">A collection with items to be placed into the OrderedSet.</param>
            <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IComparer{`0},CodeSmith.Engine.PowerCollections.RedBlackTree{`0})">
            <summary>
            Creates a new OrderedSet given a comparer and a tree that contains the data. Used
            internally for Clone.
            </summary>
            <param name="comparer">Comparer for the set.</param>
            <param name="tree">Data for the set.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.System#ICloneable#Clone">
            <summary>
            Makes a shallow clone of this set; i.e., if items of the
            set are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
            <remarks>Cloning the set takes time O(N), where N is the number of items in the set.</remarks>
            <returns>The cloned set.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.Clone">
            <summary>
            Makes a shallow clone of this set; i.e., if items of the
            set are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
            <remarks>Cloning the set takes time O(N), where N is the number of items in the set.</remarks>
            <returns>The cloned set.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.CloneContents">
            <summary>
            Makes a deep clone of this set. A new set is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
            <remarks><para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
            <para>Cloning the set takes time O(N log N), where N is the number of items in the set.</para></remarks>
            <returns>The cloned set.</returns>
            <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.GetEnumerator">
            <summary>
            Returns an enumerator that enumerates all the items in the set. 
            The items are enumerated in sorted order.
            </summary>
            <remarks>
            <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
            <p>If an item is added to or deleted from the set while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
            <p>Enumeration all the items in the set takes time O(N log N), where N is the number
            of items in the set.</p>
            </remarks>
            <returns>An enumerator for enumerating all the items in the OrderedSet.</returns>		
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.Contains(`0)">
            <summary>
            Determines if this set contains an item equal to <paramref name="item"/>. The set
            is not changed.
            </summary>
            <remarks>Searching the set for an item takes time O(log N), where N is the number of items in the set.</remarks>
            <param name="item">The item to search for.</param>
            <returns>True if the set contains <paramref name="item"/>. False if the set does not contain <paramref name="item"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.TryGetItem(`0,`0@)">
            <summary>
            <para>Determines if this set contains an item equal to <paramref name="item"/>, according to the 
            comparison mechanism that was used when the set was created. The set
            is not changed.</para>
            <para>If the set does contain an item equal to <paramref name="item"/>, then the item from the set is returned.</para>
            </summary>
            <remarks>Searching the set for an item takes time O(log N), where N is the number of items in the set.</remarks>
            <example>
            In the following example, the set contains strings which are compared in a case-insensitive manner. 
            <code>
            OrderedSet&lt;string&gt; set = new OrderedSet&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase);
            set.Add("HELLO");
            string s;
            bool b = set.TryGetItem("Hello", out s);   // b receives true, s receives "HELLO".
            </code>
            </example>
            <param name="item">The item to search for.</param>
            <param name="foundItem">Returns the item from the set that was equal to <paramref name="item"/>.</param>
            <returns>True if the set contains <paramref name="item"/>. False if the set does not contain <paramref name="item"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.IndexOf(`0)">
            <summary>
            Get the index of the given item in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
            <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
            <param name="item">The item to get the index of.</param>
            <returns>The index of the item in the sorted set, or -1 if the item is not present
            in the set.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.Add(`0)">
            <summary>
            Adds a new item to the set. If the set already contains an item equal to
            <paramref name="item"/>, that item is replaced with <paramref name="item"/>.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
            <para>Adding an item takes time O(log N), where N is the number of items in the set.</para></remarks>
            <param name="item">The item to add to the set.</param>
            <returns>True if the set already contained an item equal to <paramref name="item"/> (which was replaced), false 
            otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Adds a new item to the set. If the set already contains an item equal to
            <paramref name="item"/>, that item is replaces with <paramref name="item"/>.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
            <para>Adding an item takes time O(log N), where N is the number of items in the set.</para></remarks>
            <param name="item">The item to add to the set.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds all the items in <paramref name="collection"/> to the set. If the set already contains an item equal to
            one of the items in <paramref name="collection"/>, that item will be replaced.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
            <para>Adding the collection takes time O(M log N), where N is the number of items in the set, and M is the 
            number of items in <paramref name="collection"/>.</para></remarks>
            <param name="collection">A collection of items to add to the set.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.Remove(`0)">
            <summary>
            Searches the set for an item equal to <paramref name="item"/>, and if found,
            removes it from the set. If not found, the set is unchanged.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
            <para>Removing an item from the set takes time O(log N), where N is the number of items in the set.</para></remarks>
            <param name="item">The item to remove.</param>
            <returns>True if <paramref name="item"/> was found and removed. False if <paramref name="item"/> was not in the set.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes all the items in <paramref name="collection"/> from the set. Items
            not present in the set are ignored.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
            <para>Removing the collection takes time O(M log N), where N is the number of items in the set, and M is the 
            number of items in <paramref name="collection"/>.</para></remarks>
            <param name="collection">A collection of items to remove from the set.</param>
            <returns>The number of items removed from the set.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.Clear">
            <summary>
            Removes all items from the set.
            </summary>
            <remarks>Clearing the sets takes a constant amount of time, regardless of the number of items in it.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.CheckEmpty">
            <summary>
            If the collection is empty, throw an invalid operation exception.
            </summary>
            <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.GetFirst">
            <summary>
            Returns the first item in the set: the item
            that would appear first if the set was enumerated. This is also
            the smallest item in the set.
            </summary>
            <remarks>GetFirst() takes time O(log N), where N is the number of items in the set.</remarks>
            <returns>The first item in the set. </returns>
            <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.GetLast">
            <summary>
            Returns the lastl item in the set: the item
            that would appear last if the set was enumerated. This is also the
            largest item in the set.
            </summary>
            <remarks>GetLast() takes time O(log N), where N is the number of items in the set.</remarks>
            <returns>The lastl item in the set. </returns>
            <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.RemoveFirst">
            <summary>
            Removes the first item in the set. This is also the smallest item in the set.
            </summary>
            <remarks>RemoveFirst() takes time O(log N), where N is the number of items in the set.</remarks>
            <returns>The item that was removed, which was the smallest item in the set. </returns>
            <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.RemoveLast">
            <summary>
            Removes the last item in the set. This is also the largest item in the set.
            </summary>
            <remarks>RemoveLast() takes time O(log N), where N is the number of items in the set.</remarks>
            <returns>The item that was removed, which was the largest item in the set. </returns>
            <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.CheckConsistentComparison(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Check that this set and another set were created with the same comparison
            mechanism. Throws exception if not compatible.
            </summary>
            <param name="otherSet">Other set to check comparision mechanism.</param>
            <exception cref="T:System.InvalidOperationException">If otherSet and this set don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.IsSupersetOf(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Determines if this set is a superset of another set. Neither set is modified.
            This set is a superset of <paramref name="otherSet"/> if every element in
            <paramref name="otherSet"/> is also in this set.
            <remarks>IsSupersetOf is computed in time O(M log N), where M is the size of the 
            <paramref name="otherSet"/>, and N is the size of the this set.</remarks>
            </summary>
            <param name="otherSet">OrderedSet to compare to.</param>
            <returns>True if this is a superset of <paramref name="otherSet"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.IsProperSupersetOf(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Determines if this set is a proper superset of another set. Neither set is modified.
            This set is a proper superset of <paramref name="otherSet"/> if every element in
            <paramref name="otherSet"/> is also in this set.
            Additionally, this set must have strictly more items than <paramref name="otherSet"/>.
            </summary>
            <remarks>IsProperSupersetOf is computed in time O(M log N), where M is the number of unique items in 
            <paramref name="otherSet"/>.</remarks>
            <param name="otherSet">OrderedSet to compare to.</param>
            <returns>True if this is a proper superset of <paramref name="otherSet"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.IsSubsetOf(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Determines if this set is a subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet"/> if every element in this set
            is also in <paramref name="otherSet"/>.
            </summary>
            <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref name="otherSet"/>, and N is the size of the this set.</remarks>
            <param name="otherSet">Set to compare to.</param>
            <returns>True if this is a subset of <paramref name="otherSet"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.IsProperSubsetOf(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Determines if this set is a proper subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet"/> if every element in this set
            is also in <paramref name="otherSet"/>. Additionally, this set must have strictly 
            fewer items than <paramref name="otherSet"/>.
            </summary>
            <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref name="otherSet"/>, and N is the size of the this set.</remarks>
            <param name="otherSet">Set to compare to.</param>
            <returns>True if this is a proper subset of <paramref name="otherSet"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.IsEqualTo(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Determines if this set is equal to another set. This set is equal to
            <paramref name="otherSet"/> if they contain the same items.
            </summary>
            <remarks>IsEqualTo is computed in time O(N), where N is the number of items in 
            this set.</remarks>
            <param name="otherSet">Set to compare to</param>
            <returns>True if this set is equal to <paramref name="otherSet"/>, false otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.UnionWith(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. This set receives
            the union of the two sets, the other set is unchanged.
            </summary>
            <remarks>
            <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The union of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to union with.</param>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.IsDisjointFrom(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Determines if this set is disjoint from another set. Two sets are disjoint
            if no item from one set is equal to any item in the other set.
            </summary>
            <remarks>
            <para>The answer is computed in time O(N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to check disjointness with.</param>
            <returns>True if the two sets are disjoint, false otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.Union(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. A new set is 
            created with the union of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
            <remarks>
            <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The union of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to union with.</param>
            <returns>The union of the two sets.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.IntersectionWith(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. This set receives
            the intersection of the two sets, the other set is unchanged.
            </summary>
            <remarks>
            <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The intersection of two sets is computed in time O(N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to intersection with.</param>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.Intersection(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. A new set is 
            created with the intersection of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
            <remarks>
            <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The intersection of two sets is computed in time O(N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to intersection with.</param>
            <returns>The intersection of the two sets.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.DifferenceWith(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet"/>. This set receives
            the difference of the two sets; the other set is unchanged.
            </summary>
            <remarks>
            <para>The difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to difference with.</param>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.Difference(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet"/>. A new set is 
            created with the difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
            <remarks>
            <para>The difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to difference with.</param>
            <returns>The difference of the two sets.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.SymmetricDifferenceWith(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. This set receives
            the symmetric difference of the two sets; the other set is unchanged.
            </summary>
            <remarks>
            <para>The symmetric difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to symmetric difference with.</param>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.SymmetricDifference(CodeSmith.Engine.PowerCollections.OrderedSet{`0})">
            <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. A new set is 
            created with the symmetric difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
            <remarks>
            <para>The symmetric difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to symmetric difference with.</param>
            <returns>The symmetric difference of the two sets.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.AsList">
            <summary>
            Get a read-only list view of the items in this ordered set. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedSet.
            </summary>
            <returns>A read-only IList&lt;T&gt; view onto this OrderedSet.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.Reversed">
             <summary>
             Returns a View collection that can be used for enumerating the items in the set in 
             reversed order.
             </summary>
            <remarks>
            <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.Reversed()) {
                // process item
             }
            </code></p>
             <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
            <p>Calling Reverse does not copy the data in the tree, and the operation takes constant time.</p>
            </remarks>
             <returns>An OrderedSet.View of items in reverse order.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.Range(`0,System.Boolean,`0,System.Boolean)">
             <summary>
             Returns a View collection that can be used for enumerating a range of the items in the set..
             Only items that are greater than <paramref name="from"/> and 
             less than <paramref name="to"/> are included. The items are enumerated in sorted order.
             Items equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive"/> and <paramref name="toInclusive"/> parameters.
             </summary>
            <remarks>
            <p>If <paramref name="from"/> is greater than <paramref name="to"/>, the returned collection is empty. </p>
            <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.Range(from, true, to, false)) {
                // process item
             }
            </code></p>
             <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
            <p>Calling Range does not copy the data in the tree, and the operation takes constant time.</p>
            </remarks>
             <param name="from">The lower bound of the range.</param>
             <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
             <param name="to">The upper bound of the range. </param>
             <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
             <returns>An OrderedSet.View of items in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.RangeFrom(`0,System.Boolean)">
             <summary>
             Returns a View collection that can be used for enumerating a range of the items in the set..
             Only items that are greater than (and optionally, equal to) <paramref name="from"/> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="from"/> can be included
             or excluded depending on the <paramref name="fromInclusive"/> parameter.
             </summary>
            <remarks>
            <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.RangeFrom(from, true)) {
                // process item
             }
            </code></p>
             <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
            <p>Calling RangeFrom does not copy the data in the tree, and the operation takes constant time.</p>
            </remarks>
             <param name="from">The lower bound of the range.</param>
             <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
             <returns>An OrderedSet.View of items in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.RangeTo(`0,System.Boolean)">
             <summary>
             Returns a View collection that can be used for enumerating a range of the items in the set..
             Only items that are less than (and optionally, equal to) <paramref name="to"/> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to"/> can be included
             or excluded depending on the <paramref name="toInclusive"/> parameter.
             </summary>
            <remarks>
            <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.RangeTo(to, false)) {
                // process item
             }
            </code></p>
             <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
            <p>Calling RangeTo does not copy the data in the tree, and the operation takes constant time.</p>
            </remarks>
             <param name="to">The upper bound of the range. </param>
             <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
             <returns>An OrderedSet.View of items in the given range.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedSet`1.Comparer">
            <summary>
            Returns the IComparer&lt;T&gt; used to compare items in this set. 
            </summary>
            <value>If the set was created using a comparer, that comparer is returned. If the set was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for T (Comparer&lt;T&gt;.Default) is returned.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedSet`1.Count">
            <summary>
            Returns the number of items in the set.
            </summary>
            <remarks>The size of the set is returned in constant time.</remarks>
            <value>The number of items in the set.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedSet`1.Item(System.Int32)">
            <summary>
            Get the item by its index in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
            <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
            <param name="index">The index to get the item by.</param>
            <returns>The item at the given index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.OrderedSet`1.ListView">
            <summary>
            The nested class that provides a read-only list view
            of all or part of the collection.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.ListView.#ctor(CodeSmith.Engine.PowerCollections.OrderedSet{`0},CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.RangeTester,System.Boolean,System.Boolean)">
            <summary>
            Create a new list view wrapped the given set.
            </summary>
            <param name="mySet"></param>
            <param name="rangeTester">Range tester that defines the range being used.</param>
            <param name="entireTree">If true, then rangeTester defines the entire tree. Used to optimize some operations.</param>
            <param name="reversed">Is the view enuemerated in reverse order?</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.OrderedSet`1.View">
             <summary>
             The OrderedSet&lt;T&gt;.View class is used to look at a subset of the Items
             inside an ordered set. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
            <remarks>
             <p>Views are dynamic. If the underlying set changes, the view changes in sync. If a change is made
             to the view, the underlying set changes accordingly.</p>
            <p>Typically, this class is used in conjunction with a foreach statement to enumerate the items 
             in a subset of the OrderedSet. For example:</p>
            <code>
             foreach(T item in set.Range(from, to)) {
                // process item
             }
            </code>
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.#ctor(CodeSmith.Engine.PowerCollections.OrderedSet{`0},CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.RangeTester,System.Boolean,System.Boolean)">
            <summary>
            Initialize the view.
            </summary>
            <param name="mySet">OrderedSet being viewed</param>
            <param name="rangeTester">Range tester that defines the range being used.</param>
            <param name="entireTree">If true, then rangeTester defines the entire tree. Used to optimize some operations.</param>
            <param name="reversed">Is the view enuemerated in reverse order?</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.ItemInView(`0)">
            <summary>
            Determine if the given item lies within the bounds of this view.
            </summary>
            <param name="item">Item to test.</param>
            <returns>True if the item is within the bounds of this view.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.GetEnumerator">
            <summary>
            Enumerate all the items in this view.
            </summary>
            <returns>An IEnumerator&lt;T&gt; with the items in this view.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.Clear">
            <summary>
            Removes all the items within this view from the underlying set.
            </summary>
            <example>The following removes all the items that start with "A" from an OrderedSet.
            <code>
            set.Range("A", "B").Clear();
            </code>
            </example>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.Add(`0)">
            <summary>
            Adds a new item to the set underlying this View. If the set already contains an item equal to
            <paramref name="item"/>, that item is replaces with <paramref name="item"/>. If
            <paramref name="item"/> is outside the range of this view, an InvalidOperationException
            is thrown.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
            <para>Adding an item takes time O(log N), where N is the number of items in the set.</para></remarks>
            <param name="item">The item to add.</param>
            <returns>True if the set already contained an item equal to <paramref name="item"/> (which was replaced), false 
            otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Adds a new item to the set underlying this View. If the set already contains an item equal to
            <paramref name="item"/>, that item is replaces with <paramref name="item"/>. If
            <paramref name="item"/> is outside the range of this view, an InvalidOperationException
            is thrown.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
            <para>Adding an item takes time O(log N), where N is the number of items in the set.</para></remarks>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.Remove(`0)">
            <summary>
            Searches the underlying set for an item equal to <paramref name="item"/>, and if found,
            removes it from the set. If not found, the set is unchanged. If the item is outside
            the range of this view, the set is unchanged.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
            <para>Removing an item from the set takes time O(log N), where N is the number of items in the set.</para></remarks>
            <param name="item">The item to remove.</param>
            <returns>True if <paramref name="item"/> was found and removed. False if <paramref name="item"/> was not in the set, or
            was outside the range of this view.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.Contains(`0)">
            <summary>
            Determines if this view of the set contains an item equal to <paramref name="item"/>. The set
            is not changed. If 
            </summary>
            <remarks>Searching the set for an item takes time O(log N), where N is the number of items in the set.</remarks>
            <param name="item">The item to search for.</param>
            <returns>True if the set contains <paramref name="item"/>, and <paramref name="item"/> is within
            the range of this view. False otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.IndexOf(`0)">
            <summary>
            Get the index of the given item in the view. The smallest item in the view has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
            <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
            <param name="item">The item to get the index of.</param>
            <returns>The index of the item in the view, or -1 if the item is not present
            in the view.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.AsList">
            <summary>
            Get a read-only list view of the items in this view. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedSet.
            </summary>
            <returns>A read-only IList&lt;T&gt; view onto this view.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.Reversed">
            <summary>
            Creates a new View that has the same items as this view, in the reversed order.
            </summary>
            <returns>A new View that has the reversed order of this view, with the same upper 
            and lower bounds.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.GetFirst">
            <summary>
            Returns the first item in this view: the item
            that would appear first if the view was enumerated. 
            </summary>
            <remarks>GetFirst() takes time O(log N), where N is the number of items in the set.</remarks>
            <returns>The first item in the view. </returns>
            <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.GetLast">
            <summary>
            Returns the last item in the view: the item
            that would appear last if the view was enumerated. 
            </summary>
            <remarks>GetLast() takes time O(log N), where N is the number of items in the set.</remarks>
            <returns>The last item in the view. </returns>
            <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.Count">
            <summary>
            Number of items in this view.
            </summary>
            <value>Number of items that lie within the bounds the view.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.OrderedSet`1.View.Item(System.Int32)">
            <summary>
            Get the item by its index in the sorted order. The smallest item in the view has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
            <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
            <param name="index">The index to get the item by.</param>
            <returns>The item at the given index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count.</exception>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Pair`2">
            <summary>
            Stores a pair of objects within a single struct. This struct is useful to use as the
            T of a collection, or as the TKey or TValue of a dictionary.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.PowerCollections.Pair`2.firstComparer">
            <summary>
            Comparers for the first and second type that are used to compare
            values.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.PowerCollections.Pair`2.First">
            <summary>
            The first element of the pair.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.PowerCollections.Pair`2.Second">
            <summary>
            The second element of the pair.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Pair`2.#ctor(`0,`1)">
            <summary>
            Creates a new pair with given first and second elements.
            </summary>
            <param name="first">The first element of the pair.</param>
            <param name="second">The second element of the pair.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Pair`2.#ctor(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Creates a new pair using elements from a KeyValuePair structure. The
            First element gets the Key, and the Second elements gets the Value.
            </summary>
            <param name="keyAndValue">The KeyValuePair to initialize the Pair with .</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Pair`2.Equals(System.Object)">
            <summary>
            Determines if this pair is equal to another object. The pair is equal to another object 
            if that object is a Pair, both element types are the same, and the first and second elements
            both compare equal using object.Equals.
            </summary>
            <param name="obj">Object to compare for equality.</param>
            <returns>True if the objects are equal. False if the objects are not equal.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Pair`2.Equals(CodeSmith.Engine.PowerCollections.Pair{`0,`1})">
            <summary>
            Determines if this pair is equal to another pair. The pair is equal if  the first and second elements
            both compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
            <param name="other">Pair to compare with for equality.</param>
            <returns>True if the pairs are equal. False if the pairs are not equal.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Pair`2.GetHashCode">
            <summary>
            Returns a hash code for the pair, suitable for use in a hash-table or other hashed collection.
            Two pairs that compare equal (using Equals) will have the same hash code. The hash code for
            the pair is derived by combining the hash codes for each of the two elements of the pair.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Pair`2.CompareTo(CodeSmith.Engine.PowerCollections.Pair{`0,`1})">
            <summary>
            <para> Compares this pair to another pair of the some type. The pairs are compared by using
            the IComparable&lt;T&gt; or IComparable interface on TFirst and TSecond. The pairs
            are compared by their first elements first, if their first elements are equal, then they
            are compared by their second elements.</para>
            <para>If either TFirst or TSecond does not implement IComparable&lt;T&gt; or IComparable, then
            an NotSupportedException is thrown, because the pairs cannot be compared.</para>
            </summary>
            <param name="other">The pair to compare to.</param>
            <returns>An integer indicating how this pair compares to <paramref name="other"/>. Less
            than zero indicates this pair is less than <paramref name="other"/>. Zero indicate this pair is
            equals to <paramref name="other"/>. Greater than zero indicates this pair is greater than
            <paramref name="other"/>.</returns>
            <exception cref="T:System.NotSupportedException">Either FirstSecond or TSecond is not comparable
            via the IComparable&lt;T&gt; or IComparable interfaces.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Pair`2.System#IComparable#CompareTo(System.Object)">
            <summary>
            <para> Compares this pair to another pair of the some type. The pairs are compared by using
            the IComparable&lt;T&gt; or IComparable interface on TFirst and TSecond. The pairs
            are compared by their first elements first, if their first elements are equal, then they
            are compared by their second elements.</para>
            <para>If either TFirst or TSecond does not implement IComparable&lt;T&gt; or IComparable, then
            an NotSupportedException is thrown, because the pairs cannot be compared.</para>
            </summary>
            <param name="obj">The pair to compare to.</param>
            <returns>An integer indicating how this pair compares to <paramref name="obj"/>. Less
            than zero indicates this pair is less than the other value. Zero indicate this pair is
            equals to <paramref name="obj"/>. Greater than zero indicates this pair is greater than
            <paramref name="obj"/>.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is not of the correct type.</exception>
            <exception cref="T:System.NotSupportedException">Either FirstSecond or TSecond is not comparable
            via the IComparable&lt;T&gt; or IComparable interfaces.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Pair`2.ToString">
            <summary>
            Returns a string representation of the pair. The string representation of the pair is
            of the form:
            <c>First: {0}, Second: {1}</c>
            where {0} is the result of First.ToString(), and {1} is the result of Second.ToString() (or
            "null" if they are null.)
            </summary>
            <returns> The string representation of the pair.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Pair`2.op_Equality(CodeSmith.Engine.PowerCollections.Pair{`0,`1},CodeSmith.Engine.PowerCollections.Pair{`0,`1})">
            <summary>
            Determines if two pairs are equal. Two pairs are equal if  the first and second elements
            both compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
            <param name="pair1">First pair to compare.</param>
            <param name="pair2">Second pair to compare.</param>
            <returns>True if the pairs are equal. False if the pairs are not equal.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Pair`2.op_Inequality(CodeSmith.Engine.PowerCollections.Pair{`0,`1},CodeSmith.Engine.PowerCollections.Pair{`0,`1})">
            <summary>
            Determines if two pairs are not equal. Two pairs are equal if  the first and second elements
            both compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
            <param name="pair1">First pair to compare.</param>
            <param name="pair2">Second pair to compare.</param>
            <returns>True if the pairs are not equal. False if the pairs are equal.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Pair`2.op_Explicit(CodeSmith.Engine.PowerCollections.Pair{`0,`1})~System.Collections.Generic.KeyValuePair{`0,`1}">
            <summary>
            Converts a Pair to a KeyValuePair. The Key part of the KeyValuePair gets
            the First element, and the Value part of the KeyValuePair gets the Second 
            elements.
            </summary>
            <param name="pair">Pair to convert.</param>
            <returns>The KeyValuePair created from <paramref name="pair"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Pair`2.ToKeyValuePair">
            <summary>
            Converts this Pair to a KeyValuePair. The Key part of the KeyValuePair gets
            the First element, and the Value part of the KeyValuePair gets the Second 
            elements.
            </summary>
            <returns>The KeyValuePair created from this Pair.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Pair`2.op_Explicit(System.Collections.Generic.KeyValuePair{`0,`1})~CodeSmith.Engine.PowerCollections.Pair{`0,`1}">
            <summary>
            Converts a KeyValuePair structure into a Pair. The
            First element gets the Key, and the Second element gets the Value.
            </summary>
            <param name="keyAndValue">The KeyValuePair to convert.</param>
            <returns>The Pair created by converted the KeyValuePair into a Pair.</returns>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2">
            <summary>
            ReadOnlyDictionaryBase is a base class that can be used to more easily implement the
            generic IDictionary&lt;T&gt; and non-generic IDictionary interfaces.
            </summary>
            <remarks>
            <para>To use ReadOnlyDictionaryBase as a base class, the derived class must override
            Count, TryGetValue, GetEnumerator. </para>
            </remarks>
            <typeparam name="TKey">The key type of the dictionary.</typeparam>
            <typeparam name="TValue">The value type of the dictionary.</typeparam>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.#ctor">
            <summary>
            Creates a new DictionaryBase. This must be called from the constructor of the
            derived class to specify whether the dictionary is read-only and the name of the
            collection.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.MethodModifiesCollection">
            <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.System#Collections#Generic#IDictionary{TKey@TValue}#Add(`0,`1)">
            <summary>
            Adds a new key-value pair to the dictionary. Always throws an exception
            indicating that this method is not supported in a read-only dictionary.
            </summary>
            <param name="key">Key to add.</param>
            <param name="value">Value to associated with the key.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.Remove(`0)">
            <summary>
            Removes a key from the dictionary. Always throws an exception
            indicating that this method is not supported in a read-only dictionary.
            </summary>
            <param name="key">Key to remove from the dictionary.</param>
            <returns>True if the key was found, false otherwise.</returns>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.ContainsKey(`0)">
            <summary>
            Determines whether a given key is found
            in the dictionary.
            </summary>
            <remarks>The default implementation simply calls TryGetValue and returns
            what it returns.</remarks>
            <param name="key">Key to look for in the dictionary.</param>
            <returns>True if the key is present in the dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.TryGetValue(`0,`1@)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. If so, the value
            associated with that key is returned through the value parameter. This method must be overridden 
            in the derived class.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="value">Returns the value associated with key, if true was returned.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.ToString">
            <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
            <returns>The string representation of the dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines if a dictionary contains a given KeyValuePair. This implementation checks to see if the
            dictionary contains the given key, and if the value associated with the key is equal to (via object.Equals)
            the value.
            </summary>
            <param name="item">A KeyValuePair containing the Key and Value to check for.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            Adds a key-value pair to the collection. Always throws an exception
            indicating that this method is not supported in a read-only dictionary.
            </summary>
            <param name="key">Key to add to the dictionary.</param>
            <param name="value">Value to add to the dictionary.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.System#Collections#IDictionary#Clear">
            <summary>
            Clears this dictionary. Always throws an exception
            indicating that this method is not supported in a read-only dictionary.
            </summary>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. The dictionary
            is not changed. Calls the (overridden) ContainsKey method. If key is not of the correct
            TKey for the dictionary, false is returned.
            </summary>
            <param name="key">The key to search for.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            Removes the key (and associated value) from the collection that is equal to the passed in key. Always throws an exception
            indicating that this method is not supported in a read-only dictionary.
            </summary>
            <param name="key">The key to remove.</param>
            <exception cref="T:System.NotSupportedException">Always thrown.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Returns an enumerator that enumerates all the entries in the dictionary. Each entry is 
            returned as a DictionaryEntry.
            The entries are enumerated in the same orders as the (overridden) GetEnumerator
            method.
            </summary>
            <returns>An enumerator for enumerating all the elements in the OrderedDictionary.</returns>		
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that enumerates all the entries in the dictionary. Each entry is 
            returned as a DictionaryEntry.
            The entries are enumerated in the same orders as the (overridden) GetEnumerator
            method.
            </summary>
            <returns>An enumerator for enumerating all the elements in the OrderedDictionary.</returns>		
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.DebuggerDisplayString">
            <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
            <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.Item(`0)">
            <summary>
            The indexer of the dictionary. The set accessor throws an NotSupportedException
            stating the dictionary is read-only.
            </summary>
            <remarks>The get accessor is implemented by calling TryGetValue.</remarks>
            <param name="key">Key to find in the dictionary.</param>
            <returns>The value associated with the key.</returns>
            <exception cref="T:System.NotSupportedException">Always thrown from the set accessor, indicating
            that the dictionary is read only.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown from the get accessor if the key
            was not found.</exception>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.Keys">
            <summary>
            Returns a collection of the keys in this dictionary. 
            </summary>
            <value>A read-only collection of the keys in this dictionary.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.Values">
            <summary>
            Returns a collection of the values in this dictionary. The ordering of 
            values in this collection is the same as that in the Keys collection.
            </summary>
            <value>A read-only collection of the values in this dictionary.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.System#Collections#IDictionary#IsFixedSize">
            <summary>
            Returns whether this dictionary is fixed size. 
            </summary>
            <value>Always returns true.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.System#Collections#IDictionary#IsReadOnly">
            <summary>
            Returns if this dictionary is read-only. 
            </summary>
            <value>Always returns true.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.System#Collections#IDictionary#Keys">
            <summary>
            Returns a collection of all the keys in the dictionary. The values in this collection will
            be enumerated in the same order as the (overridden) GetEnumerator method.
            </summary>
            <value>The collection of keys.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.System#Collections#IDictionary#Values">
            <summary>
            Returns a collection of all the values in the dictionary. The values in this collection will
            be enumerated in the same order as the (overridden) GetEnumerator method.
            </summary>
            <value>The collection of values.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            Gets the value associated with a given key. When getting a value, if this
            key is not found in the collection, then null is returned. If the key is not of the correct type 
            for this dictionary, null is returned.
            </summary>
            <value>The value associated with the key, or null if the key was not present.</value>
            <exception cref="T:System.NotSupportedException">Always thrown from the set accessor, indicating
            that the dictionary is read only.</exception>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.KeysCollection">
            <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Keys collection. The collection is read-only.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.KeysCollection.#ctor(CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase{`0,`1})">
            <summary>
            Constructor.
            </summary>
            <param name="myDictionary">The dictionary this is associated with.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.ValuesCollection">
            <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Values collection. The collection is read-only.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.DictionaryEnumeratorWrapper">
            <summary>
            A class that wraps a IDictionaryEnumerator around an IEnumerator that
            enumerates KeyValuePairs. This is useful in implementing IDictionary, because
            IEnumerator can be implemented with an iterator, but IDictionaryEnumerator cannot.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyDictionaryBase`2.DictionaryEnumeratorWrapper.#ctor(System.Collections.Generic.IEnumerator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Constructor.
            </summary>
            <param name="enumerator">The enumerator of KeyValuePairs that is being wrapped.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2">
            <summary>
            MultiDictionaryBase is a base class that can be used to more easily implement a class
            that associates multiple values to a single key. The class implements the generic
            IDictionary&lt;TKey, ICollection&lt;TValue&gt;&gt; interface. The resulting collection
            is read-only -- items cannot be added or removed.
            </summary>
            <remarks>
            <para>To use ReadOnlyMultiDictionaryBase as a base class, the derived class must override
            Count, Contains(TKey,TValue), EnumerateKeys, and TryEnumerateValuesForKey . </para>
            </remarks>
            <typeparam name="TKey">The key type of the dictionary.</typeparam>
            <typeparam name="TValue">The value type of the dictionary.</typeparam>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.#ctor">
            <summary>
            Creates a new ReadOnlyMultiDictionaryBase. 
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.MethodModifiesCollection">
            <summary>
            Throws an NotSupportedException stating that this collection cannot be modified.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.EnumerateKeys">
            <summary>
            Enumerate all the keys in the dictionary. This method must be overridden by a derived
            class.
            </summary>
            <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the collection that
            have at least one value associated with them.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
            <summary>
            Enumerate all of the values associated with a given key. This method must be overridden
            by the derived class. If the key exists and has values associated with it, an enumerator for those
            values is returned throught <paramref name="values"/>. If the key does not exist, false is returned.
            </summary>
            <param name="key">The key to get values for.</param>
            <param name="values">If true is returned, this parameter receives an enumerators that
            enumerates the values associated with that key.</param>
            <returns>True if the key exists and has values associated with it. False otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.System#Collections#Generic#IDictionary{TKey@System#Collections#Generic#ICollection{TValue}}#Add(`0,System.Collections.Generic.ICollection{`1})">
            <summary>
            Implements IDictionary&lt;TKey, IEnumerable&lt;TValue&gt;&gt;.Add. If the 
            key is already present, and ArgumentException is thrown. Otherwise, a
            new key is added, and new values are associated with that key.
            </summary>
            <param name="key">Key to add.</param>
            <param name="values">Values to associate with that key.</param>
            <exception cref="T:System.ArgumentException">The key is already present in the dictionary.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.System#Collections#Generic#IDictionary{TKey@System#Collections#Generic#ICollection{TValue}}#Remove(`0)">
            <summary>
            Removes a key from the dictionary. This method must be overridden in the derived class.
            </summary>
            <param name="key">Key to remove from the dictionary.</param>
            <returns>True if the key was found, false otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.System#Collections#Generic#IDictionary{TKey@System#Collections#Generic#ICollection{TValue}}#TryGetValue(`0,System.Collections.Generic.ICollection{`1}@)">
            <summary>
            Determines if this dictionary contains a key equal to <paramref name="key"/>. If so, all the values
            associated with that key are returned through the values parameter. This method must be
            overridden by the derived class.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="values">Returns all values associated with key, if true was returned.</param>
            <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.ContainsKey(`0)">
            <summary>
            Determines whether a given key is found in the dictionary.
            </summary>
            <remarks>The default implementation simply calls TryGetValue.
            It may be appropriate to override this method to 
            provide a more efficient implementation.</remarks>
            <param name="key">Key to look for in the dictionary.</param>
            <returns>True if the key is present in the dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.Contains(`0,`1)">
            <summary>
            Determines if this dictionary contains a key-value pair equal to <paramref name="key"/> and 
            <paramref name="value"/>. The dictionary is not changed. This method must be overridden in the derived class.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="value">The value to search for.</param>
            <returns>True if the dictionary has associated <paramref name="value"/> with <paramref name="key"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
            <summary>
            Determines if this dictionary contains the given key and all of the values associated with that key..
            </summary>
            <param name="pair">A key and collection of values to search for.</param>
            <returns>True if the dictionary has associated all of the values in <paramref name="pair"/>.Value with <paramref name="pair"/>.Key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.EqualValues(`1,`1)">
            <summary>
            If the derived class does not use the default comparison for values, this
            methods should be overridden to compare two values for equality. This is
            used for the correct implementation of ICollection.Contains on the Values
            and KeyValuePairs collections.
            </summary>
            <param name="value1">First value to compare.</param>
            <param name="value2">Second value to compare.</param>
            <returns>True if the values are equal.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.CountValues(`0)">
            <summary>
            Gets a count of the number of values associated with a key. The
            default implementation is slow; it enumerators all of the values
            (using TryEnumerateValuesForKey) to count them. A derived class
            may be able to supply a more efficient implementation.
            </summary>
            <param name="key">The key to count values for.</param>
            <returns>The number of values associated with <paramref name="key"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.CountAllValues">
            <summary>
            Gets a total count of values in the collection. This default implementation
            is slow; it enumerates all of the keys in the dictionary and calls CountValues on each.
            A derived class may be able to supply a more efficient implementation.
            </summary>
            <returns>The total number of values associated with all keys in the dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.ToString">
            <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
            <returns>The string representation of the dictionary.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.DebuggerDisplayString">
            <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
            <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.GetEnumerator">
            <summary>
            Enumerate all the keys in the dictionary, and for each key, the collection of values for that key.
            </summary>
            <returns>An enumerator to enumerate all the key, ICollection&lt;value&gt; pairs in the dictionary.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.Count">
            <summary>
            Gets the number of keys in the dictionary. This property must be overridden
            in the derived class.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.Keys">
            <summary>
            Gets a read-only collection all the keys in this dictionary.
            </summary>
            <value>An readonly ICollection&lt;TKey&gt; of all the keys in this dictionary.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.Values">
            <summary>
            Gets a read-only collection of all the values in the dictionary. 
            </summary>
            <returns>A read-only ICollection&lt;TValue&gt; of all the values in the dictionary.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.System#Collections#Generic#IDictionary{TKey@System#Collections#Generic#ICollection{TValue}}#Values">
            <summary>
            Gets a read-only collection of all the value collections in the dictionary. 
            </summary>
            <returns>A read-only ICollection&lt;IEnumerable&lt;TValue&gt;&gt; of all the values in the dictionary.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.KeyValuePairs">
            <summary>
            Gets a read-only collection of all key-value pairs in the dictionary. If a key has multiple
            values associated with it, then a key-value pair is present for each value associated
            with the key.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.Item(`0)">
            <summary>
            Returns a collection of all of the values in the dictionary associated with <paramref name="key"/>.
            If the key is not present in the dictionary, an ICollection with no
            values is returned. The returned ICollection is read-only.
            </summary>
            <param name="key">The key to get the values associated with.</param>
            <value>An ICollection&lt;TValue&gt; with all the values associated with <paramref name="key"/>.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.System#Collections#Generic#IDictionary{TKey@System#Collections#Generic#ICollection{TValue}}#Item(`0)">
            <summary>
            Gets a collection of all the values in the dictionary associated with <paramref name="key"/>.
            If the key is not present in the dictionary, a KeyNotFound exception is thrown.
            </summary>
            <param name="key">The key to get the values associated with.</param>
            <value>An IEnumerable&lt;TValue&gt; that enumerates all the values associated with <paramref name="key"/>.</value>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The given key is not present in the dictionary.</exception>
            <exception cref="T:System.NotSupportedException">The set accessor is called.</exception>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.ValuesForKeyCollection">
            <summary>
            A private class that provides the ICollection&lt;TValue&gt; for a particular key. This is the collection
            that is returned from the indexer. The collections is read-write, live, and can be used to add, remove,
            etc. values from the multi-dictionary.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.ValuesForKeyCollection.#ctor(CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase{`0,`1},`0)">
            <summary>
            Constructor. Initializes this collection.
            </summary>
            <param name="myDictionary">Dictionary we're using.</param>
            <param name="key">The key we're looking at.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.ValuesForKeyCollection.NoValues">
            <summary>
            A simple function that returns an IEnumerator&lt;TValue&gt; that
            doesn't yield any values. A helper.
            </summary>
            <returns>An IEnumerator&lt;TValue&gt; that yields no values.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.ValuesForKeyCollection.GetEnumerator">
            <summary>
            Enumerate all the values associated with key.
            </summary>
            <returns>An IEnumerator&lt;TValue&gt; that enumerates all the values associated with key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.ValuesForKeyCollection.Contains(`1)">
            <summary>
            Determines if the given values is associated with key.
            </summary>
            <param name="item">Value to check for.</param>
            <returns>True if value is associated with key, false otherwise.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.ValuesForKeyCollection.Count">
            <summary>
            Get the number of values associated with the key.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.KeysCollection">
            <summary>
            A private class that implements ICollection&lt;TKey&gt; and ICollection for the
            Keys collection. The collection is read-only.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.KeysCollection.#ctor(CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase{`0,`1})">
            <summary>
            Constructor.
            </summary>
            <param name="myDictionary">The dictionary this is associated with.</param>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.ValuesCollection">
            <summary>
            A private class that implements ICollection&lt;TValue&gt; and ICollection for the
            Values collection. The collection is read-only.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.EnumerableValuesCollection">
            <summary>
            A private class that implements ICollection&lt;IEnumerable&lt;TValue&gt;&gt; and ICollection for the
            Values collection on IDictionary. The collection is read-only.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.ReadOnlyMultiDictionaryBase`2.KeyValuePairsCollection">
            <summary>
            A private class that implements ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; and ICollection for the
            KeyValuePairs collection. The collection is read-only.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.DuplicatePolicy">
            <summary>
            Describes what to do if a key is already in the tree when doing an
            insertion.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.RedBlackTree`1">
             <summary>
             The base implementation for various collections classes that use Red-Black trees
             as part of their implementation. This class should not (and can not) be 
             used directly by end users; it's only for internal use by the collections package.
             </summary>
             <remarks>
             The Red-Black tree manages items of type T, and uses a IComparer&lt;T&gt; that
             compares items to sort the tree. Multiple items can compare equal and be stored
             in the tree. Insert, Delete, and Find operations are provided in their full generality;
             all operations allow dealing with either the first or last of items that compare equal. 
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.GetNodeStack">
            <summary>
            Create an array of Nodes big enough for any path from top 
            to bottom. This is cached, and reused from call-to-call, so only one
            can be around at a time per tree.
            </summary>
            <returns>The node stack.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.StopEnumerations">
            <summary>
            Must be called whenever there is a structural change in the tree. Causes
            changeStamp to be changed, which causes any in-progress enumerations
            to throw exceptions.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.CheckEnumerationStamp(System.Int32)">
            <summary>
            Checks the given stamp against the current change stamp. If different, the
            collection has changed during enumeration and an InvalidOperationException
            must be thrown
            </summary>
            <param name="startStamp">changeStamp at the start of the enumeration.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Initialize a red-black tree, using the given interface instance to compare elements. Only
            Compare is used on the IComparer interface.
            </summary>
            <param name="comparer">The IComparer&lt;T&gt; used to sort keys.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.Clone">
            <summary>
            Clone the tree, returning a new tree containing the same items. Should
            take O(N) take.
            </summary>
            <returns>Clone version of this tree.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.Find(`0,System.Boolean,System.Boolean,`0@)">
            <summary>
            Finds the key in the tree. If multiple items in the tree have
            compare equal to the key, finds the first or last one. Optionally replaces the item
            with the one searched for.
            </summary>
            <param name="key">Key to search for.</param>
            <param name="findFirst">If true, find the first of duplicates, else finds the last of duplicates.</param>
            <param name="replace">If true, replaces the item with key (if function returns true)</param>
            <param name="item">Returns the found item, before replacing (if function returns true).</param>
            <returns>True if the key was found.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.FindIndex(`0,System.Boolean)">
            <summary>
            Finds the index of the key in the tree. If multiple items in the tree have
            compare equal to the key, finds the first or last one. 
            </summary>
            <param name="key">Key to search for.</param>
            <param name="findFirst">If true, find the first of duplicates, else finds the last of duplicates.</param>
            <returns>Index of the item found if the key was found, -1 if not found.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.GetItemByIndex(System.Int32)">
            <summary>
            Find the item at a particular index in the tree.
            </summary>
            <param name="index">The zero-based index of the item. Must be &gt;= 0 and &lt; Count.</param>
            <returns>The item at the particular index.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.Insert(`0,CodeSmith.Engine.PowerCollections.DuplicatePolicy,`0@)">
            <summary>
            Insert a new node into the tree, maintaining the red-black invariants.
            </summary>
            <remarks>Algorithm from Sedgewick, "Algorithms".</remarks>
            <param name="item">The new item to insert</param>
            <param name="dupPolicy">What to do if equal item is already present.</param>
            <param name="previous">If false, returned, the previous item.</param>
            <returns>false if duplicate exists, otherwise true.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.InsertSplit(CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.Node,CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.Node,CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.Node,CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.Node,System.Boolean@)">
            <summary>
            Split a node with two red children (a 4-node in the 2-3-4 tree formalism), as
            part of an insert operation.
            </summary>
            <param name="ggparent">great grand-parent of "node", can be null near root</param>
            <param name="gparent">grand-parent of "node", can be null near root</param>
            <param name="parent">parent of "node", can be null near root</param>
            <param name="node">Node to split, can't be null</param>
            <param name="rotated">Indicates that rotation(s) occurred in the tree.</param>
            <returns>Node to continue searching from.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.Rotate(CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.Node,CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.Node,CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.Node)">
            <summary>
            Performs a rotation involving the node, it's child and grandchild. The counts of 
            childs and grand-child are set the correct values from their children; this is important
            if they have been adjusted on the way down the try as part of an insert/delete.
            </summary>
            <param name="node">Top node of the rotation. Can be null if child==root.</param>
            <param name="child">One child of "node". Not null.</param>
            <param name="gchild">One child of "child". Not null.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.Delete(`0,System.Boolean,`0@)">
            <summary>
            Deletes a key from the tree. If multiple elements are equal to key, 
            deletes the first or last. If no element is equal to the key, 
            returns false.
            </summary>
            <remarks>Top-down algorithm from Weiss. Basic plan is to move down in the tree, 
            rotating and recoloring along the way to always keep the current node red, which 
            ensures that the node we delete is red. The details are quite complex, however! </remarks>
            <param name="key">Key to delete.</param>
            <param name="deleteFirst">Which item to delete if multiple are equal to key. True to delete the first, false to delete last.</param>
            <param name="item">Returns the item that was deleted, if true returned.</param>
            <returns>True if an element was deleted, false if no element had 
            specified key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.GetEnumerator">
            
            <summary>
            Enumerate all the items in-order
            </summary>
            <returns>An enumerator for all the items, in order.</returns>
            <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerate all the items in-order
            </summary>
            <returns>An enumerator for all the items, in order.</returns>
            <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.BoundedRangeTester(System.Boolean,`0,System.Boolean,`0)">
            <summary>
            Gets a range tester that defines a range by first and last items.
            </summary>
            <param name="useFirst">If true, bound the range on the bottom by first.</param>
            <param name="first">If useFirst is true, the inclusive lower bound.</param>
            <param name="useLast">If true, bound the range on the top by last.</param>
            <param name="last">If useLast is true, the exclusive upper bound.</param>
            <returns>A RangeTester delegate that tests for an item in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.DoubleBoundedRangeTester(`0,System.Boolean,`0,System.Boolean)">
            <summary>
            Gets a range tester that defines a range by first and last items.
            </summary>
            <param name="first">The lower bound.</param>
            <param name="firstInclusive">True if the lower bound is inclusive, false if exclusive.</param>
            <param name="last">The upper bound.</param>
            <param name="lastInclusive">True if the upper bound is inclusive, false if exclusive.</param>
            <returns>A RangeTester delegate that tests for an item in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.LowerBoundedRangeTester(`0,System.Boolean)">
            <summary>
            Gets a range tester that defines a range by a lower bound.
            </summary>
            <param name="first">The lower bound.</param>
            <param name="inclusive">True if the lower bound is inclusive, false if exclusive.</param>
            <returns>A RangeTester delegate that tests for an item in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.UpperBoundedRangeTester(`0,System.Boolean)">
            <summary>
            Gets a range tester that defines a range by upper bound.
            </summary>
            <param name="last">The upper bound.</param>
            <param name="inclusive">True if the upper bound is inclusive, false if exclusive.</param>
            <returns>A RangeTester delegate that tests for an item in the given range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.EqualRangeTester(`0)">
            <summary>
            Gets a range tester that defines a range by all items equal to an item.
            </summary>
            <param name="equalTo">The item that is contained in the range.</param>
            <returns>A RangeTester delegate that tests for an item equal to <paramref name="equalTo"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.EntireRangeTester(`0)">
            <summary>
            A range tester that defines a range that is the entire tree.
            </summary>
            <param name="item">Item to test.</param>
            <returns>Always returns 0.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.EnumerateRange(CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.RangeTester)">
            <summary>
            Enumerate the items in a custom range in the tree. The range is determined by 
            a RangeTest delegate.
            </summary>
            <param name="rangeTester">Tests an item against the custom range.</param>
            <returns>An IEnumerable&lt;T&gt; that enumerates the custom range in order.</returns>
            <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.EnumerateRangeInOrder(CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.RangeTester,CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.Node)">
            <summary>
            Enumerate all the items in a custom range, under and including node, in-order.
            </summary>
            <param name="rangeTester">Tests an item against the custom range.</param>
            <param name="node">Node to begin enumeration. May be null.</param>
            <returns>An enumerable of the items.</returns>
            <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.EnumerateRangeReversed(CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.RangeTester)">
            <summary>
            Enumerate the items in a custom range in the tree, in reversed order. The range is determined by 
            a RangeTest delegate.
            </summary>
            <param name="rangeTester">Tests an item against the custom range.</param>
            <returns>An IEnumerable&lt;T&gt; that enumerates the custom range in reversed order.</returns>
            <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.EnumerateRangeInReversedOrder(CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.RangeTester,CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.Node)">
            <summary>
            Enumerate all the items in a custom range, under and including node, in reversed order.
            </summary>
            <param name="rangeTester">Tests an item against the custom range.</param>
            <param name="node">Node to begin enumeration. May be null.</param>
            <returns>An enumerable of the items, in reversed oreder.</returns>
            <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.DeleteItemFromRange(CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.RangeTester,System.Boolean,`0@)">
            <summary>
            Deletes either the first or last item from a range, as identified by a RangeTester
            delegate. If the range is empty, returns false.
            </summary>
            <remarks>Top-down algorithm from Weiss. Basic plan is to move down in the tree, 
            rotating and recoloring along the way to always keep the current node red, which 
            ensures that the node we delete is red. The details are quite complex, however! </remarks>
            <param name="rangeTester">Range to delete from.</param>
            <param name="deleteFirst">If true, delete the first item from the range, else the last.</param>
            <param name="item">Returns the item that was deleted, if true returned.</param>
            <returns>True if an element was deleted, false if the range is empty.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.DeleteRange(CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.RangeTester)">
            <summary>
            Delete all the items in a range, identified by a RangeTester delegate.
            </summary>
            <param name="rangeTester">The delegate that defines the range to delete.</param>
            <returns>The number of items deleted.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.CountRange(CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.RangeTester)">
            <summary>
            Count the items in a custom range in the tree. The range is determined by 
            a RangeTester delegate.
            </summary>
            <param name="rangeTester">The delegate that defines the range.</param>
            <returns>The number of items in the range.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.CountRangeUnderNode(CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.RangeTester,CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.Node,System.Boolean,System.Boolean)">
            <summary>
            Count all the items in a custom range, under and including node.
            </summary>
            <param name="rangeTester">The delegate that defines the range.</param>
            <param name="node">Node to begin enumeration. May be null.</param>
            <param name="belowRangeTop">This node and all under it are either in the range or below it.</param>
            <param name="aboveRangeBottom">This node and all under it are either in the range or above it.</param>
            <returns>The number of items in the range, under and include node.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.FirstItemInRange(CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.RangeTester,`0@)">
            <summary>
            Find the first item in a custom range in the tree, and it's index. The range is determined
            by a RangeTester delegate.
            </summary>
            <param name="rangeTester">The delegate that defines the range.</param>
            <param name="item">Returns the item found, if true was returned.</param>
            <returns>Index of first item in range if range is non-empty, -1 otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.LastItemInRange(CodeSmith.Engine.PowerCollections.RedBlackTree{`0}.RangeTester,`0@)">
            <summary>
            Find the last item in a custom range in the tree, and it's index. The range is determined
            by a RangeTester delegate.
            </summary>
            <param name="rangeTester">The delegate that defines the range.</param>
            <param name="item">Returns the item found, if true was returned.</param>
            <returns>Index of the item if range is non-empty, -1 otherwise.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.RedBlackTree`1.ElementCount">
            <summary>
            Returns the number of elements in the tree.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.RedBlackTree`1.Node">
            <summary>
            The class that is each node in the red-black tree.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.Node.IncrementCount">
            <summary>
            Add one to the Count.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.Node.DecrementCount">
            <summary>
            Subtract one from the Count. The current
            Count must be non-zero.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.RedBlackTree`1.Node.Clone">
            <summary>
            Clones a node and all its descendants.
            </summary>
            <returns>The cloned node.</returns>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.RedBlackTree`1.Node.IsRed">
            <summary>
            Is this a red node?
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.RedBlackTree`1.Node.Count">
            <summary>
            Get or set the Count field -- a 31-bit field
            that holds the number of nodes at or below this
            level.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.RedBlackTree`1.RangeTester">
            <summary>
            A delegate that tests if an item is within a custom range. The range must be a contiguous
            range of items with the ordering of this tree. The range test function must test
            if an item is before, withing, or after the range.
            </summary>
            <param name="item">Item to test against the range.</param>
            <returns>Returns negative if item is before the range, zero if item is withing the range,
            and positive if item is after the range.</returns>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Set`1">
             <summary>
             Set&lt;T&gt; is a collection that contains items of type T. 
             The item are maintained in a haphazard, unpredictable order, and duplicate items are not allowed.
             </summary>
             <remarks>
             <p>The items are compared in one of two ways. If T implements IComparable&lt;T&gt; 
             then the Equals method of that interface will be used to compare items, otherwise the Equals
             method from Object will be used. Alternatively, an instance of IComparer&lt;T&gt; can be passed
             to the constructor to use to compare items.</p>
             <p>Set is implemented as a hash table. Inserting, deleting, and looking up an
             an element all are done in approximately constant time, regardless of the number of items in the Set.</p>
             <p><see cref="T:CodeSmith.Engine.PowerCollections.OrderedSet`1"/> is similar, but uses comparison instead of hashing, and does maintains
             the items in sorted order.</p>
            </remarks>
            <seealso cref="T:CodeSmith.Engine.PowerCollections.OrderedSet`1"/>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.#ctor">
             <summary>
             Creates a new Set. The Equals method and GetHashCode method on T
             will be used to compare items for equality.
             </summary>
            <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new Set. The Equals and GetHashCode method of the passed comparer object
            will be used to compare items in this set.
            </summary>
            <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Creates a new Set. The Equals method and GetHashCode method on T
             will be used to compare items for equality.
             </summary>
            <remarks>
             Items that are null are permitted.
            </remarks>
             <param name="collection">A collection with items to be placed into the Set.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new Set. The Equals and GetHashCode method of the passed comparer object
            will be used to compare items in this set. The set is
            initialized with all the items in the given collection.
            </summary>
            <param name="collection">A collection with items to be placed into the Set.</param>
            <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},CodeSmith.Engine.PowerCollections.Hash{`0})">
            <summary>
            Creates a new Set given a comparer and a tree that contains the data. Used
            internally for Clone.
            </summary>
            <param name="equalityComparer">EqualityComparer for the set.</param>
            <param name="hash">Data for the set.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.System#ICloneable#Clone">
            <summary>
            Makes a shallow clone of this set; i.e., if items of the
            set are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
            <remarks>Cloning the set takes time O(N), where N is the number of items in the set.</remarks>
            <returns>The cloned set.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.Clone">
            <summary>
            Makes a shallow clone of this set; i.e., if items of the
            set are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
            <remarks>Cloning the set takes time O(N), where N is the number of items in the set.</remarks>
            <returns>The cloned set.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.CloneContents">
            <summary>
            Makes a deep clone of this set. A new set is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
            <remarks><para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
            <para>Cloning the set takes time O(N), where N is the number of items in the set.</para></remarks>
            <returns>The cloned set.</returns>
            <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.GetEnumerator">
            <summary>
            Returns an enumerator that enumerates all the items in the set. 
            The items are enumerated in sorted order.
            </summary>
            <remarks>
            <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
            <p>If an item is added to or deleted from the set while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
            <p>Enumerating all the items in the set takes time O(N), where N is the number
            of items in the set.</p>
            </remarks>
            <returns>An enumerator for enumerating all the items in the Set.</returns>		
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.Contains(`0)">
            <summary>
            Determines if this set contains an item equal to <paramref name="item"/>. The set
            is not changed.
            </summary>
            <remarks>Searching the set for an item takes approximately constant time, regardless of the number of items in the set.</remarks>
            <param name="item">The item to search for.</param>
            <returns>True if the set contains <paramref name="item"/>. False if the set does not contain <paramref name="item"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.TryGetItem(`0,`0@)">
            <summary>
            <para>Determines if this set contains an item equal to <paramref name="item"/>, according to the 
            comparison mechanism that was used when the set was created. The set
            is not changed.</para>
            <para>If the set does contain an item equal to <paramref name="item"/>, then the item from the set is returned.</para>
            </summary>
            <remarks>Searching the set for an item takes approximately constant time, regardless of the number of items in the set.</remarks>
            <example>
            In the following example, the set contains strings which are compared in a case-insensitive manner. 
            <code>
            Set&lt;string&gt; set = new Set&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase);
            set.Add("HELLO");
            string s;
            bool b = set.TryGetItem("Hello", out s);   // b receives true, s receives "HELLO".
            </code>
            </example>
            <param name="item">The item to search for.</param>
            <param name="foundItem">Returns the item from the set that was equal to <paramref name="item"/>.</param>
            <returns>True if the set contains <paramref name="item"/>. False if the set does not contain <paramref name="item"/>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.Add(`0)">
            <summary>
            Adds a new item to the set. If the set already contains an item equal to
            <paramref name="item"/>, that item is replaced with <paramref name="item"/>.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
            <para>Adding an item takes approximately constant time, regardless of the number of items in the set.</para></remarks>
            <param name="item">The item to add to the set.</param>
            <returns>True if the set already contained an item equal to <paramref name="item"/> (which was replaced), false 
            otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Adds a new item to the set. If the set already contains an item equal to
            <paramref name="item"/>, that item is replaced with <paramref name="item"/>.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
            <para>Adding an item takes approximately constant time, regardless of the number of items in the set.</para></remarks>
            <param name="item">The item to add to the set.</param>
            <returns>True if the set already contained an item equal to <paramref name="item"/> (which was replaced), false 
            otherwise.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds all the items in <paramref name="collection"/> to the set. If the set already contains an item equal to
            one of the items in <paramref name="collection"/>, that item will be replaced.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
            <para>Adding the collection takes time O(M), where M is the 
            number of items in <paramref name="collection"/>.</para></remarks>
            <param name="collection">A collection of items to add to the set.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.Remove(`0)">
            <summary>
            Searches the set for an item equal to <paramref name="item"/>, and if found,
            removes it from the set. If not found, the set is unchanged.
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
            <para>Removing an item from the set takes approximately constant time, regardless of the size of the set.</para></remarks>
            <param name="item">The item to remove.</param>
            <returns>True if <paramref name="item"/> was found and removed. False if <paramref name="item"/> was not in the set.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes all the items in <paramref name="collection"/> from the set. 
            </summary>
            <remarks>
            <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
            <para>Removing the collection takes time O(M), where M is the 
            number of items in <paramref name="collection"/>.</para></remarks>
            <param name="collection">A collection of items to remove from the set.</param>
            <returns>The number of items removed from the set.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.Clear">
            <summary>
            Removes all items from the set.
            </summary>
            <remarks>Clearing the set takes a constant amount of time, regardless of the number of items in it.</remarks>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.CheckConsistentComparison(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Check that this set and another set were created with the same comparison
            mechanism. Throws exception if not compatible.
            </summary>
            <param name="otherSet">Other set to check comparision mechanism.</param>
            <exception cref="T:System.InvalidOperationException">If otherSet and this set don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.IsSupersetOf(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Determines if this set is a superset of another set. Neither set is modified.
            This set is a superset of <paramref name="otherSet"/> if every element in
            <paramref name="otherSet"/> is also in this set.
            <remarks>IsSupersetOf is computed in time O(M), where M is the size of the 
            <paramref name="otherSet"/>.</remarks>
            </summary>
            <param name="otherSet">Set to compare to.</param>
            <returns>True if this is a superset of <paramref name="otherSet"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.IsProperSupersetOf(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Determines if this set is a proper superset of another set. Neither set is modified.
            This set is a proper superset of <paramref name="otherSet"/> if every element in
            <paramref name="otherSet"/> is also in this set.
            Additionally, this set must have strictly more items than <paramref name="otherSet"/>.
            </summary>
            <remarks>IsProperSubsetOf is computed in time O(M), where M is the size of
            <paramref name="otherSet"/>.</remarks>
            <param name="otherSet">Set to compare to.</param>
            <returns>True if this is a proper superset of <paramref name="otherSet"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.IsSubsetOf(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Determines if this set is a subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet"/> if every element in this set
            is also in <paramref name="otherSet"/>.
            </summary>
            <remarks>IsSubsetOf is computed in time O(N), where N is the size of the this set.</remarks>
            <param name="otherSet">Set to compare to.</param>
            <returns>True if this is a subset of <paramref name="otherSet"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.IsProperSubsetOf(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Determines if this set is a proper subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet"/> if every element in this set
            is also in <paramref name="otherSet"/>. Additionally, this set must have strictly 
            fewer items than <paramref name="otherSet"/>.
            </summary>
            <remarks>IsProperSubsetOf is computed in time O(N), where N is the size of the this set.</remarks>
            <param name="otherSet">Set to compare to.</param>
            <returns>True if this is a proper subset of <paramref name="otherSet"/>.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.IsEqualTo(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Determines if this set is equal to another set. This set is equal to
            <paramref name="otherSet"/> if they contain the same items.
            </summary>
            <remarks>IsEqualTo is computed in time O(N), where N is the number of items in 
            this set.</remarks>
            <param name="otherSet">Set to compare to</param>
            <returns>True if this set is equal to <paramref name="otherSet"/>, false otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.IsDisjointFrom(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Determines if this set is disjoint from another set. Two sets are disjoint
            if no item from one set is equal to any item in the other set.
            </summary>
            <remarks>
            <para>The answer is computed in time O(N), where N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to check disjointness with.</param>
            <returns>True if the two sets are disjoint, false otherwise.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.UnionWith(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. This set receives
            the union of the two sets, the other set is unchanged.
            </summary>
            <remarks>
            <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The union of two sets is computed in time O(M + N), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to union with.</param>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.Union(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. A new set is 
            created with the union of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
            <remarks>
            <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The union of two sets is computed in time O(M + N), where M is the size of the 
            one set, and N is the size of the other set.</para>
            </remarks>
            <param name="otherSet">Set to union with.</param>
            <returns>The union of the two sets.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.IntersectionWith(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. This set receives
            the intersection of the two sets, the other set is unchanged.
            </summary>
            <remarks>
            <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The intersection of two sets is computed in time O(N), where N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to intersection with.</param>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.Intersection(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. A new set is 
            created with the intersection of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
            <remarks>
            <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
            <para>The intersection of two sets is computed in time O(N), where N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to intersection with.</param>
            <returns>The intersection of the two sets.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.DifferenceWith(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet"/>. This set receives
            the difference of the two sets; the other set is unchanged.
            </summary>
            <remarks>
            <para>The difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to difference with.</param>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.Difference(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet"/>. A new set is 
            created with the difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
            <remarks>
            <para>The difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to difference with.</param>
            <returns>The difference of the two sets.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.SymmetricDifferenceWith(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. This set receives
            the symmetric difference of the two sets; the other set is unchanged.
            </summary>
            <remarks>
            <para>The symmetric difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to symmetric difference with.</param>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Set`1.SymmetricDifference(CodeSmith.Engine.PowerCollections.Set{`0})">
            <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. A new set is 
            created with the symmetric difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
            <remarks>
            <para>The symmetric difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
            </remarks>
            <param name="otherSet">Set to symmetric difference with.</param>
            <returns>The symmetric difference of the two sets.</returns>
            <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet"/> don't use the same method for comparing items.</exception>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.Set`1.Comparer">
            <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare items in this set. 
            </summary>
            <value>If the set was created using a comparer, that comparer is returned. Otherwise
            the default comparer for T (EqualityComparer&lt;T&gt;.Default) is returned.</value>
        </member>
        <member name="P:CodeSmith.Engine.PowerCollections.Set`1.Count">
            <summary>
            Returns the number of items in the set.
            </summary>
            <remarks>The size of the set is returned in constant time.</remarks>
            <value>The number of items in the set.</value>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Strings">
            <summary>
            A holder class for localizable strings that are used. Currently, these are not loaded from resources, but 
            just coded into this class. To make this library localizable, simply change this class to load the
            given strings from resources.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Triple`3">
            <summary>
            Stores a triple of objects within a single struct. This struct is useful to use as the
            T of a collection, or as the TKey or TValue of a dictionary.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.PowerCollections.Triple`3.firstComparer">
            <summary>
            Comparers for the first and second type that are used to compare
            values.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.PowerCollections.Triple`3.First">
            <summary>
            The first element of the triple.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.PowerCollections.Triple`3.Second">
            <summary>
            The second element of the triple.
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.PowerCollections.Triple`3.Third">
            <summary>
            The thrid element of the triple.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Triple`3.#ctor(`0,`1,`2)">
            <summary>
            Creates a new triple with given elements.
            </summary>
            <param name="first">The first element of the triple.</param>
            <param name="second">The second element of the triple.</param>
            <param name="third">The third element of the triple.</param>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Triple`3.Equals(System.Object)">
            <summary>
            Determines if this triple is equal to another object. The triple is equal to another object 
            if that object is a Triple, all element types are the same, and the all three elements
            compare equal using object.Equals.
            </summary>
            <param name="obj">Object to compare for equality.</param>
            <returns>True if the objects are equal. False if the objects are not equal.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Triple`3.Equals(CodeSmith.Engine.PowerCollections.Triple{`0,`1,`2})">
            <summary>
            Determines if this triple is equal to another triple. Two triples are equal if the all three elements
            compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
            <param name="other">Triple to compare with for equality.</param>
            <returns>True if the triples are equal. False if the triples are not equal.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Triple`3.GetHashCode">
            <summary>
            Returns a hash code for the triple, suitable for use in a hash-table or other hashed collection.
            Two triples that compare equal (using Equals) will have the same hash code. The hash code for
            the triple is derived by combining the hash codes for each of the two elements of the triple.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Triple`3.CompareTo(CodeSmith.Engine.PowerCollections.Triple{`0,`1,`2})">
            <summary>
            <para> Compares this triple to another triple of the some type. The triples are compared by using
            the IComparable&lt;T&gt; or IComparable interface on TFirst, TSecond, and TThird. The triples
            are compared by their first elements first, if their first elements are equal, then they
            are compared by their second elements. If their second elements are also equal, then they
            are compared by their third elements.</para>
            <para>If TFirst, TSecond, or TThird does not implement IComparable&lt;T&gt; or IComparable, then
            an NotSupportedException is thrown, because the triples cannot be compared.</para>
            </summary>
            <param name="other">The triple to compare to.</param>
            <returns>An integer indicating how this triple compares to <paramref name="other"/>. Less
            than zero indicates this triple is less than <paramref name="other"/>. Zero indicate this triple is
            equals to <paramref name="other"/>. Greater than zero indicates this triple is greater than
            <paramref name="other"/>.</returns>
            <exception cref="T:System.NotSupportedException">Either FirstSecond, TSecond, or TThird is not comparable
            via the IComparable&lt;T&gt; or IComparable interfaces.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Triple`3.System#IComparable#CompareTo(System.Object)">
            <summary>
            <para> Compares this triple to another triple of the some type. The triples are compared by using
            the IComparable&lt;T&gt; or IComparable interface on TFirst, TSecond, and TThird. The triples
            are compared by their first elements first, if their first elements are equal, then they
            are compared by their second elements. If their second elements are also equal, then they
            are compared by their third elements.</para>
            <para>If TFirst, TSecond, or TThird does not implement IComparable&lt;T&gt; or IComparable, then
            an NotSupportedException is thrown, because the triples cannot be compared.</para>
            </summary>
            <param name="obj">The triple to compare to.</param>
            <returns>An integer indicating how this triple compares to <paramref name="obj"/>. Less
            than zero indicates this triple is less than <paramref name="obj"/>. Zero indicate this triple is
            equals to <paramref name="obj"/>. Greater than zero indicates this triple is greater than
            <paramref name="obj"/>.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is not of the correct type.</exception>
            <exception cref="T:System.NotSupportedException">Either FirstSecond, TSecond, or TThird is not comparable
            via the IComparable&lt;T&gt; or IComparable interfaces.</exception>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Triple`3.ToString">
            <summary>
            Returns a string representation of the triple. The string representation of the triple is
            of the form:
            <c>First: {0}, Second: {1}, Third: {2}</c>
            where {0} is the result of First.ToString(), {1} is the result of Second.ToString(), and
            {2} is the result of Third.ToString() (or "null" if they are null.)
            </summary>
            <returns> The string representation of the triple.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Triple`3.op_Equality(CodeSmith.Engine.PowerCollections.Triple{`0,`1,`2},CodeSmith.Engine.PowerCollections.Triple{`0,`1,`2})">
            <summary>
            Determines if two triples are equal. Two triples are equal if the all three elements
            compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
            <param name="pair1">First triple to compare.</param>
            <param name="pair2">Second triple to compare.</param>
            <returns>True if the triples are equal. False if the triples are not equal.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Triple`3.op_Inequality(CodeSmith.Engine.PowerCollections.Triple{`0,`1,`2},CodeSmith.Engine.PowerCollections.Triple{`0,`1,`2})">
            <summary>
            Determines if two triples are not equal. Two triples are equal if the all three elements
            compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
            <param name="pair1">First triple to compare.</param>
            <param name="pair2">Second triple to compare.</param>
            <returns>True if the triples are not equal. False if the triples are equal.</returns>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Util">
            <summary>
            A holder class for various internal utility functions that need to be shared.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Util.IsCloneableType(System.Type,System.Boolean@)">
            <summary>
            Determine if a type is cloneable: either a value type or implementing
            ICloneable.
            </summary>
            <param name="type">Type to check.</param>
            <param name="isValue">Returns if the type is a value type, and does not implement ICloneable.</param>
            <returns>True if the type is cloneable.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Util.SimpleClassName(System.Type)">
            <summary>
            Returns the simple name of the class, for use in exception messages. 
            </summary>
            <returns>The simple name of this class.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Util.CreateEnumerableWrapper``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Wrap an enumerable so that clients can't get to the underlying
            implementation via a down-case
            </summary>
            <param name="wrapped">Enumerable to wrap.</param>
            <returns>A wrapper around the enumerable.</returns>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Util.GetHashCode``1(``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets the hash code for an object using a comparer. Correctly handles
            null.
            </summary>
            <param name="item">Item to get hash code for. Can be null.</param>
            <param name="equalityComparer">The comparer to use.</param>
            <returns>The hash code for the item.</returns>
        </member>
        <member name="T:CodeSmith.Engine.PowerCollections.Util.WrapEnumerable`1">
            <summary>
            Wrap an enumerable so that clients can't get to the underlying 
            implementation via a down-cast.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PowerCollections.Util.WrapEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create the wrapper around an enumerable.
            </summary>
            <param name="wrapped">IEnumerable to wrap.</param>
        </member>
        <member name="T:CodeSmith.Engine.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.IPropertyRefresher">
            <summary>
            Interface that all property refreshers must implement.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.PropertyRefresherContext">
            <summary>
            Context information passed into the IPropertyRefresher methods.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.PropertyRefresherContext.PropertyInfo">
            <summary>
            The property that the context points to.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.PropertyRefresherContext.Instance">
            <summary>
            The CodeTemplate instance that the context points to.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.PropertyRefresherContext.WorkingDirectory">
            <summary>
            The working directory for resolving and creating relative paths.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Schema.CodeSmithProject.SaveFile(System.String)">
            <summary>
            Saves the project to a file.
            </summary>
            <param name="fileName">Name of the file.</param>
        </member>
        <member name="M:CodeSmith.Engine.Schema.CodeSmithProject.SaveFile(System.String,System.Boolean)">
            <summary>
            Saves the project to a file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="relativePaths">if set to <c>true</c> make paths relative.</param>
        </member>
        <member name="M:CodeSmith.Engine.Schema.CodeSmithProject.SaveToString">
            <summary>
            Saves project to string.
            </summary>
            <returns>An XML string of the project.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Schema.CodeSmithProject.SaveToString(System.Boolean)">
            <summary>
            Saves project to string.
            </summary>
            <param name="applyVariables">if set to <c>true</c> apply variables.</param>
            <returns>An XML string of the project.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Schema.CodeSmithProject.MakePathsRelative">
            <summary>
            Makes the paths relative to the directory of <see cref="P:CodeSmith.Engine.Schema.CodeSmithProject.FileName"/>.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Schema.CodeSmithProject.InsertVariables(CodeSmith.Engine.Schema.CodeSmithProject)">
            <summary>
            Inserts variables into the property set where the value matchs.
            </summary>
            <param name="csp">The original project.</param>
            <returns>A new instance of CodeSmithProject.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Schema.CodeSmithProject.ReplaceVariables(CodeSmith.Engine.Schema.CodeSmithProject)">
            <summary>
            Replaces variables in the property set with the variables value.
            </summary>
            <param name="csp">The original project.</param>
            <returns>A new instance of CodeSmithProject.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Schema.CodeSmithProject.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.Schema.CodeSmithProject.LoadFile(System.String)">
            <summary>
            Loads the project from a file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.Schema.CodeSmithProject.LoadFile(System.String,System.Boolean)">
            <summary>
            Loads the project from a file.
            </summary>
            <param name="fileName">Name of the file.</param>
            <param name="replaceVariables">if set to <c>true</c> replace variables.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.Schema.CodeSmithProject.LoadFromString(System.String)">
            <summary>
            Loads the project from a string.
            </summary>
            <param name="xmlFragment">The XML fragment.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.Schema.CodeSmithProject.LoadFromString(System.String,System.Boolean)">
            <summary>
            Loads from string.
            </summary>
            <param name="xmlFragment">The XML fragment.</param>
            <param name="replaceVariables">if set to <c>true</c> replace variables.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.Schema.CodeSmithProject.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:CodeSmith.Engine.Schema.CodeSmithProject.SingleOutput">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.CodeSmithProject.DefaultTemplate">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.CodeSmithProject.Variables">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.CodeSmithProject.DefaultProperties">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.CodeSmithProject.PropertySets">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.DefaultTemplate.Path">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.Property.ChildNodes">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.Property.Name">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.Property.Value">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.PropertySet.Properties">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.PropertySet.Name">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.PropertySet.Enabled">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.PropertySet.Output">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.PropertySet.Template">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.PropertySet.MergeType">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.PropertySet.MergeInit">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.SingleOutput.Path">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.Variable.Key">
            <remarks/>
        </member>
        <member name="P:CodeSmith.Engine.Schema.Variable.Value">
            <remarks/>
        </member>
        <member name="T:CodeSmith.Engine.IPropertySerializer">
            <summary>
            Interface that all property serializers must implement.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.IPropertySerializer.SaveProperty(CodeSmith.Engine.PropertySerializerContext,System.Object)">
            <summary>
            This method will be used to save the property value when a template is being compiled.
            </summary>
            <param name="context">Context information of the target property.</param>
            <param name="propertyValue">The property to be saved.</param>
            <returns>An object that will be stored in a Hashtable during template compilation.</returns>
        </member>
        <member name="M:CodeSmith.Engine.IPropertySerializer.LoadProperty(CodeSmith.Engine.PropertySerializerContext,System.Object)">
            <summary>
            This method will be used to restore the property value after a template has been compiled.
            </summary>
            <param name="context">Context information of the target property.</param>
            <param name="propertyValue">The property to be loaded.</param>
            <returns>The value to be assigned to the template property after it has been compiled.</returns>
        </member>
        <member name="M:CodeSmith.Engine.IPropertySerializer.WritePropertyXml(CodeSmith.Engine.PropertySerializerContext,System.Xml.XmlWriter,System.Object)">
            <summary>
            This method will be used when serializing the property value to an XML property set.
            </summary>
            <param name="context">Context information of the target property.</param>
            <param name="writer">The XML writer that the property value will be written to.</param>
            <param name="propertyValue">The property to be serialized.</param>
        </member>
        <member name="M:CodeSmith.Engine.IPropertySerializer.ReadPropertyXml(CodeSmith.Engine.PropertySerializerContext,System.Xml.XmlNode)">
            <summary>
            This method will be used when deserializing the property from an XML property set.
            </summary>
            <param name="context">Context information of the target property.</param>
            <param name="propertyValue">The XML node to read the property value from.</param>
            <returns>The value to be assigned to the template property.</returns>
        </member>
        <member name="M:CodeSmith.Engine.IPropertySerializer.ParseDefaultValue(CodeSmith.Engine.PropertySerializerContext,System.String)">
            <summary>
            This method will be used to parse a default value for a property when a template is being instantiated.
            </summary>
            <param name="context">Context information of the target property.</param>
            <param name="defaultValue">The default value.</param>
            <returns>An object that will be assigned to the template property.</returns>
        </member>
        <member name="T:CodeSmith.Engine.PropertySerializerContext">
            <summary>
            Context information passed into the IPropertySerializer methods.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.PropertySerializerContext.#ctor(System.Reflection.PropertyInfo,CodeSmith.Engine.CodeTemplate)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.PropertySerializerContext"/> class.
            </summary>
            <param name="propertyInfo">The property that the context points to.</param>
            <param name="instance">The CodeTemplate instance that the context points to.</param>
        </member>
        <member name="M:CodeSmith.Engine.PropertySerializerContext.#ctor(System.Reflection.PropertyInfo,CodeSmith.Engine.CodeTemplate,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.PropertySerializerContext"/> class.
            </summary>
            <param name="propertyInfo">The property info.</param>
            <param name="instance">The instance.</param>
            <param name="workingDirectory">The working directory.</param>
        </member>
        <member name="P:CodeSmith.Engine.PropertySerializerContext.PropertyInfo">
            <summary>
            The property that the context points to.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.PropertySerializerContext.Instance">
            <summary>
            The CodeTemplate instance that the context points to.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.PropertySerializerContext.WorkingDirectory">
            <summary>
            The working directory for resolving and creating relative paths.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.XmlPropertyDirectiveTypeConverter">
            <summary>
            This class can be used to convert to and from an XmlNode for a class that supports XML serialization.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.XmlPropertyFilePicker">
            <summary>
            This type editor can be used on a class that supports XML serialization to allow the user to pick an XML file and have that XML file deserialized into the target class.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.XmlPropertyTypeConverter">
            <summary>
            This class can be used to convert to and from an XmlNode for a class that supports XML serialization.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.AdoHelper`1">
            <summary>
            The AdoHelper class is intended to encapsulate high performance, scalable best practices for
            common data access uses.
            </summary>
            <typeparam name="TFactory">The type of the factory.</typeparam>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetParameter(System.String,System.Object)">
            <summary>
            Get an IDataParameter for use in a SQL command
            </summary>
            <param name="name">The name of the parameter to create</param>
            <param name="value">The value of the specified parameter</param>
            <returns>An IDataParameter object</returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetParameter(System.String,System.Data.DbType,System.Int32,System.Data.ParameterDirection)">
            <summary>
            Get an IDataParameter for use in a SQL command
            </summary>
            <param name="name">The name of the parameter to create</param>
            <param name="dbType">The System.Data.DbType of the parameter</param>
            <param name="size">The size of the parameter</param>
            <param name="direction">The System.Data.ParameterDirection of the parameter</param>
            <returns>An IDataParameter object</returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetParameter(System.String,System.Data.DbType,System.Int32,System.String,System.Data.DataRowVersion)">
            <summary>
            Get an IDataParameter for use in a SQL command
            </summary>
            <param name="name">The name of the parameter to create</param>
            <param name="dbType">The System.Data.DbType of the parameter</param>
            <param name="size">The size of the parameter</param>
            <param name="sourceColumn">The source column of the parameter</param>
            <param name="sourceVersion">The System.Data.DataRowVersion of the parameter</param>
            <returns>An IDataParameter object</returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.AttachParameters(System.Data.IDbCommand,System.Data.IDataParameter[])">
            <summary>
            This method is used to attach array of IDataParameters to an IDbCommand.
            
            This method will assign a value of DbNull to any parameter with a direction of
            InputOutput and a value of null.  
            
            This behavior will prevent default values from being used, but
            this will be the less common case than an intended pure output parameter (derived as InputOutput)
            where the user provided no input value.
            </summary>
            <param name="command">The command to which the parameters will be added</param>
            <param name="commandParameters">An array of IDataParameterParameters to be added to command</param>
            <exception cref="T:System.ArgumentNullException">Thrown if command is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.AssignParameterValues(System.Data.IDataParameterCollection,System.Data.DataRow)">
            <summary>
            This method assigns dataRow column values to an IDataParameterCollection
            </summary>
            <param name="commandParameters">The IDataParameterCollection to be assigned values</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values</param>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the parameter names are invalid.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.AssignParameterValues(System.Data.IDataParameter[],System.Data.DataRow)">
            <summary>
            This method assigns dataRow column values to an array of IDataParameters
            </summary>
            <param name="commandParameters">Array of IDataParameters to be assigned values</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values</param>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the parameter names are invalid.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.AssignParameterValues(System.Data.IDataParameter[],System.Object[])">
            <summary>
            This method assigns an array of values to an array of IDataParameters
            </summary>
            <param name="commandParameters">Array of IDataParameters to be assigned values</param>
            <param name="parameterValues">Array of objects holding the values to be assigned</param>
            <exception cref="T:System.ArgumentException">Thrown if an incorrect number of parameters are passed.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.CleanParameterSyntax(System.Data.IDbCommand)">
            <summary>
            This method cleans up the parameter syntax for the provider
            </summary>
            <param name="command">The IDbCommand containing the parameters to clean up.</param>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.PrepareCommand(System.Data.IDbCommand,System.Data.IDbConnection,System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.IDataParameter[],System.Boolean@)">
            <summary>
            This method opens (if necessary) and assigns a connection, transaction, command type and parameters 
            to the provided command
            </summary>
            <param name="command">The IDbCommand to be prepared</param>
            <param name="connection">A valid IDbConnection, on which to execute this command</param>
            <param name="transaction">A valid IDbTransaction, or 'null'</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters to be associated with the command or 'null' if no parameters are required</param>
            <param name="mustCloseConnection"><c>true</c> if the connection was opened by the method, otherwose is false.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if command is null.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ClearCommand(System.Data.IDbCommand)">
            <summary>
            This method clears (if necessary) the connection, transaction, command type and parameters 
            from the provided command
            </summary>
            <remarks>
            Not implemented here because the behavior of this method differs on each data provider. 
            </remarks>
            <param name="command">The IDbCommand to be cleared</param>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteDataset(System.Data.IDbCommand)">
            <summary>
            Execute an IDbCommand (that returns a resultset) against the database specified in 
            the connection string. 
            </summary>
            <param name="command">The IDbCommand object to use</param>
            <returns>A DataSet containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if command is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteDataset(System.String,System.Data.CommandType,System.String)">
            <summary>
            Execute an IDbCommand (that returns a resultset and takes no parameters) against the database specified in 
            the connection string. 
            </summary>
            <example>
            <code>
            DataSet ds = helper.ExecuteDataset(connString, CommandType.StoredProcedure, "GetOrders");
            </code></example>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>A DataSet containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <returns>A DataSet containing the resultset generated by the command</returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteDataset(System.String,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns a resultset) against the database specified in the connection string 
            using the provided parameters.
            </summary>
            <example>
            <code>
            DataSet ds = helper.ExecuteDataset(connString, CommandType.StoredProcedure, "GetOrders", new IDbParameter("@prodid", 24));
            </code></example>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDbParamters used to execute the command</param>
            <returns>A DataSet containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteDataset(System.String,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            </remarks>
            <example>
            <code>
            DataSet ds = helper.ExecuteDataset(connString, "GetOrders", 24, 36);
            </code></example>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A DataSet containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteDataset(System.Data.IDbConnection,System.Data.CommandType,System.String)">
            <summary>
            Execute an IDbCommand (that returns a resultset and takes no parameters) against the provided IDbConnection. 
            </summary>
            <example>
            <code>
            DataSet ds = helper.ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders");
            </code></example>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>A DataSet containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteDataset(System.Data.IDbConnection,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the provided parameters.
            </summary>
            <example>
            <code>
            DataSet ds = helper.ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
            </code></example>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters used to execute the command</param>
            <returns>A DataSet containing the resultset generated by the command</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteDataset(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            </remarks>
            <example>
            <code>
            DataSet ds = helper.ExecuteDataset(conn, "GetOrders", 24, 36);
            </code></example>
            <param name="connection">A valid IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A DataSet containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteDataset(System.Data.IDbTransaction,System.Data.CommandType,System.String)">
            <summary>
            Execute an IDbCommand (that returns a resultset and takes no parameters) against the provided IDbTransaction. 
            </summary>
            <example><code>
             DataSet ds = helper.ExecuteDataset(trans, CommandType.StoredProcedure, "GetOrders");
            </code></example>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>A DataSet containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteDataset(System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns a resultset) against the specified IDbTransaction
            using the provided parameters.
            </summary>
            <example>
            <code>
            DataSet ds = helper.ExecuteDataset(trans, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
            </code></example>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters used to execute the command</param>
            <returns>A DataSet containing the resultset generated by the command</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteDataset(System.Data.IDbTransaction,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified 
            IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            </remarks>
            <example>
            <code>
            DataSet ds = helper.ExecuteDataset(tran, "GetOrders", 24, 36);
            </code></example>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>A DataSet containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteNonQuery(System.Data.IDbCommand)">
            <summary>
            Execute an IDbCommand (that returns no resultset) against the database
            </summary>
            <param name="command">The IDbCommand to execute</param>
            <returns>An int representing the number of rows affected by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if command is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteNonQuery(System.String,System.Data.CommandType,System.String)">
            <summary>
            Execute an IDbCommand (that returns no resultset and takes no parameters) against the database specified in 
            the connection string
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>An int representing the number of rows affected by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteNonQuery(System.String,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns no resultset) against the database specified in the connection string 
            using the provided parameters
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters used to execute the command</param>
            <returns>An int representing the number of rows affected by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteNonQuery(System.String,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns no resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            </remarks>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="spName">The name of the stored prcedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An int representing the number of rows affected by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteNonQuery(System.Data.IDbConnection,System.Data.CommandType,System.String)">
            <summary>
            Execute an IDbCommand (that returns no resultset and takes no parameters) against the provided IDbConnection. 
            </summary>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>An int representing the number of rows affected by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteNonQuery(System.Data.IDbConnection,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns no resultset) against the specified IDbConnection 
            using the provided parameters.
            </summary>
            <remarks>
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDbParamters used to execute the command</param>
            <returns>An int representing the number of rows affected by the command</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteNonQuery(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns no resultset) against the specified IDbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            
            </remarks>
            <param name="connection">A valid IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An int representing the number of rows affected by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteNonQuery(System.Data.IDbTransaction,System.Data.CommandType,System.String)">
            <summary>
            Execute an IDbCommand (that returns no resultset and takes no parameters) against the provided IDbTransaction. 
            </summary>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>An int representing the number of rows affected by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteNonQuery(System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns no resultset) against the specified IDbTransaction
            using the provided parameters.
            </summary>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters used to execute the command</param>
            <returns>An int representing the number of rows affected by the command</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteNonQuery(System.Data.IDbTransaction,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns no resultset) against the specified 
            IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            </remarks>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An int representing the number of rows affected by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReader(System.Data.IDbCommand)">
            <summary>
            Execute an IDbCommand (that returns a resultset) against the database specified in 
            the connection string. 
            </summary>
            <param name="command">The IDbCommand object to use</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if command is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReader(System.Data.IDbCommand,CodeSmith.Engine.AdoHelper{`0}.AdoConnectionOwnership)">
            <summary>
            Execute an IDbCommand (that returns a resultset) against the database specified in 
            the connection string. 
            </summary>
            <param name="command">The IDbCommand object to use</param>
            <param name="connectionOwnership">Enum indicating whether the connection was created internally or externally.</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if command is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReader(System.Data.IDbConnection,System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.IDataParameter[],CodeSmith.Engine.AdoHelper{`0}.AdoConnectionOwnership)">
            <summary>
            Create and prepare an IDbCommand, and call ExecuteReader with the appropriate CommandBehavior.
            </summary>
            <remarks>
            If we created and opened the connection, we want the connection to be closed when the DataReader is closed.
            
            If the caller provided the connection, we want to leave it to them to manage.
            </remarks>
            <param name="connection">A valid IDbConnection, on which to execute this command</param>
            <param name="transaction">A valid IDbTransaction, or 'null'</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters to be associated with the command or 'null' if no parameters are required</param>
            <param name="connectionOwnership">Indicates whether the connection parameter was provided by the caller, or created by AdoHelper</param>
            <returns>IDataReader containing the results of the command</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReader(System.String,System.Data.CommandType,System.String)">
            <summary>
            Execute an IDbCommand (that returns a resultset and takes no parameters) against the database specified in 
            the connection string. 
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReader(System.String,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns a resultset) against the database specified in the connection string 
            using the provided parameters.
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters used to execute the command</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReader(System.String,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            </remarks>
            <example>
            <code>
            IDataReader dr = helper.ExecuteReader(connString, "GetOrders", 24, 36);
            </code></example>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>an IDataReader containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReader(System.Data.IDbConnection,System.Data.CommandType,System.String)">
            <summary>
            Execute an IDbCommand (that returns a resultset and takes no parameters) against the provided IDbConnection. 
            </summary>
            <example>
            <code>
            IDataReader dr = helper.ExecuteReader(conn, CommandType.StoredProcedure, "GetOrders");
            </code></example>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>an IDataReader containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReader(System.Data.IDbConnection,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the provided parameters.
            </summary>
            <example>
            <code>
            IDataReader dr = helper.ExecuteReader(conn, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
            </code></example>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters used to execute the command</param>
            <returns>an IDataReader containing the resultset generated by the command</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReader(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            </remarks>
            <example>
            <code>
            IDataReader dr = helper.ExecuteReader(conn, "GetOrders", 24, 36);
            </code></example>
            <param name="connection">A valid IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>an IDataReader containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReader(System.Data.IDbTransaction,System.Data.CommandType,System.String)">
            <summary>
            Execute an IDbCommand (that returns a resultset and takes no parameters) against the provided IDbTransaction. 
            </summary>
            <example><code>
             IDataReader dr = helper.ExecuteReader(trans, CommandType.StoredProcedure, "GetOrders");
            </code></example>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReader(System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns a resultset) against the specified IDbTransaction
            using the provided parameters.
            </summary>
            <example>
            <code>
            IDataReader dr = helper.ExecuteReader(trans, CommandType.StoredProcedure, "GetOrders", new IDataParameter("@prodid", 24));
            </code></example>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters used to execute the command</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReader(System.Data.IDbTransaction,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified
            IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            </remarks>
            <example>
            <code>
            IDataReader dr = helper.ExecuteReader(tran, "GetOrders", 24, 36);
            </code></example>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>an IDataReader containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteScalar(System.Data.IDbCommand)">
            <summary>
            Execute an IDbCommand (that returns a 1x1 resultset) against the database specified in 
            the connection string. 
            </summary>
            <param name="command">The IDbCommand to execute</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if command is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteScalar(System.String,System.Data.CommandType,System.String)">
            <summary>
            Execute an IDbCommand (that returns a 1x1 resultset and takes no parameters) against the database specified in 
            the connection string. 
            </summary>
            <example>
            <code>
            int orderCount = (int)helper.ExecuteScalar(connString, CommandType.StoredProcedure, "GetOrderCount");
            </code></example>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteScalar(System.String,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns a 1x1 resultset) against the database specified in the connection string 
            using the provided parameters.
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters used to execute the command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteScalar(System.String,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a 1x1 resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            </remarks>
            <example>
            <code>
            int orderCount = (int)helper.ExecuteScalar(connString, "GetOrderCount", 24, 36);
            </code></example>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteScalar(System.Data.IDbConnection,System.Data.CommandType,System.String)">
            <summary>
            Execute an IDbCommand (that returns a 1x1 resultset and takes no parameters) against the provided IDbConnection. 
            </summary>
            <example>
            <code>
            int orderCount = (int)helper.ExecuteScalar(conn, CommandType.StoredProcedure, "GetOrderCount");
            </code></example>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteScalar(System.Data.IDbConnection,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns a 1x1 resultset) against the specified IDbConnection 
            using the provided parameters.
            </summary>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters used to execute the command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteScalar(System.Data.IDbConnection,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a 1x1 resultset) against the specified IDbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            </remarks>
            <example>
            <code>
            int orderCount = (int)helper.ExecuteScalar(conn, "GetOrderCount", 24, 36);
            </code></example>
            <param name="connection">A valid IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteScalar(System.Data.IDbTransaction,System.Data.CommandType,System.String)">
            <summary>
            Execute an IDbCommand (that returns a 1x1 resultset and takes no parameters) against the provided IDbTransaction. 
            </summary>
            <example>
            <code>
            int orderCount = (int)helper.ExecuteScalar(tran, CommandType.StoredProcedure, "GetOrderCount");
            </code></example>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteScalar(System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns a 1x1 resultset) against the specified IDbTransaction
            using the provided parameters.
            </summary>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDbParamters used to execute the command</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteScalar(System.Data.IDbTransaction,System.String,System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a 1x1 resultset) against the specified
            IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            </remarks>
            <example>
            <code>
            int orderCount = (int)helper.ExecuteScalar(tran, "GetOrderCount", 24, 36);
            </code></example>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the transaction is rolled back or commmitted</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.FillDataset(System.Data.IDbCommand,System.Data.DataSet,System.String[])">
            <summary>
            Execute an IDbCommand (that returns a resultset) against the database specified in 
            the connection string. 
            </summary>
            <param name="command">The IDbCommand to execute</param>
            <param name="dataSet">A DataSet wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)</param>
            <exception cref="T:System.ArgumentNullException">Thrown if command is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.FillDataset(System.String,System.Data.CommandType,System.String,System.Data.DataSet,System.String[])">
            <summary>
            Execute an IDbCommand (that returns a resultset and takes no parameters) against the database specified in 
            the connection string. 
            </summary>
            <example>
            <code>
            helper.FillDataset(connString, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
            </code></example>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="dataSet">A DataSet wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)</param>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.FillDataset(System.String,System.Data.CommandType,System.String,System.Data.DataSet,System.String[],System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns a resultset) against the database specified in the connection string 
            using the provided parameters.
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters used to execute the command</param>
            <param name="dataSet">A DataSet wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.FillDataset(System.String,System.String,System.Data.DataSet,System.String[],System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the database specified in 
            the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            </remarks>
            <example>
            <code>
            helper.FillDataset(connString, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"}, 24);
            </code></example>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>    
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.FillDataset(System.Data.IDbConnection,System.Data.CommandType,System.String,System.Data.DataSet,System.String[])">
            <summary>
            Execute an IDbCommand (that returns a resultset and takes no parameters) against the provided IDbConnection. 
            </summary>
            <example>
            <code>
            helper.FillDataset(conn, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
            </code></example>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>    
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.FillDataset(System.Data.IDbConnection,System.Data.CommandType,System.String,System.Data.DataSet,System.String[],System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the provided parameters.
            </summary>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="dataSet">A DataSet wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>
            <param name="commandParameters">An array of IDataParameters used to execute the command</param>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.FillDataset(System.Data.IDbConnection,System.String,System.Data.DataSet,System.String[],System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            </remarks>
            <example>
            <code>
            helper.FillDataset(conn, "GetOrders", ds, new string[] {"orders"}, 24, 36);
            </code></example>
            <param name="connection">A valid IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.FillDataset(System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.DataSet,System.String[])">
            <summary>
            Execute an IDbCommand (that returns a resultset and takes no parameters) against the provided IDbTransaction. 
            </summary>
            <example>
            <code>
            helper.FillDataset(tran, CommandType.StoredProcedure, "GetOrders", ds, new string[] {"orders"});
            </code></example>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>    
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.FillDataset(System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.DataSet,System.String[],System.Data.IDataParameter[])">
            <summary>
            Execute an IDbCommand (that returns a resultset) against the specified IDbTransaction
            using the provided parameters.
            </summary>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="dataSet">A DataSet wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>
            <param name="commandParameters">An array of IDataParameters used to execute the command</param>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.FillDataset(System.Data.IDbTransaction,System.String,System.Data.DataSet,System.String[],System.Object[])">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified 
            IDbTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <remarks>
            This method provides no access to output parameters or the stored procedure's return value parameter.
            </remarks>
            <example>
            <code>
            helper.FillDataset(tran, "GetOrders", ds, new string[] {"orders"}, 24, 36);
            </code></example>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataSet">A dataset wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.FillDataset(System.Data.IDbConnection,System.Data.IDbTransaction,System.Data.CommandType,System.String,System.Data.DataSet,System.String[],System.Data.IDataParameter[])">
            <summary>
            Private helper method that execute an IDbCommand (that returns a resultset) against the specified IDbTransaction and IDbConnection
            using the provided parameters.
            </summary>
            <param name="connection">A valid IDbConnection</param>
            <param name="transaction">A valid IDbTransaction</param>
            <param name="commandType">The CommandType (stored procedure, text, etc.)</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="dataSet">A DataSet wich will contain the resultset generated by the command</param>
            <param name="tableNames">This array will be used to create table mappings allowing the DataTables to be referenced
            by a user defined name (probably the actual table name)
            </param>
            <param name="commandParameters">An array of IDataParameters used to execute the command</param>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.RowUpdating(System.Object,System.Data.Common.RowUpdatingEventArgs)">
            <summary>
            This method consumes the RowUpdatingEvent and passes it on to the consumer specifed in the call to UpdateDataset
            </summary>
            <param name="obj">The object that generated the event</param>
            <param name="e">The System.Data.Common.RowUpdatingEventArgs</param>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.RowUpdated(System.Object,System.Data.Common.RowUpdatedEventArgs)">
            <summary>
            This method consumes the RowUpdatedEvent and passes it on to the consumer specifed in the call to UpdateDataset
            </summary>
            <param name="obj">The object that generated the event</param>
            <param name="e">The System.Data.Common.RowUpdatingEventArgs</param>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.SetCommand(System.Data.IDbCommand,System.Boolean@)">
            <summary>
            Set up a command for updating a DataSet.
            </summary>
            <param name="command">command object to prepare</param>
            <param name="mustCloseConnection">output parameter specifying whether the connection used should be closed by the DAAB</param>
            <returns>An IDbCommand object</returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.UpdateDataset(System.Data.IDbCommand,System.Data.IDbCommand,System.Data.IDbCommand,System.Data.DataSet,System.String)">
            <summary>
            Executes the respective command for each inserted, updated, or deleted row in the DataSet.
            </summary>
            <example>
            <code>
            helper.UpdateDataset(conn, insertCommand, deleteCommand, updateCommand, dataSet, "Order");
            </code></example>
            <param name="insertCommand">A valid SQL statement or stored procedure to insert new records into the data source</param>
            <param name="deleteCommand">A valid SQL statement or stored procedure to delete records from the data source</param>
            <param name="updateCommand">A valid SQL statement or stored procedure used to update records in the data source</param>
            <param name="dataSet">The DataSet used to update the data source</param>
            <param name="tableName">The DataTable used to update the data source.</param>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.UpdateDataset(System.Data.IDbCommand,System.Data.IDbCommand,System.Data.IDbCommand,System.Data.DataSet,System.String,CodeSmith.Engine.AdoHelper{`0}.RowUpdatingHandler,CodeSmith.Engine.AdoHelper{`0}.RowUpdatedHandler)">
            <summary> 
            Executes the IDbCommand for each inserted, updated, or deleted row in the DataSet also implementing RowUpdating and RowUpdated Event Handlers 
            </summary> 
            <example> 
            <code>
            RowUpdatingEventHandler rowUpdatingHandler = new RowUpdatingEventHandler( OnRowUpdating ); 
            RowUpdatedEventHandler rowUpdatedHandler = new RowUpdatedEventHandler( OnRowUpdated ); 
            helper.UpdateDataSet(sqlInsertCommand, sqlDeleteCommand, sqlUpdateCommand, dataSet, "Order", rowUpdatingHandler, rowUpdatedHandler); 
            </code></example> 
            <param name="insertCommand">A valid SQL statement or stored procedure to insert new records into the data source</param> 
            <param name="deleteCommand">A valid SQL statement or stored procedure to delete records from the data source</param> 
            <param name="updateCommand">A valid SQL statement or stored procedure used to update records in the data source</param> 
            <param name="dataSet">The DataSet used to update the data source</param> 
            <param name="tableName">The DataTable used to update the data source.</param> 
            <param name="rowUpdatingHandler">RowUpdatingEventHandler</param> 
            <param name="rowUpdatedHandler">RowUpdatedEventHandler</param> 
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.CreateCommand(System.String,System.String,System.String[])">
            <summary>
            Simplify the creation of an IDbCommand object by allowing
            a stored procedure and optional parameters to be provided
            </summary>
            <example>
            <code>
            IDbCommand command = helper.CreateCommand(conn, "AddCustomer", "CustomerID", "CustomerName");
            </code></example>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="sourceColumns">An array of string to be assigned as the source columns of the stored procedure parameters</param>
            <returns>A valid IDbCommand object</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if any of the IDataParameters.ParameterNames are null, or if the parameter count does not match the number of values supplied</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the parameter count does not match the number of values supplied</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.CreateCommand(System.Data.IDbConnection,System.String,System.String[])">
            <summary>
            Simplify the creation of an IDbCommand object by allowing
            a stored procedure and optional parameters to be provided
            </summary>
            <example>
            <code>
            IDbCommand command = helper.CreateCommand(conn, "AddCustomer", "CustomerID", "CustomerName");
            </code></example>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="sourceColumns">An array of string to be assigned as the source columns of the stored procedure parameters</param>
            <returns>A valid IDbCommand object</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.CreateCommand(System.String,System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>
            Simplify the creation of an IDbCommand object by allowing
            a stored procedure and optional parameters to be provided
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandText">A valid SQL statement</param>
            <param name="commandType">A System.Data.CommandType</param>
            <param name="commandParameters">The parameters for the SQL statement</param>
            <returns>A valid IDbCommand object</returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.CreateCommand(System.Data.IDbConnection,System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>
            Simplify the creation of an IDbCommand object by allowing
            a stored procedure and optional parameters to be provided
            </summary>
            <example><code>
            IDbCommand command = helper.CreateCommand(conn, "AddCustomer", "CustomerID", "CustomerName");
            </code></example>
            <param name="connection">A valid IDbConnection object</param>
            <param name="commandText">A valid SQL statement</param>
            <param name="commandType">A System.Data.CommandType</param>
            <param name="commandParameters">The parameters for the SQL statement</param>
            <returns>A valid IDbCommand object</returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteNonQueryTypedParams(System.Data.IDbCommand,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns no resultset) 
            against the database specified in the connection string using the 
            dataRow column values as the stored procedure's parameters values.
            This method will assign the parameter values based on row values.
            </summary>
            <param name="command">The IDbCommand to execute</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>An int representing the number of rows affected by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if command is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteNonQueryTypedParams(System.String,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns no resultset) against the database specified in 
            the connection string using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on row values.
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>An int representing the number of rows affected by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteNonQueryTypedParams(System.Data.IDbConnection,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns no resultset) against the specified IDbConnection 
            using the dataRow column values as the stored procedure's parameters values.  
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on row values.
            </summary>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>An int representing the number of rows affected by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteNonQueryTypedParams(System.Data.IDbTransaction,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns no resultset) against the specified
            IDbTransaction using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on row values.
            </summary>
            <param name="transaction">A valid IDbTransaction object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>An int representing the number of rows affected by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteDatasetTypedParams(System.Data.IDbCommand,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the database specified in 
            the connection string using the dataRow column values as the stored procedure's parameters values.
            This method will assign the paraemter values based on row values.
            </summary>
            <param name="command">The IDbCommand to execute</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>A DataSet containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if command is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteDatasetTypedParams(System.String,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the database specified in 
            the connection string using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on row values.
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>A DataSet containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteDatasetTypedParams(System.Data.IDbConnection,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the dataRow column values as the store procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on row values.
            </summary>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>A DataSet containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteDatasetTypedParams(System.Data.IDbTransaction,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbTransaction 
            using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on row values.
            </summary>
            <param name="transaction">A valid IDbTransaction object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>A DataSet containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReaderTypedParams(System.Data.IDbCommand,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the database specified in 
            the connection string using the dataRow column values as the stored procedure's parameters values.
            This method will assign the parameter values based on parameter order.
            </summary>
            <param name="command">The IDbCommand to execute</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if command is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReaderTypedParams(System.String,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the database specified in 
            the connection string using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReaderTypedParams(System.Data.IDbConnection,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbConnection 
            using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteReaderTypedParams(System.Data.IDbTransaction,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a resultset) against the specified IDbTransaction 
            using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <param name="transaction">A valid IDbTransaction object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>A IDataReader containing the resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteScalarTypedParams(System.Data.IDbCommand,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a 1x1 resultset) against the database specified in 
            the connection string using the dataRow column values as the stored procedure's parameters values.
            This method will assign the parameter values based on parameter order.
            </summary>
            <param name="command">The IDbCommand to execute</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if command is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteScalarTypedParams(System.String,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a 1x1 resultset) against the database specified in 
            the connection string using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteScalarTypedParams(System.Data.IDbConnection,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a 1x1 resultset) against the specified IDbConnection 
            using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ExecuteScalarTypedParams(System.Data.IDbTransaction,System.String,System.Data.DataRow)">
            <summary>
            Execute a stored procedure via an IDbCommand (that returns a 1x1 resultset) against the specified IDbTransaction
            using the dataRow column values as the stored procedure's parameters values.
            This method will query the database to discover the parameters for the 
            stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
            </summary>
            <param name="transaction">A valid IDbTransaction object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="dataRow">The dataRow used to hold the stored procedure's parameter values.</param>
            <returns>An object containing the value in the 1x1 resultset generated by the command</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if transaction.Connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.CheckForReturnValueParameter(System.Object[])">
            <summary>
            Checks for the existence of a return value parameter in the parametervalues
            </summary>
            <param name="parameterValues">An array of objects to be assigned as the input values of the stored procedure</param>
            <returns>true if the parameterValues contains a return value parameter, false otherwise</returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.AreParameterValuesIDataParameters(System.Object[],System.Data.IDataParameter[])">
            <summary>
            Check to see if the parameter values passed to the helper are, in fact, IDataParameters.
            </summary>
            <param name="parameterValues">Array of parameter values passed to helper</param>
            <param name="iDataParameterValues">new array of IDataParameters built from parameter values</param>
            <returns>True if the parameter values are IDataParameters</returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetSpParameterSet(System.String,System.String)">
            <summary>
            Retrieves the set of IDataParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <returns>An array of IDataParameterParameters</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetSpParameterSet(System.String,System.String,System.Boolean)">
            <summary>
            Retrieves the set of IDataParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
            <returns>An array of IDataParameters</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetSpParameterSet(System.Data.IDbConnection,System.String)">
            <summary>
            Retrieves the set of IDataParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connection">A valid IDataConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <returns>An array of IDataParameters</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetSpParameterSet(System.Data.IDbConnection,System.String,System.Boolean)">
            <summary>
            Retrieves the set of IDataParameters appropriate for the stored procedure
            </summary>
            <remarks>
            This method will query the database for this information, and then store it in a cache for future requests.
            </remarks>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
            <returns>An array of IDataParameters</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetSpParameterSetInternal(System.Data.IDbConnection,System.String,System.Boolean)">
            <summary>
            Retrieves the set of IDataParameters appropriate for the stored procedure
            </summary>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">A bool value indicating whether the return value parameter should be included in the results</param>
            <returns>An array of IDataParameters</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetCachedParameterSet(System.String,System.String)">
            <summary>
            Retrieve a parameter array from the cache
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>An array of IDataParameters</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetCachedParameterSet(System.Data.IDbConnection,System.String)">
            <summary>
            Retrieve a parameter array from the cache
            </summary>
            <param name="connection">A valid IDbConnection object</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>An array of IDataParameters</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetCachedParameterSetInternal(System.Data.IDbConnection,System.String)">
            <summary>
            Retrieve a parameter array from the cache
            </summary>
            <param name="connection">A valid IDbConnection object</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>An array of IDataParameters</returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.CacheParameterSet(System.String,System.String,System.Data.IDataParameter[])">
            <summary>
            Add parameter array to the cache
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters to be cached</param>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.CacheParameterSet(System.Data.IDbConnection,System.String,System.Data.IDataParameter[])">
            <summary>
            Add parameter array to the cache
            </summary>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters to be cached</param>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.CacheParameterSetInternal(System.Data.IDbConnection,System.String,System.Data.IDataParameter[])">
            <summary>
            Add parameter array to the cache
            </summary>
            <param name="connection">A valid IDbConnection</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters to be cached</param>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.DiscoverSpParameterSet(System.Data.IDbConnection,System.String,System.Boolean)">
            <summary>
            Resolve at run time the appropriate set of IDataParameters for a stored procedure
            </summary>
            <param name="connection">A valid IDbConnection object</param>
            <param name="spName">The name of the stored procedure</param>
            <param name="includeReturnValueParameter">Whether or not to include their return value parameter</param>
            <returns>The parameter array discovered.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if spName is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connection is null</exception>
        </member>
        <member name="F:CodeSmith.Engine.AdoHelper`1.m_rowUpdated">
            <summary>
            Internal handler used for bubbling up the event to the user
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.AdoHelper`1.m_rowUpdating">
            <summary>
            Internal handler used for bubbling up the event to the user
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetConnection(System.String)">
            <summary>
            Returns an IDbConnection object for the given connection string
            </summary>
            <param name="connectionString">The connection string to be used to create the connection</param>
            <returns>An IDbConnection object</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetDataAdapter">
            <summary>
            Returns an IDbDataAdapter object
            </summary>
            <returns>The IDbDataAdapter</returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.DeriveParameters(System.Data.IDbCommand)">
            <summary>
            Calls the CommandBuilder.DeriveParameters method for the specified provider, doing any setup and cleanup necessary
            </summary>
            <param name="cmd">The IDbCommand referencing the stored procedure from which the parameter information is to be derived. The derived parameters are added to the Parameters collection of the IDbCommand. </param>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetParameter">
            <summary>
            Returns an IDataParameter object
            </summary>
            <returns>The IDataParameter object</returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.AddUpdateEventHandlers(System.Data.IDbDataAdapter,CodeSmith.Engine.AdoHelper{`0}.RowUpdatingHandler,CodeSmith.Engine.AdoHelper{`0}.RowUpdatedHandler)">
            <summary>
            Provider specific code to set up the updating/ed event handlers used by UpdateDataset
            </summary>
            <param name="dataAdapter">DataAdapter to attach the event handlers to</param>
            <param name="rowUpdatingHandler">The handler to be called when a row is updating</param>
            <param name="rowUpdatedHandler">The handler to be called when a row is updated</param>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetDataParameters(System.Int32)">
            <summary>
            Returns an array of IDataParameters of the specified size
            </summary>
            <param name="size">size of the array</param>
            <returns>The array of IDataParameters</returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.GetBlobParameter(System.Data.IDbConnection,System.Data.IDataParameter)">
            <summary>
            Handle any provider-specific issues with BLOBs here by "washing" the IDataParameter and returning a new one that is set up appropriately for the provider.
            </summary>
            <param name="connection">The IDbConnection to use in cleansing the parameter</param>
            <param name="p">The parameter before cleansing</param>
            <returns>The parameter after it's been cleansed.</returns>
        </member>
        <member name="T:CodeSmith.Engine.AdoHelper`1.RowUpdatedHandler">
            <summary>
            Delegate for creating a RowUpdatedEvent handler
            </summary>
            <param name="sender">The object that published the event</param>
            <param name="e">The RowUpdatedEventArgs for the event</param>
        </member>
        <member name="T:CodeSmith.Engine.AdoHelper`1.RowUpdatingHandler">
            <summary>
            Delegate for creating a RowUpdatingEvent handler
            </summary>
            <param name="sender">The object that published the event</param>
            <param name="e">The RowUpdatingEventArgs for the event</param>
        </member>
        <member name="T:CodeSmith.Engine.AdoHelper`1.AdoConnectionOwnership">
            <summary>
            This enum is used to indicate whether the connection was provided by the caller, or created by AdoHelper, so that
            we can set the appropriate CommandBehavior when calling ExecuteReader()
            </summary>
        </member>
        <member name="F:CodeSmith.Engine.AdoHelper`1.AdoConnectionOwnership.Internal">
            <summary>Connection is owned and managed by ADOHelper</summary>
        </member>
        <member name="F:CodeSmith.Engine.AdoHelper`1.AdoConnectionOwnership.External">
            <summary>Connection is owned and managed by the caller</summary>
        </member>
        <member name="T:CodeSmith.Engine.AdoHelper`1.ADOHelperParameterCache">
            <summary>
            ADOHelperParameterCache provides functions to leverage a static cache of procedure parameters, and the
            ability to discover parameters for stored procedures at run-time.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ADOHelperParameterCache.CloneParameters(System.Data.IDataParameter[])">
            <summary>
            Deep copy of cached IDataParameter array
            </summary>
            <param name="originalParameters"></param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ADOHelperParameterCache.CacheParameterSet(System.String,System.String,System.Data.IDataParameter[])">
            <summary>
            Add parameter array to the cache
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <param name="commandParameters">An array of IDataParameters to be cached</param>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.AdoHelper`1.ADOHelperParameterCache.GetCachedParameterSet(System.String,System.String)">
            <summary>
            Retrieve a parameter array from the cache
            </summary>
            <param name="connectionString">A valid connection string for an IDbConnection</param>
            <param name="commandText">The stored procedure name or SQL command</param>
            <returns>An array of IDataParameters</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if commandText is null</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if connectionString is null</exception>
        </member>
        <member name="M:CodeSmith.Engine.CodeSmithDomainFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="P:CodeSmith.Engine.CodeSmithDomainFactory.CodeSmithDomain"/> class.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeSmithDomainFactory.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="P:CodeSmith.Engine.CodeSmithDomainFactory.CodeSmithDomain"/> class.
            </summary>
            <param name="friendlyName">Name of the friendly.</param>
        </member>
        <member name="M:CodeSmith.Engine.CodeSmithDomainFactory.Finalize">
            <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="P:CodeSmith.Engine.CodeSmithDomainFactory.CodeSmithDomain"/> is reclaimed by garbage collection.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeSmithDomainFactory.CreateInstance``1">
            <summary>
            Creates an instance in the <see cref="P:CodeSmith.Engine.CodeSmithDomainFactory.CodeSmithDomain"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeSmithDomainFactory.CreateInstance``1(System.Object[])">
            <summary>
            Creates an instance in the <see cref="P:CodeSmith.Engine.CodeSmithDomainFactory.CodeSmithDomain"/>.
            </summary>
            <param name="args">The constructor args.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.CodeSmithDomainFactory.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, 
            releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.CodeSmithDomainFactory.NeedCodeSmithDomain">
            <summary>
            Need a <see cref="P:CodeSmith.Engine.CodeSmithDomainFactory.CodeSmithDomain"/>.
            </summary>
            <returns>true if a <see cref="P:CodeSmith.Engine.CodeSmithDomainFactory.CodeSmithDomain"/> is needed.</returns>
        </member>
        <member name="P:CodeSmith.Engine.CodeSmithDomainFactory.CodeSmithDomain">
            <summary>
            Gets the CodeSmith <see cref="T:System.AppDomain"/>.
            </summary>
            <value>The CodeSmith <see cref="T:System.AppDomain"/>.</value>
        </member>
        <member name="T:CodeSmith.Engine.DotNetFrameworkVersion">
            <summary>
            Allows the user to specify the framework version to resolve.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.Utility.EnumHelper">
            <summary>
            A class to help with Enum Flags.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Utility.EnumHelper.IsAnyFlagOn``1(``0,``0)">
            <summary>
            Determines whether any flag is on for the specified mask.
            </summary>
            <typeparam name="T">The flag type.</typeparam>
            <param name="mask">The mask to check if the flag is on.</param>
            <param name="flag">The flag to check for in the mask.</param>
            <returns>
            	<c>true</c> if any flag is on for the specified mask; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.EnumHelper.IsFlagOn``1(``0,``0)">
            <summary>
            Determines whether the flag is on for the specified mask.
            </summary>
            <typeparam name="T">The flag type.</typeparam>
            <param name="mask">The mask to check if the flag is on.</param>
            <param name="flag">The flag to check for in the mask.</param>
            <returns>
            	<c>true</c> if the flag is on for the specified mask; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.EnumHelper.SetFlagOn``1(``0@,``0)">
            <summary>
            Sets the flag on in the specified mask.
            </summary>
            <typeparam name="T">The flag type.</typeparam>
            <param name="mask">The mask to set flag on.</param>
            <param name="flag">The flag to set.</param>
        </member>
        <member name="M:CodeSmith.Engine.Utility.EnumHelper.SetFlagOn``1(``0,``0)">
            <summary>
            Sets the flag on in the specified mask.
            </summary>
            <typeparam name="T">The flag type.</typeparam>
            <param name="mask">The mask to set flag on.</param>
            <param name="flag">The flag to set.</param>
            <returns>The mask with the flag set to on.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.EnumHelper.SetFlagOff``1(``0@,``0)">
            <summary>
            Sets the flag off in the specified mask.
            </summary>
            <typeparam name="T">The flag type.</typeparam>
            <param name="mask">The mask to set flag off.</param>
            <param name="flag">The flag to set.</param>
        </member>
        <member name="M:CodeSmith.Engine.Utility.EnumHelper.SetFlagOff``1(``0,``0)">
            <summary>
            Sets the flag off in the specified mask.
            </summary>
            <typeparam name="T">The flag type.</typeparam>
            <param name="mask">The mask to set flag off.</param>
            <param name="flag">The flag to set.</param>
            <returns>The mask with the flag set to off.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.EnumHelper.ToggleFlag``1(``0@,``0)">
            <summary>
            Toggles the flag in the specified mask.
            </summary>
            <typeparam name="T">The flag type.</typeparam>
            <param name="mask">The mask to toggle the flag against.</param>
            <param name="flag">The flag to toggle.</param>
        </member>
        <member name="M:CodeSmith.Engine.Utility.EnumHelper.ToggleFlag``1(``0,``0)">
            <summary>
            Toggles the flag in the specified mask.
            </summary>
            <typeparam name="T">The flag type.</typeparam>
            <param name="mask">The mask to toggle the flag against.</param>
            <param name="flag">The flag to toggle.</param>
            <returns>The mask with the flag set in the opposite position then it was.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.EnumHelper.ToStringHex``1(``0)">
            <summary>
            Gets the string hex of the enum.
            </summary>
            <typeparam name="T">The enum type.</typeparam>
            <param name="enum">The enum to get the string hex from.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.EnumHelper.TryParseEnum``1(System.String,``0@)">
            <summary>
            Tries to get an enum from a string.
            </summary>
            <typeparam name="T">The enum type.</typeparam>
            <param name="input">The input string.</param>
            <param name="returnValue">The return enum value.</param>
            <returns>
            	<c>true</c> if the string was able to be parsed to an enum; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.ExceptionHelper.IsLicenseException(System.Exception)">
            <summary>
            Checks an exception for a licensing related error.
            </summary>
            <param name="ex">The exception</param>
            <returns>Returns true if a licensing exception is found.</returns>
        </member>
        <member name="T:CodeSmith.Engine.Inflector">
            <summary>
            The Inflector class transforms words from one 
            form to another. For example, from singular to plural.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Inflector.Pluralize(System.String)">
            <summary>
            Return the plural of a word.
            </summary>
            <param name="word">The singular form</param>
            <returns>The plural form of <paramref name="word"/></returns>
        </member>
        <member name="M:CodeSmith.Engine.Inflector.Singularize(System.String)">
            <summary>
            Return the singular of a word.
            </summary>
            <param name="word">The plural form</param>
            <returns>The singular form of <paramref name="word"/></returns>
        </member>
        <member name="M:CodeSmith.Engine.Inflector.Capitalize(System.String)">
            <summary>
            Capitalizes a word.
            </summary>
            <param name="word">The word to be capitalized.</param>
            <returns><paramref name="word"/> capitalized.</returns>
        </member>
        <member name="T:CodeSmith.Engine.ObjectCopier">
            <summary>
            Copy data from a source into a target object by copying public property values.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:CodeSmith.Engine.ObjectCopier.Copy(System.Object,System.Object)">
            <summary>
            Copies values from the source into the properties of the target.
            </summary>
            <param name="source">An object containing the source values.</param>
            <param name="target">An object with properties to be set from the source.</param>
            <remarks>
            The property names and types of the source object must match the property names and types
            on the target object. Source properties may not be indexed. 
            Target properties may not be readonly or indexed.
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.ObjectCopier.Copy(System.Object,System.Object,System.String[])">
            <summary>
            Copies values from the source into the properties of the target.
            </summary>
            <param name="source">An object containing the source values.</param>
            <param name="target">An object with properties to be set from the source.</param>
            <param name="ignoreList">A list of property names to ignore. 
            These properties will not be set on the target object.</param>
            <remarks>
            The property names and types of the source object must match the property names and types
            on the target object. Source properties may not be indexed. 
            Target properties may not be readonly or indexed.
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.ObjectCopier.Copy(System.Object,System.Object,System.Boolean,System.String[])">
            <summary>
            Copies values from the source into the properties of the target.
            </summary>
            <param name="source">An object containing the source values.</param>
            <param name="target">An object with properties to be set from the source.</param>
            <param name="ignoreList">A list of property names to ignore. 
            These properties will not be set on the target object.</param>
            <param name="suppressExceptions">If <see langword="true"/>, any exceptions will be supressed.</param>
            <remarks>
            <para>
            The property names and types of the source object must match the property names and types
            on the target object. Source properties may not be indexed. 
            Target properties may not be readonly or indexed.
            </para><para>
            Properties to copy are determined based on the source object. Any properties
            on the source object marked with the <see cref="T:System.ComponentModel.BrowsableAttribute"/> equal
            to false are ignored.
            </para>
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.ObjectCopier.Copy(System.Object,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Copies values from the source into the target IDictionary.
            </summary>
            <param name="source">The source object.</param>
            <param name="target">The target IDictionary.</param>
        </member>
        <member name="M:CodeSmith.Engine.ObjectCopier.Copy(System.Object,System.Collections.Generic.IDictionary{System.String,System.Object},System.String[])">
            <summary>
            Copies values from the source into the target IDictionary.
            </summary>
            <param name="source">The source object.</param>
            <param name="target">The target IDictionary.</param>
            <param name="ignoreList">A list of property names to ignore. 
            These properties will not be added to the targed IDictionary.</param>
        </member>
        <member name="M:CodeSmith.Engine.ObjectCopier.Copy(System.Object,System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean,System.String[])">
            <summary>
            Copies values from the source into the target IDictionary.
            </summary>
            <param name="source">The source object.</param>
            <param name="target">The target IDictionary.</param>
            <param name="ignoreList">A list of property names to ignore. 
            These properties will not be added to the targed IDictionary.</param>
            <param name="suppressExceptions">If <see langword="true" />, any exceptions will be supressed.</param>
        </member>
        <member name="M:CodeSmith.Engine.ObjectCopier.Copy(System.Collections.Generic.IDictionary{System.String,System.Object},System.Object)">
            <summary>
            Copies values from the IDictionary into the properties of the target.
            </summary>
            <param name="source">The IDictionary source.</param>
            <param name="target">The target object.</param>
        </member>
        <member name="M:CodeSmith.Engine.ObjectCopier.Copy(System.Collections.Generic.IDictionary{System.String,System.Object},System.Object,System.String[])">
            <summary>
            Copies values from the IDictionary into the properties of the target.
            </summary>
            <param name="source">The IDictionary source.</param>
            <param name="target">The target object.</param>
            <param name="ignoreList">A list of property names to ignore. 
            These properties will not be set on the target object.</param>
        </member>
        <member name="M:CodeSmith.Engine.ObjectCopier.Copy(System.Collections.Generic.IDictionary{System.String,System.Object},System.Object,System.Boolean,System.String[])">
            <summary>
            Copies values from the IDictionary into the properties of the target.
            </summary>
            <param name="source">The IDictionary source.</param>
            <param name="target">The target object.</param>
            <param name="ignoreList">A list of property names to ignore. 
            These properties will not be set on the target object.</param>
            <param name="suppressExceptions">If <see langword="true" />, any exceptions will be supressed.</param>
        </member>
        <member name="M:CodeSmith.Engine.ObjectCopier.SetPropertyValue(System.Object,System.String,System.Object)">
            <summary>
            Sets an object's property with the specified value,
            converting that value to the appropriate type if possible.
            </summary>
            <param name="target">Object containing the property to set.</param>
            <param name="propertyName">Name of the property to set.</param>
            <param name="value">Value to set into the property.</param>
        </member>
        <member name="M:CodeSmith.Engine.ObjectCopier.GetPropertyValue(System.Object,System.String)">
            <summary>
            Gets an object's property value by name.
            </summary>
            <param name="target">Object containing the property to get.</param>
            <param name="propertyName">Name of the property.</param>
            <returns>The value of the property.</returns>
        </member>
        <member name="M:CodeSmith.Engine.ObjectCopier.GetUnderlyingType(System.Type)">
            <summary>
            Gets the underlying type dealing with Nullable.
            </summary>
            <param name="type">The type.</param>
            <returns>Returns a type dealing with Nullable.</returns>
        </member>
        <member name="M:CodeSmith.Engine.ObjectCopier.FindProperty(System.Type,System.String)">
            <summary>
            Finds a <see cref="T:System.Reflection.PropertyInfo"/> by name ignoring case.
            </summary>
            <param name="type">The type to search.</param>
            <param name="propertyName">Name of the property.</param>
            <returns>A <see cref="T:System.Reflection.PropertyInfo"/> matching the property name.</returns>
            <remarks>
            FindProperty will first try to get a property matching the name and case of the 
            property name specified.  If a property cannot be found, all the properties will
            be searched ignoring the case of the name.
            </remarks>
        </member>
        <member name="M:CodeSmith.Engine.Utility.PathUtil.RelativePathTo(System.String,System.String)">
            <summary>
            Creates a relative path from one file or folder to another.
            </summary>
            <param name="fromDirectory">Contains the directory that defines the start of the relative path.</param>
            <param name="toPath">Contains the path that defines the endpoint of the relative path.</param>
            <returns>The relative path from the start directory to the end path.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:CodeSmith.Engine.Utility.RegistryUtil">
            <summary>
            Utility class for working with the registry.
            NOTE: At some time it would be nice to add automatic detection to see if values exist in the Wow6432Node keys.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.GetString(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            Retrieves the specified value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Gets the value for the specified key.</param>
            <returns>Returns null if an error occurred, else returns the string value for the specified key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.GetString(Microsoft.Win32.RegistryKey,System.String,System.String,System.String)">
            <summary>
            Retrieves the specified value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Gets the value for the specified key.</param>
            <param name="defaultValue">The value to return if the key does not exist.</param>
            <returns>Returns null if an error occurred, else returns the string value for the specified key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.GetDWORD(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            Retrieves the specified DWORD value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Gets the value for the specified key.</param>
            <returns>Returns 0 if an error occurred, else returns the int value for the specified key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.GetDWORD(Microsoft.Win32.RegistryKey,System.String,System.String,System.Int32)">
            <summary>
            Retrieves the specified DWORD value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Gets the value for the specified key.</param>
            <param name="defaultValue">The value to return if the key does not exist.</param>
            <returns>Returns 0 if an error occurred, else returns the int value for the specified key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.GetQWORD(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            Retrieves the specified QWORD value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Gets the value for the specified key.</param>
            <returns>Returns 0 if an error occurred, else returns the long value for the specified key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.GetQWORD(Microsoft.Win32.RegistryKey,System.String,System.String,System.Int64)">
            <summary>
            Retrieves the specified QWORD value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Gets the value for the specified key.</param>
            <param name="defaultValue">The value to return if the key does not exist.</param>
            <returns>Returns 0 if an error occurred, else returns the long value for the specified key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.GetBoolean(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            Retrieves the specified DWORD value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Gets the value for the specified key.</param>
            <returns>Returns false if an error occurred, else returns the value for the specified key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.GetBoolean(Microsoft.Win32.RegistryKey,System.String,System.String,System.Boolean)">
            <summary>
            Retrieves the specified DWORD value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Gets the value for the specified key.</param>
            <param name="defaultValue">The value to return if the key does not exist.</param>
            <returns>Returns false if an error occurred, else returns the value for the specified key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.GetBinary(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            Retrieves the specified Binary value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Gets the value for the specified key.</param>
            <returns>Returns null if an error occurred, else returns the byte[] value for the specified key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.GetBinary(Microsoft.Win32.RegistryKey,System.String,System.String,System.Byte[])">
            <summary>
            Retrieves the specified Binary value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Gets the value for the specified key.</param>
            <param name="defaultValue">The value to return if the key does not exist.</param>
            <returns>Returns null if an error occurred, else returns the byte[] value for the specified key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.GetDateTime(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            Retrieves the specified DateTime value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Gets the value for the specified key.</param>
            <returns>Returns DateTime.Min if an error occurred, else returns the value for the specified key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.GetDateTime(Microsoft.Win32.RegistryKey,System.String,System.String,System.DateTime)">
            <summary>
            Retrieves the specified DateTime value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Gets the value for the specified key.</param>
            <param name="defaultValue">The value to return if the key does not exist.</param>
            <returns>Returns DateTime.Min if an error occurred, else returns the value for the specified key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.GetValueType(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            Retrieves the type of the specified Registry value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Gets the value type for the specified key name.</param>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.SetString(Microsoft.Win32.RegistryKey,System.String,System.String,System.String)">
            <summary>
            Sets or creates the specified String value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Sets the value for the specified key name.</param>
            <param name="value">Sets this value to the key name.</param>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.SetDWORD(Microsoft.Win32.RegistryKey,System.String,System.String,System.Int32)">
            <summary>
            Sets or creates the specified DWORD value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Sets the value for the specified key name.</param>
            <param name="value">Sets this value to the key name.</param>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.SetQWORD(Microsoft.Win32.RegistryKey,System.String,System.String,System.Int64)">
            <summary>
            Sets or creates the specified QWORD value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Sets the value for the specified key name.</param>
            <param name="value">Sets this value to the key name.</param>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.SetBoolean(Microsoft.Win32.RegistryKey,System.String,System.String,System.Boolean)">
            <summary>
            Sets or creates the specified Boolean value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Sets the value for the specified key name.</param>
            <param name="value">Sets this value to the key name.</param>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.SetBinary(Microsoft.Win32.RegistryKey,System.String,System.String,System.Byte[])">
            <summary>
            Sets or creates the specified Binary value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Sets the value for the specified key name.</param>
            <param name="value">Sets this value to the key name.</param>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.SetDateTime(Microsoft.Win32.RegistryKey,System.String,System.String,System.DateTime)">
            <summary>
            Sets or creates the specified DateTime value.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Sets the value for the specified key name.</param>
            <param name="value">Sets this value to the key name.</param>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.CreateSubKey(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Creates a new subkey or opens an existing subkey.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <returns>Returns the opened subkey if it could be opened, else returns null.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.DeleteSubKeyTree(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Deletes a subkey and any child subkeys recursively.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Deletes this key under the supplied RegistryKey.</param>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.DeleteValue(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            Deletes the specified value from this (current) key.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Sets the value for the specified key name.</param>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.RenameSubKey(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            Renames a registry key.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="destinationSubKey">Then name of the new SubKey.</param>
            <returns>The new SubKey.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.CopySubKey(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            Copies a registry key.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="destinationSubKey">Then name of the destination SubKey.</param>
            <returns>The newly copied SubKey.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.CopyHiveKeyRecursively(Microsoft.Win32.RegistryKey,Microsoft.Win32.RegistryKey)">
            <summary>
            Copies a HiveKey Recursively.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="destinationHiveKey">Then name of the destination HiveKey.</param>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.Count(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Retrieves the number of values in the specified Registry hive.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <returns>Returns the number of sub keys, else returns 0.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.Count(Microsoft.Win32.RegistryKey,System.String,System.Boolean)">
            <summary>
            Retrieves the number of values in the specified Registry hive.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="useSubKeyCount"></param>
            <returns>Returns the number of sub keys, else returns 0.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.Exists(Microsoft.Win32.RegistryKey)">
            <summary>
            Checks to see if a subkey exists.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <returns>Returns false if the key wasn't found.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.Exists(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Checks to see if a subkey exists.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <returns>Returns false if the key wasn't found.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.Exists(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            Checks to see if a subkey exists.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">If the name is specified then it will check to see if this value exists.</param>
            <returns>Returns false if the key wasn't found.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.Find(Microsoft.Win32.RegistryKey,System.String,System.String,System.String)">
            <summary>
            Finds a specific key one level deep from the hivekey.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            <param name="name">Gets the value for the specified key.</param>
            <param name="value">Value to check.</param>
            <returns>The SubKey name if found; returns string.Empty if not found.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.Keys(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Retrieves all key names under a given hive key.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            /// <returns>Retrieves all key names under a given hive key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.SubKeys(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Retrieves all subkeys under a given hive key.
            </summary>
            <param name="hiveKey">The RegistryKey that the sub key exists in.</param>
            <param name="subKey">Opens this key under the supplied RegistryKey.</param>
            /// <returns>Retrieves all subkeys under a given hive key.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.NextSubKey(Microsoft.Win32.RegistryKey)">
            <summary>
             Returns the next available index in a list of registry sub keys.
            </summary>
            <param name="hiveKey">The hive key.</param>
            <returns>Returns the next number in an indexed list.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Utility.RegistryUtil.CreateCodeSmithKey">
            <summary>
            create the root CodeSmith RegistryKey.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Utility.RegistryUtil.Message">
            <summary>
            This is the Error message, it will be null unless an error occurred.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Utility.RegistryUtil.RootKey">
            <summary>
            Returns the root CodeSmith RegistryKey (E.G Software\CodeSmith).
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.Utility.RegistryUtil.Key">
            <summary>
            Returns the CodeSmith RegistryKey (E.G Software\CodeSmith\v5.2).
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.SafeDataReader">
            <summary>
            This is a DataReader that 'fixes' any null values before
            they are returned to our business code.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.#ctor(System.Data.IDataReader)">
            <summary>
            Initializes the SafeDataReader object to use data from
            the provided DataReader object.
            </summary>
            <param name="dataReader">The source DataReader object containing the data.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetString(System.Int32)">
            <summary>
            Gets a string value from the datareader.
            </summary>
            <remarks>
            Returns empty string for null.
            </remarks>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetValue(System.Int32)">
            <summary>
            Gets a value of type <see cref="T:System.Object"/> from the datareader.
            </summary>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetInt32(System.Int32)">
            <summary>
            Gets an integer from the datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetDouble(System.Int32)">
            <summary>
            Gets a double from the datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetGuid(System.Int32)">
            <summary>
            Gets a Guid value from the datareader.
            </summary>
            <remarks>
            Returns Guid.Empty for null.
            </remarks>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.Read">
            <summary>
            Reads the next row of data from the datareader.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.NextResult">
            <summary>
            Moves to the next result set in the datareader.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.Close">
            <summary>
            Closes the datareader.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetBoolean(System.Int32)">
            <summary>
            Gets a boolean value from the datareader.
            </summary>
            <remarks>
            Returns <see langword="false" /> for null.
            </remarks>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetByte(System.Int32)">
            <summary>
            Gets a byte value from the datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Invokes the GetBytes method of the underlying datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="i">Ordinal column position of the value.</param>
            <param name="buffer">Array containing the data.</param>
            <param name="bufferOffset">Offset position within the buffer.</param>
            <param name="fieldOffset">Offset position within the field.</param>
            <param name="length">Length of data to read.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetChar(System.Int32)">
            <summary>
            Gets a char value from the datareader.
            </summary>
            <remarks>
            Returns Char.MinValue for null.
            </remarks>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <summary>
            Invokes the GetChars method of the underlying datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="i">Ordinal column position of the value.</param>
            <param name="buffer">Array containing the data.</param>
            <param name="bufferOffset">Offset position within the buffer.</param>
            <param name="fieldOffset">Offset position within the field.</param>
            <param name="length">Length of data to read.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetData(System.Int32)">
            <summary>
            Invokes the GetData method of the underlying datareader.
            </summary>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetDataTypeName(System.Int32)">
            <summary>
            Invokes the GetDataTypeName method of the underlying datareader.
            </summary>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetDateTime(System.Int32)">
            <summary>
            Gets a date value from the datareader.
            </summary>
            <remarks>
            Returns DateTime.MinValue for null.
            </remarks>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetDecimal(System.Int32)">
            <summary>
            Gets a decimal value from the datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetFieldType(System.Int32)">
            <summary>
            Invokes the GetFieldType method of the underlying datareader.
            </summary>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetFloat(System.Int32)">
            <summary>
            Gets a Single value from the datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetInt16(System.Int32)">
            <summary>
            Gets a Short value from the datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetInt64(System.Int32)">
            <summary>
            Gets a Long value from the datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetName(System.Int32)">
            <summary>
            Invokes the GetName method of the underlying datareader.
            </summary>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetOrdinal(System.String)">
            <summary>
            Gets an ordinal value from the datareader.
            </summary>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetSchemaTable">
            <summary>
            Invokes the GetSchemaTable method of the underlying datareader.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetValues(System.Object[])">
            <summary>
            Invokes the GetValues method of the underlying datareader.
            </summary>
            <param name="values">An array of System.Object to
            copy the values into.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.IsDBNull(System.Int32)">
            <summary>
            Invokes the IsDBNull method of the underlying datareader.
            </summary>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.Dispose">
            <summary>
            Disposes the object.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.Dispose(System.Boolean)">
            <summary>
            Disposes the object.
            </summary>
            <param name="disposing">True if called by
            the public Dispose method.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.Finalize">
            <summary>
            Object finalizer.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetString(System.String)">
            <summary>
            Gets a string value from the datareader.
            </summary>
            <remarks>
            Returns empty string for null.
            </remarks>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetValue(System.String)">
            <summary>
            Gets a value of type <see cref="T:System.Object"/> from the datareader.
            </summary>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetInt32(System.String)">
            <summary>
            Gets an integer from the datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetDouble(System.String)">
            <summary>
            Gets a double from the datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetGuid(System.String)">
            <summary>
            Gets a Guid value from the datareader.
            </summary>
            <remarks>
            Returns Guid.Empty for null.
            </remarks>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetBoolean(System.String)">
            <summary>
            Gets a boolean value from the datareader.
            </summary>
            <remarks>
            Returns <see langword="false" /> for null.
            </remarks>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetByte(System.String)">
            <summary>
            Gets a byte value from the datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetBytes(System.String,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Invokes the GetBytes method of the underlying datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="name">Name of the column containing the value.</param>
            <param name="buffer">Array containing the data.</param>
            <param name="bufferOffset">Offset position within the buffer.</param>
            <param name="fieldOffset">Offset position within the field.</param>
            <param name="length">Length of data to read.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetChar(System.String)">
            <summary>
            Gets a char value from the datareader.
            </summary>
            <remarks>
            Returns Char.MinValue for null.
            </remarks>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetChars(System.String,System.Int64,System.Char[],System.Int32,System.Int32)">
            <summary>
            Invokes the GetChars method of the underlying datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="name">Name of the column containing the value.</param>
            <param name="buffer">Array containing the data.</param>
            <param name="bufferOffset">Offset position within the buffer.</param>
            <param name="fieldOffset">Offset position within the field.</param>
            <param name="length">Length of data to read.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetData(System.String)">
            <summary>
            Invokes the GetData method of the underlying datareader.
            </summary>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetDataTypeName(System.String)">
            <summary>
            Invokes the GetDataTypeName method of the underlying datareader.
            </summary>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetDateTime(System.String)">
            <summary>
            Gets a date value from the datareader.
            </summary>
            <remarks>
            Returns DateTime.MinValue for null.
            </remarks>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetDecimal(System.String)">
            <summary>
            Gets a decimal value from the datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetFieldType(System.String)">
            <summary>
            Invokes the GetFieldType method of the underlying datareader.
            </summary>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetFloat(System.String)">
            <summary>
            Gets a Single value from the datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetInt16(System.String)">
            <summary>
            Gets a Short value from the datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.GetInt64(System.String)">
            <summary>
            Gets a Long value from the datareader.
            </summary>
            <remarks>
            Returns 0 for null.
            </remarks>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="M:CodeSmith.Engine.SafeDataReader.IsDBNull(System.String)">
            <summary>
            Invokes the IsDBNull method of the underlying datareader.
            </summary>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="P:CodeSmith.Engine.SafeDataReader.DataReader">
            <summary>
            Get a reference to the underlying data reader
            object that actually contains the data from
            the data source.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.SafeDataReader.Depth">
            <summary>
            Returns the depth property value from the datareader.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.SafeDataReader.FieldCount">
            <summary>
            Returns the FieldCount property from the datareader.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.SafeDataReader.IsClosed">
            <summary>
            Returns the IsClosed property value from the datareader.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.SafeDataReader.Item(System.String)">
            <summary>
            Returns a value from the datareader.
            </summary>
            <param name="name">Name of the column containing the value.</param>
        </member>
        <member name="P:CodeSmith.Engine.SafeDataReader.Item(System.Int32)">
            <summary>
            Returns a value from the datareader.
            </summary>
            <param name="i">Ordinal column position of the value.</param>
        </member>
        <member name="P:CodeSmith.Engine.SafeDataReader.RecordsAffected">
            <summary>
            Returns the RecordsAffected property value from the underlying datareader.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.SerializableDictionary`2">
            <summary>
            Represents a xml serializable collection of keys and values.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
        </member>
        <member name="M:CodeSmith.Engine.SerializableDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.SerializableDictionary`2"/> class.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.SerializableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.SerializableDictionary`2"/> class.
            </summary>
            <param name="dictionary">The dictionary.</param>
        </member>
        <member name="M:CodeSmith.Engine.SerializableDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.SerializableDictionary`2"/> class.
            </summary>
            <param name="comparer">The comparer.</param>
        </member>
        <member name="M:CodeSmith.Engine.SerializableDictionary`2.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.SerializableDictionary`2"/> class.
            </summary>
            <param name="capacity">The capacity.</param>
        </member>
        <member name="M:CodeSmith.Engine.SerializableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.SerializableDictionary`2"/> class.
            </summary>
            <param name="dictionary">The dictionary.</param>
            <param name="comparer">The comparer.</param>
        </member>
        <member name="M:CodeSmith.Engine.SerializableDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.SerializableDictionary`2"/> class.
            </summary>
            <param name="capacity">The capacity.</param>
            <param name="comparer">The comparer.</param>
        </member>
        <member name="M:CodeSmith.Engine.SerializableDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.SerializableDictionary`2"/> class.
            </summary>
            <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo"/> object containing the information required to serialize the <see cref="T:System.Collections.Generic.Dictionary`2"/>.</param>
            <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext"/> structure containing the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.Dictionary`2"/>.</param>
        </member>
        <member name="M:CodeSmith.Engine.SerializableDictionary`2.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <summary>
            This property is reserved, apply the 
            <see cref="T:XmlSchemaProviderAttribute" /> to the class instead.
            </summary>
            <returns>
            An <see cref="T:System.Xml.Schema.XmlSchema" />
            that describes the XML representation of the object that 
            is produced by the <see cref="M:IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />
            method and consumed by the <see cref="M:IXmlSerializable.ReadXml(System.Xml.XmlReader)" />
            method.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.SerializableDictionary`2.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <summary>
            Generates an object from its XML representation.
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader" />
            stream from which the object is deserialized.</param>
        </member>
        <member name="M:CodeSmith.Engine.SerializableDictionary`2.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <summary>
            Converts an object into its XML representation.
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter" />
            stream to which the object is serialized.</param>
        </member>
        <member name="T:CodeSmith.Engine.IndexedEnumerable">
            <summary>
            IndexedEnumerable makes enumerating over collections much easier by implementing properties like: IsEven, IsOdd, IsLast.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.IndexedEnumerable.Create``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns an IndexedEnumerable from any collection implementing IEnumerable&lt;T&gt;
            </summary>
            <typeparam name="T">Type of enumerable</typeparam>
            <param name="source">Source enumerable</param>
            <returns>A new IndexedEnumerable&lt;T&gt;.</returns>
        </member>
        <member name="M:CodeSmith.Engine.IndexedEnumerable.AsIndexedEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns an IndexedEnumerable from any collection implementing IEnumerable&lt;T&gt;
            </summary>
            <typeparam name="T">Type of enumerable</typeparam>
            <param name="source">Source enumerable</param>
            <returns>A new IndexedEnumerable&lt;T&gt;.</returns>
        </member>
        <member name="T:CodeSmith.Engine.IndexedEnumerable`1">
            <summary>
            IndexedEnumerable makes enumerating over collections much easier by implementing properties like: IsEven, IsOdd, IsLast.
            </summary>
            <typeparam name="T">Type to iterate over</typeparam>
        </member>
        <member name="M:CodeSmith.Engine.IndexedEnumerable`1.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.IndexedEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructor that takes an IEnumerable&lt;T&gt;
            </summary>
            <param name="enumerable">The collection to enumerate.</param>
        </member>
        <member name="M:CodeSmith.Engine.IndexedEnumerable`1.GetEnumerator">
            <summary>
            Returns an enumeration of Entry objects.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.IndexedEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Non-generic form of GetEnumerator.
            </summary>
        </member>
        <member name="T:CodeSmith.Engine.IndexedEnumerable`1.EntryItem">
            <summary>
            Represents each entry returned within a collection,
            containing the _value and whether it is the first and/or
            the last entry in the collection's. enumeration
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.IndexedEnumerable`1.EntryItem.Value">
            <summary>
            The Entry Value.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.IndexedEnumerable`1.EntryItem.IsFirst">
            <summary>
            Returns true if it is the first item in the collection.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.IndexedEnumerable`1.EntryItem.IsLast">
            <summary>
            Returns true if it is the last item in the collection.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.IndexedEnumerable`1.EntryItem.Index">
            <summary>
            The index of the current item in the collection.
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.IndexedEnumerable`1.EntryItem.IsEven">
            <summary>
            Returns true if the current item has an even index
            </summary>
        </member>
        <member name="P:CodeSmith.Engine.IndexedEnumerable`1.EntryItem.IsOdd">
            <summary>
            Returns true if the current item has an odd index
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.IsPlural(System.String)">
            <summary>
            Determines if a string is in plural form based on some simple rules.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.IsSingular(System.String)">
            <summary>
            Determines if a string is in singular form based on some simple rules.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.ToPlural(System.String)">
            <summary>
            Converts a string to plural based on some simple rules.
            </summary>
            <param name="value">The value to convert.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.ToPlural(System.String,System.String)">
            <summary>
            Converts a string to plural based on some simple rules.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="pluralOverridesMapFile">The plural overrides map file.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.ToPlural(System.String,CodeSmith.Engine.MapCollection)">
            <summary>
            Converts a string to plural based on some simple rules.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="pluralOverridesMap">The plural overrides map.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.ToSingular(System.String)">
            <summary>
            Converts a string to singular based on some simple rules.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.ToSingular(System.String,System.String)">
            <summary>
            Converts a string to singular based on some simple rules.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="pluralOverridesMapFile">The plural overrides map file.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.ToSingular(System.String,CodeSmith.Engine.MapCollection)">
            <summary>
            Converts a string to singular based on some simple rules.
            </summary>
            <param name="value">The value to convert.</param>
            <param name="pluralOverridesMap">The plural overrides map.</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.ToCamelCase(System.String)">
            <summary>
            Converts a string to use camelCase.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.ToPascalCase(System.String)">
            <summary>
            Converts a string to use PascalCase.
            </summary>
            <param name="value">Text to convert</param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.ToSpacedWords(System.String)">
            <summary>
            Takes a NameIdentifier and spaces it out into words "Name Identifier".
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.ContainsSpace(System.String)">
            <summary>
            Determines if a string value contains a space.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.ContainsString(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines if a string value contains any of the strings passed in.
            </summary>
            <param name="source"></param>
            <param name="wordList"></param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.IsNumeric(System.String)">
            <summary>
            Determines if a string is a numeric value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.AppendOrdinalSuffix(System.String)">
            <summary>
            Takes a number and appends the ordinal suffix. ie. 1 = 1st, 13 = 13th.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.StringUtil.AppendOrdinalSuffix(System.Int32)">
            <summary>
            Takes a number and appends the ordinal suffix. ie. 1 = 1st, 13 = 13th.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"/> class.
            </summary>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>Initializes a new instance of the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IDictionary`2"></see> and uses the default equality comparer for the key type.</summary>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IDictionary`2"></see> whose elements are copied to the new <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</param>
            <exception cref="T:System.ArgumentException">dictionary contains one or more duplicate keys.</exception>
            <exception cref="T:System.ArgumentNullException">dictionary is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Initializes a new instance of the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> class that is empty, has the default initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"></see>.</summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"></see> implementation to use when comparing keys, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"></see> for the type of the key.</param>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.#ctor(System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> class that is empty, has the specified initial capacity, and uses the default equality comparer for the key type.</summary>
            <param name="capacity">The initial number of elements that the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> can contain.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">capacity is less than 0.</exception>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Initializes a new instance of the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> class that contains elements copied from the specified <see cref="T:System.Collections.Generic.IDictionary`2"></see> and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"></see>.</summary>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IDictionary`2"></see> whose elements are copied to the new <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"></see> implementation to use when comparing keys, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"></see> for the type of the key.</param>
            <exception cref="T:System.ArgumentException">dictionary contains one or more duplicate keys.</exception>
            <exception cref="T:System.ArgumentNullException">dictionary is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Initializes a new instance of the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> class that is empty, has the specified initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"></see>.</summary>
            <param name="capacity">The initial number of elements that the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> can contain.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"></see> implementation to use when comparing keys, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"></see> for the type of the key.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">capacity is less than 0.</exception>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.Add(`0,`1)">
            <summary>Adds the specified key and value to the dictionary.</summary>
            <param name="value">The value of the element to add. The value can be null for reference types.</param>
            <param name="key">The key of the element to add.</param>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</exception>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.Clear">
            <summary>Removes all keys and values from the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</summary>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> contains the specified key.</summary>
            <returns>true if the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> contains an element with the specified key; otherwise, false.</returns>
            <param name="key">The key to locate in the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</param>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.ContainsValue(`1)">
            <summary>Determines whether the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> contains a specific value.</summary>
            <returns>true if the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> contains an element with the specified value; otherwise, false.</returns>
            <param name="value">The value to locate in the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>. The value can be null for reference types.</param>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.GetEnumerator">
            <summary>Returns an enumerator that iterates through the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</summary>
            <returns>A <see cref="T:System.Collections.Generic.Dictionary`2.Enumerator"></see> structure for the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Implements the <see cref="T:System.Runtime.Serialization.ISerializable"></see> interface and returns the data needed to serialize the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> instance.</summary>
            <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext"></see> structure that contains the source and destination of the serialized stream associated with the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> instance.</param>
            <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> object that contains the information required to serialize the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> instance.</param>
            <exception cref="T:System.ArgumentNullException">info is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.OnDeserialization(System.Object)">
            <summary>Implements the <see cref="T:System.Runtime.Serialization.ISerializable"></see> interface and raises the deserialization event when the deserialization is complete.</summary>
            <param name="sender">The source of the deserialization event.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> object associated with the current <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> instance is invalid.</exception>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.Remove(`0)">
            <summary>Removes the value with the specified key from the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</summary>
            <returns>true if the element is successfully found and removed; otherwise, false.  This method returns false if key is not found in the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</returns>
            <param name="key">The key of the element to remove.</param>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.</param>
            <returns>
            true if the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.GetReadLock">
            <summary>
            Gets the read lock.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.ThreadSafeDictionary`2.GetWriteLock">
            <summary>
            Gets the write lock.
            </summary>
            <returns></returns>
        </member>
        <member name="P:CodeSmith.Engine.ThreadSafeDictionary`2.Comparer">
            <summary>Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1"></see> that is used to determine equality of keys for the dictionary. </summary>
            <returns>The <see cref="T:System.Collections.Generic.IEqualityComparer`1"></see> generic interface implementation that is used to determine equality of keys for the current <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see> and to provide hash values for the keys.</returns>
        </member>
        <member name="P:CodeSmith.Engine.ThreadSafeDictionary`2.Count">
            <summary>Gets the number of key/value pairs contained in the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</summary>
            <returns>The number of key/value pairs contained in the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</returns>
        </member>
        <member name="P:CodeSmith.Engine.ThreadSafeDictionary`2.Item(`0)">
            <summary>Gets or sets the value associated with the specified key.</summary>
            <returns>The value associated with the specified key. If the specified key is not found, a get operation throws a <see cref="T:System.Collections.Generic.KeyNotFoundException"></see>, and a set operation creates a new element with the specified key.</returns>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and key does not exist in the collection.</exception>
        </member>
        <member name="P:CodeSmith.Engine.ThreadSafeDictionary`2.Keys">
            <summary>Gets a collection containing the keys in the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</summary>
            <returns>A <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection"></see> containing the keys in the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</returns>
        </member>
        <member name="P:CodeSmith.Engine.ThreadSafeDictionary`2.Values">
            <summary>Gets a collection containing the values in the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</summary>
            <returns>A <see cref="T:System.Collections.Generic.Dictionary`2.ValueCollection"></see> containing the values in the <see cref="T:CodeSmith.Engine.ThreadSafeDictionary`2"></see>.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Util.TryGetValue(System.Reflection.PropertyInfo,System.Object,System.Object[])">
            <summary>
            Safely returns a value if GetValue succeeded, otherwise it returns null.
            </summary>
            <param name="property">The Source Property</param>
            <param name="value">The object whose property value will be returned.</param>
            <param name="index">Optional index values for indexed properties. This value should be null for non-indexed properties.</param>
        </member>
        <member name="M:CodeSmith.Engine.Util.TryEnumIsDefined(System.Type,System.Object)">
            <summary>
            Will try and parse an enum and it's default type.
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns>True if the enum value is defined.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Util.GetEnumDefaultValue(System.Type)">
            <summary>
            Gets the default defined value of an enum.
            </summary>
            <param name="type">The enum.</param>
            <returns>If the value cannot be determined, 0 will be returned.</returns>
        </member>
        <member name="M:CodeSmith.Engine.Util.TryGetEnumDefaultValue``1(System.Type,System.Object@)">
            <summary>
            Attempts to get the default value of an enum.
            </summary>
            <typeparam name="T">The System Type.</typeparam>
            <param name="type"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:CodeSmith.Engine.VersionCheck.GetLatestVersionInfo">
            <summary>
            Gets the latest released version number of CodeSmith that has been released.
            </summary>
            <returns>
            If an internet connection was detected it will return the version information of the latest released version of CodeSmith.
            If an internet connection could not be found then it returns null.
            </returns>
        </member>
        <member name="M:CodeSmith.Engine.VersionCheck.GetCurrentVersion">
            <summary>
            Returns the Assembly file version information for the CodeSmith.Engine assembly.
            </summary>
            <returns>Returns the Assembly file version information for the CodeSmith.Engine assembly.</returns>
        </member>
        <member name="M:CodeSmith.Engine.VersionCheck.GetShortVersion">
            <summary>
            Returns the current version information in the following format: 5.2.0000 (Major.Minor.Revision)
            </summary>
            <returns>Returns the current version information in the following format: 5.2.0000 (Major.Minor.Revision)</returns>
        </member>
        <member name="M:CodeSmith.Engine.VersionCheck.GetShortBuild">
            <summary>
            Returns the current version information in the following format: 5.2.0000 (Major.Minor.Build)
            </summary>
            <returns>Returns the current version information in the following format: 5.2.0000 (Major.Minor.Build)</returns>
        </member>
        <member name="M:CodeSmith.Engine.VersionCheck.GetVersionNumber">
            <summary>
            Returns the current version information in the following format: 5.2 (Major.Minor)
            </summary>
            <returns>Returns the current version information in the following format: 5.2 (Major.Minor)</returns>
        </member>
        <member name="T:Ionic.Zlib.CRC32">
            <summary>
            Calculates a 32bit Cyclic Redundancy Checksum (CRC) using the same polynomial
            used by Zip. This type is used internally by DotNetZip; it is generally not used
            directly by applications wishing to create, read, or manipulate zip archive
            files.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Zlib.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Ionic.Zlib.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
            Get the CRC32 for the given (word,byte) combo.  This is a computation
            defined by PKzip.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:Ionic.Zlib.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:Ionic.Zlib.CRC32.Combine(System.Int32,System.Int32)">
            <summary>
            Combines the given CRC32 value with the current running total.
            </summary>
            <remarks>
            This is useful when using a divide-and-conquer approach to calculating a CRC.
            Multiple threads can each calculate a CRC32 on a segment of the data, and then
            combine the individual CRC32 values at the end.
            </remarks>
            <param name="crc">the crc value to be combined with this one</param>
            <param name="length">the length of data the CRC value was calculated on</param>
        </member>
        <member name="P:Ionic.Zlib.CRC32.TotalBytesRead">
            <summary>
            indicates the total number of bytes read on the CRC stream.
            This is used when writing the ZipDirEntry when compressing files.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CrcCalculatorStream">
             <summary>
             A Stream that calculates a CRC32 (a checksum) on all bytes read,
             or on all bytes written.
             </summary>
            
             <remarks>
             <para>
             This class can be used to verify the CRC of a ZipEntry when
             reading from a stream, or to calculate a CRC when writing to a
             stream.  The stream should be used to either read, or write, but
             not both.  If you intermix reads and writes, the results are not
             defined.
             </para>
            
             <para>
             This class is intended primarily for use internally by the
             DotNetZip library.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.CrcCalculatorStream.#ctor(System.IO.Stream)">
            <summary>
            The default constructor.
            </summary>
            <remarks>
            Instances returned from this constructor will leave the underlying stream
            open upon Close().
            </remarks>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="M:Ionic.Zlib.CrcCalculatorStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            The constructor allows the caller to specify how to handle the underlying
            stream at close.
            </summary>
            <param name="stream">The underlying stream</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the CrcCalculatorStream.; false otherwise.</param>
        </member>
        <member name="M:Ionic.Zlib.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
            A constructor allowing the specification of the length of the stream to read.
            </summary>
            <remarks>
            Instances returned from this constructor will leave the underlying stream open
            upon Close().
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
        </member>
        <member name="M:Ionic.Zlib.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean)">
            <summary>
            A constructor allowing the specification of the length of the stream to
            read, as well as whether to keep the underlying stream open upon Close().
            </summary>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the CrcCalculatorStream.; false otherwise.</param>
        </member>
        <member name="M:Ionic.Zlib.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zlib.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream.
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="M:Ionic.Zlib.CrcCalculatorStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Not implemented.
            </summary>
            <param name="offset">N/A</param>
            <param name="origin">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:Ionic.Zlib.CrcCalculatorStream.SetLength(System.Int64)">
            <summary>
            Not implemented.
            </summary>
            <param name="value">N/A</param>
        </member>
        <member name="M:Ionic.Zlib.CrcCalculatorStream.Close">
            <summary>
            Closes the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.CrcCalculatorStream.TotalBytesSlurped">
             <summary>
             Gets the total number of bytes run through the CRC32 calculator.
             </summary>
            
             <remarks>
             This is either the total number of bytes read, or the total number of bytes
             written, depending on the direction of this stream.
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.CrcCalculatorStream.Crc">
            <summary>
            Provides the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.CrcCalculatorStream.LeaveOpen">
            <summary>
            Indicates whether the underlying stream will be left open when the
            CrcCalculatorStream is Closed.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.CrcCalculatorStream.CanRead">
            <summary>
            Indicates whether the stream supports reading.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.CrcCalculatorStream.CanSeek">
            <summary>
            Indicates whether the stream supports seeking.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.CrcCalculatorStream.CanWrite">
            <summary>
            Indicates whether the stream supports writing.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.CrcCalculatorStream.Length">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.CrcCalculatorStream.Position">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.FlushType">
            <summary>
            Describes how to flush the current deflate operation. 
            </summary>
            <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.FlushType.None">
            <summary>No flush at all.</summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Partial">
            <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This was supposed to be removed by Zlib, but it is
            still in use in some edge cases. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Sync">
            <summary>
            Use this during compression to specify that all pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Full">
            <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.FlushType.Finish">
            <summary>Signals the end of the compression/decompression stream.</summary>
        </member>
        <member name="T:Ionic.Zlib.DeflateStream">
             <summary>
             A class for compressing and decompressing streams using the Deflate algorithm.
             </summary>
            
             <remarks>
            
             <para>
             The DeflateStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream"/>.  It adds DEFLATE compression or decompression to any stream.
             </para>
            
             <para> Using this stream, applications can compress or decompress data via
             stream <c>Read</c> and <c>Write</c> operations.  Either compresssion or
             decompression can occur through either reading or writing. The compression
             format used is DEFLATE, which is documented in <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
             Compressed Data Format Specification version 1.3.".</para>
            
             <para>
             This class is similar to <see cref="T:Ionic.Zlib.ZlibStream"/>, except that <c>ZlibStream</c>
             adds the <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see>
             framing bytes to a compressed stream when compressing, or expects the RFC1950
             framing bytes when decompressing. The <c>DeflateStream</c> does not.
             </para>
            
             </remarks>
            
             <seealso cref="T:Ionic.Zlib.DeflateStream"/>
             <seealso cref="T:Ionic.Zlib.GZipStream"/>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
            <summary>
            Create a DeflateStream using the specified CompressionMode.
            </summary>
            
            <remarks> When mode is <c>CompressionMode.Compress</c>, the DeflateStream
            will use the default compression level. The "captive" stream will be closed
            when the DeflateStream is closed.  </remarks>
            
            <example>
            This example uses a DeflateStream to compress data from a file, and writes
            the compressed data to another file.
            <code>
            using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
            {
                using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                {
                    using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
                    {
                        byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                        int n;
                        while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                        {
                            compressor.Write(buffer, 0, n);
                        }
                    }
                }
            }
            </code>
            <code lang="VB">
            Using input As Stream = File.OpenRead(fileToCompress)
                Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                    Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
                        Dim buffer As Byte() = New Byte(4096) {}
                        Dim n As Integer = -1
                        Do While (n &lt;&gt; 0)
                            If (n &gt; 0) Then
                                compressor.Write(buffer, 0, n)
                            End If
                            n = input.Read(buffer, 0, buffer.Length)
                        Loop
                    End Using
                End Using
            End Using
            </code>
            </example>
            <param name="stream">The stream which will be read or written.</param>
            <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
             Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
            
             <remarks>
            
             <para> When mode is <c>CompressionMode.Decompress</c>, the level parameter
             is ignored.  The "captive" stream will be closed when the DeflateStream is
             closed.
             </para>
            
             </remarks>
            
             <example>
             This example uses a DeflateStream to compress data from a file, and writes
             the compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw,
                                                                  CompressionMode.Compress, 
                                                                  CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0) 
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>DeflateStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified
               <c>CompressionMode</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compression.  Specify true for
               the <paramref name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               The <c>DeflateStream</c> will use the default compression level.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the 
               "captive" stream in other places in this documentation.
             </param>
            
             <param name="mode">
               Indicates whether the <c>DeflateStream</c> will compress or decompress.
             </param>
            
             <param name="leaveOpen">true if the application would like the stream to
             remain open after inflation/deflation.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify whether
               the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored. 
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter
               to leave the stream open.
             </para>
            
             </remarks>
            
             <example>
             
               This example shows how to use a <c>DeflateStream</c> to compress data from
               a file, and store the compressed data into another file.
             
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0) 
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
            
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Dispose(System.Boolean)">
            <summary>
            Dispose the stream.  
            </summary>
            <remarks>
            This may or may not result in a <c>Close()</c> call on the captive stream. 
            See the constructors that have a <c>leaveOpen</c> parameter for more information.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream. 
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, providing an uncompressed data stream.
               Then call Read() on that <c>DeflateStream</c>, and the data read will be
               compressed as you read.  If you wish to use the <c>DeflateStream</c> to
               decompress data while reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, providing a readable compressed data
               stream.  Then call Read() on that <c>DeflateStream</c>, and the data read
               will be decompressed as you read.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both. 
             </para>
            
             </remarks>
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream. 
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, and a writable output stream.  Then call
               <c>Write()</c> on that <c>DeflateStream</c>, providing uncompressed data
               as input.  The data sent to the output stream will be the compressed form
               of the data written.  If you wish to use the <c>DeflateStream</c> to
               decompress data while writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, and a writable output stream.  Then
               call <c>Write()</c> on that stream, providing previously compressed
               data. The data sent to the output stream will be the decompressed form of
               the data written.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>,
               but not both.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using DEFLATE.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])"/>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using DEFLATE.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
               A buffer to compress. 
             </param>
            
             <returns>The data in compressed form</returns> 
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a single string.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing GZIP-compressed data.  
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a byte array.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing data that has been compressed with DEFLATE.  
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.  
            </summary>
            <remarks> See the ZLIB documentation for the meaning of the flush behavior.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec. 
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
             <remarks>
               By tweaking this parameter, you may be able to optimize the compression for 
               data with particular characteristics.
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.DeflateStream.Position">
             <summary>
             The position of the stream pointer. 
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="T:Ionic.Zip.EncryptionAlgorithm">
             <summary>
             An enum that provides the various encryption algorithms supported by this
             library.
             </summary>
            
             <remarks>
            
             <para>
               <c>PkzipWeak</c> implies the use of Zip 2.0 encryption, which is known to be
               weak and subvertible.
             </para>
            
             <para>
               A note on interoperability: Values of <c>PkzipWeak</c> and <c>None</c> are
               specified in <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's zip
               specification</see>, and are considered to be "standard".  Zip archives
               produced using these options will be interoperable with many other zip tools
               and libraries, including Windows Explorer.
             </para>
            
             <para>
               Values of <c>WinZipAes128</c> and <c>WinZipAes256</c> are not part of the Zip
               specification, but rather imply the use of a vendor-specific extension from
               WinZip. If you want to produce interoperable Zip archives, do not use these
               values.  For example, if you produce a zip archive using WinZipAes256, you
               will be able to open it in Windows Explorer on Windows XP and Vista, but you
               will not be able to extract entries; trying this will lead to an "unspecified
               error". For this reason, some people have said that a zip archive that uses
               WinZip's AES encryption is not actually a zip archive at all.  A zip archive
               produced this way will be readable with the WinZip tool (Version 11 and
               beyond).
             </para>
            
             <para>
               There are other third-party tools and libraries, both commercial and
               otherwise, that support WinZip's AES encryption. These will be able to read
               AES-encrypted zip archives produced by DotNetZip, and conversely applications
               that use DotNetZip to read zip archives will be able to read AES-encrypted
               archives produced by those tools or libraries.  Consult the documentation for
               those other tools and libraries to find out if WinZip's AES encryption is
               supported.
             </para>
            
             <para>
               In case you care: According to <see href="http://www.winzip.com/aes_info.htm">the WinZip specification</see>, the
               actual AES key used is derived from the <see cref="P:Ionic.Zip.ZipEntry.Password"/> via an
               algorithm that complies with <see href="http://www.ietf.org/rfc/rfc2898.txt">RFC 2898</see>, using an iteration
               count of 1000.  The algorithm is sometimes referred to as PBKDF2, which stands
               for "Password Based Key Derivation Function #2".
             </para>
            
             <para>
               A word about password strength and length: The AES encryption technology is
               very good, but any system is only as secure as the weakest link.  If you want
               to secure your data, be sure to use a password that is hard to guess.  To make
               it harder to guess (increase its "entropy"), you should make it longer.  If
               you use normal characters from an ASCII keyboard, a password of length 20 will
               be strong enough that it will be impossible to guess.  For more information on
               that, I'd encourage you to read <see href="http://www.redkestrel.co.uk/Articles/RandomPasswordStrength.html">this
               article.</see>
             </para>
            
             <para>
               The WinZip AES algorithms are not supported with the version of DotNetZip that
               runs on the .NET Compact Framework.  This is because .NET CF lacks the
               HMACSHA1 class that is required for producing the archive.
             </para>
             </remarks>
        </member>
        <member name="F:Ionic.Zip.EncryptionAlgorithm.None">
            <summary>
            No encryption at all.
            </summary>
        </member>
        <member name="F:Ionic.Zip.EncryptionAlgorithm.PkzipWeak">
            <summary>
            Traditional or Classic pkzip encryption.
            </summary>
        </member>
        <member name="F:Ionic.Zip.EncryptionAlgorithm.Unsupported">
            <summary>
            An encryption algorithm that is not supported by DotNetZip.
            </summary>
        </member>
        <member name="T:Ionic.Zip.WriteDelegate">
             <summary>
               Delegate in which the application writes the <c>ZipEntry</c> content for the named entry.
             </summary>
            
             <param name="entryName">The name of the entry that must be written.</param>
             <param name="stream">The stream to which the entry data should be written.</param>
            
             <remarks>
               When you add an entry and specify a <c>WriteDelegate</c>, via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)"/>, the application
               code provides the logic that writes the entry data directly into the zip file.
             </remarks>
            
             <example>
            
             This example shows how to define a WriteDelegate that obtains a DataSet, and then 
             writes the XML for the DataSet into the zip archive.  There's no need to 
             save the XML to a disk file first. 
             
             <code lang="C#">
             private void WriteEntry (String filename, Stream output)
             {
                 DataSet ds1 = ObtainDataSet();
                 ds1.WriteXml(output);
             }
             
             private void Run()
             {
                 using (var zip = new ZipFile())
                 {
                     zip.AddEntry(zipEntryName, WriteEntry);
                     zip.Save(zipFileName);
                 }
             }
             </code>
            
             <code lang="vb">
             Private Sub WriteEntry (ByVal filename As String, ByVal output As Stream) 
                 DataSet ds1 = ObtainDataSet()
                 ds1.WriteXml(stream)
             End Sub
             
             Public Sub Run()
                 Using zip = New ZipFile
                     zip.AddEntry(zipEntryName, New WriteDelegate(AddressOf WriteEntry))
                     zip.Save(zipFileName)
                 End Using
             End Sub
             </code> 
             </example>
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)"/>
        </member>
        <member name="T:Ionic.Zip.OpenDelegate">
             <summary>
               Delegate in which the application opens the stream, just-in-time, for the named entry.
             </summary>
             
             <param name="entryName">
             The name of the ZipEntry that the application should open the stream for.
             </param>
             
             <remarks>
               When you add an entry via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>, the application code provides the logic that
               opens and closes the stream for the given ZipEntry. 
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>
        </member>
        <member name="T:Ionic.Zip.CloseDelegate">
             <summary>
               Delegate in which the application closes the stream, just-in-time, for the named entry.
             </summary>
             
             <param name="entryName">
             The name of the ZipEntry that the application should close the stream for.
             </param>
             
             <param name="stream">The stream to be closed.</param>
            
             <remarks>
               When you add an entry via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>, the application code provides the logic that
               opens and closes the stream for the given ZipEntry. 
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>
        </member>
        <member name="T:Ionic.Zip.SetCompressionCallback">
             <summary>
               Delegate for the callback by which the application tells the
               library the CompressionLevel to use for a file.
             </summary>
            
             <remarks>
             <para>
               Using this callback, the application can, for example, specify that
               previously-compressed files (.mp3, .png, .docx, etc) should use a
               <c>CompressionLevel</c> of <c>None</c>, or can set the compression level based
               on any other factor.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.SetCompression"/>
        </member>
        <member name="T:Ionic.Zip.ZipProgressEventType">
            <summary>
            In an EventArgs type, indicates which sort of progress event is being reported. 
            </summary>
            <remarks>
            There are events for reading, events for saving, and events for extracting. 
            </remarks>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Adding_Started">
            <summary>
            Indicates that a Add() operation has started.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Adding_AfterAddEntry">
            <summary>
            Indicates that an individual entry in the archive has been added.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Adding_Completed">
            <summary>
            Indicates that a Add() operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_Started">
            <summary>
            Indicates that a Read() operation has started.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_BeforeReadEntry">
            <summary>
            Indicates that an individual entry in the archive is about to be read.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_AfterReadEntry">
            <summary>
            Indicates that an individual entry in the archive has just been read.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_Completed">
            <summary>
            Indicates that a Read() operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Reading_ArchiveBytesRead">
            <summary>
            The given event reports the number of bytes read so far
            during a Read() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_Started">
            <summary>
            Indicates that a Save() operation has started.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry">
            <summary>
            Indicates that an individual entry in the archive is about to be written.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry">
            <summary>
            Indicates that an individual entry in the archive has just been saved.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_Completed">
            <summary>
            Indicates that a Save() operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterSaveTempArchive">
            <summary>
            Indicates that the zip archive has been created in a
            temporary location during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeRenameTempArchive">
            <summary>
            Indicates that the temporary file is about to be renamed to the final archive 
            name during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterRenameTempArchive">
            <summary>
            Indicates that the temporary file is has just been renamed to the final archive 
            name during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterCompileSelfExtractor">
            <summary>
            Indicates that the self-extracting archive has been compiled
            during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Saving_EntryBytesRead">
            <summary>
            The given event is reporting the number of source bytes that have run through the compressor so far
            during a Save() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_BeforeExtractEntry">
            <summary>
            Indicates that an entry is about to be extracted. 
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractEntry">
            <summary>
            Indicates that an entry has just been extracted. 
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite">
            <summary>
            Indicates that extraction of an entry would overwrite an existing filesystem file. 
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_EntryBytesWritten">
            <summary>
            The given event is reporting the number of bytes written so far for the current entry
            during an Extract() operation.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_BeforeExtractAll">
            <summary>
            Indicates that an ExtractAll operation is about to begin.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractAll">
            <summary>
            Indicates that an ExtractAll operation has completed.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipProgressEventType.Error_Saving">
            <summary>
            Indicates that an error has occurred while saving a zip file. 
            This generally means the file cannot be opened, because it has been
            removed, or because it is locked by another process.  It can also 
            mean that the file cannot be Read, because of a range lock conflict. 
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipProgressEventArgs">
            <summary>
            Provides information about the progress of a save, read, or extract operation. 
            This is a base class; you will probably use one of the classes derived from this one.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.EntriesTotal">
            <summary>
            The total number of entries to be saved or extracted.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.CurrentEntry">
            <summary>
            The name of the last entry saved or extracted.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.Cancel">
            <summary>
            In an event handler, set this to cancel the save or extract 
            operation that is in progress.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.EventType">
            <summary>
            The type of event being reported.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.ArchiveName">
            <summary>
            Returns the archive name associated to this event.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.BytesTransferred">
            <summary>
            The number of bytes read or written so far for this entry.  
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipProgressEventArgs.TotalBytesToTransfer">
            <summary>
            Total number of bytes that will be read or written for this entry.
            This number will be -1 if the value cannot be determined. 
            </summary>
        </member>
        <member name="T:Ionic.Zip.ReadProgressEventArgs">
            <summary>
            Provides information about the progress of a Read operation.
            </summary>
        </member>
        <member name="T:Ionic.Zip.AddProgressEventArgs">
            <summary>
            Provides information about the progress of a Add operation.
            </summary>
        </member>
        <member name="T:Ionic.Zip.SaveProgressEventArgs">
            <summary>
            Provides information about the progress of a save operation.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SaveProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,Ionic.Zip.ZipEntry)">
            <summary>
            Constructor for the SaveProgressEventArgs.
            </summary>
            <param name="archiveName">the name of the zip archive.</param>
            <param name="before">whether this is before saving the entry, or after</param>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesSaved">Number of entries that have been saved.</param>
            <param name="entry">The entry involved in the event.</param>
        </member>
        <member name="P:Ionic.Zip.SaveProgressEventArgs.EntriesSaved">
            <summary>
            Number of entries saved so far.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ExtractProgressEventArgs">
            <summary>
            Provides information about the progress of the extract operation.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ExtractProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,Ionic.Zip.ZipEntry,System.String)">
            <summary>
            Constructor for the ExtractProgressEventArgs.
            </summary>
            <param name="archiveName">the name of the zip archive.</param>
            <param name="before">whether this is before saving the entry, or after</param>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesExtracted">Number of entries that have been extracted.</param>
            <param name="entry">The entry involved in the event.</param>
            <param name="extractLocation">The location to which entries are extracted.</param>
        </member>
        <member name="P:Ionic.Zip.ExtractProgressEventArgs.EntriesExtracted">
            <summary>
            Number of entries extracted so far.  This is set only if the 
            EventType is Extracting_BeforeExtractEntry or Extracting_AfterExtractEntry, and 
            the Extract() is occurring witin the scope of a call to ExtractAll().
            </summary>
        </member>
        <member name="P:Ionic.Zip.ExtractProgressEventArgs.ExtractLocation">
            <summary>
            Returns the extraction target location, a filesystem path. 
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipErrorEventArgs">
            <summary>
            Provides information about the an error that occurred while zipping. 
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipErrorEventArgs.Exception">
            <summary>
            Returns the exception that occurred, if any.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipErrorEventArgs.FileName">
            <summary>
            Returns the name of the file that caused the exception, if any.
            </summary>
        </member>
        <member name="T:Ionic.Zip.BadPasswordException">
            <summary>
            Issued when an <c>ZipEntry.ExtractWithPassword()</c> method is invoked
            with an incorrect password.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipException">
            <summary>
            Base class for all exceptions defined by and throw by the Zip library.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.ZipException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.BadReadException">
            <summary>
            Indicates that a read was attempted on a stream, and bad or incomplete data was
            received.  
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadReadException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.BadCrcException">
            <summary>
            Issued when an CRC check fails upon extracting an entry from a zip archive.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadCrcException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadCrcException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadCrcException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.SfxGenerationException">
            <summary>
            Issued when errors occur saving a self-extracting archive.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SfxGenerationException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SfxGenerationException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.SfxGenerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.BadStateException">
            <summary>
            Indicates that an operation was attempted on a ZipFile which was not possible
            given the state of the instance. For example, if you call <c>Save()</c> on a ZipFile 
            which has no filename set, you can get this exception. 
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:Ionic.Zip.BadStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:Ionic.Zip.ExtractExistingFileAction">
             <summary>
             An enum for the options when extracting an entry would overwrite an existing file. 
             </summary>
             
             <remarks>
               <para>
                 This enum describes the actions that the library can take when an
                 <c>Extract()</c> or <c>ExtractWithPassword()</c> method is called to extract an
                 entry to a filesystem, and the extraction would overwrite an existing filesystem
                 file.
               </para>
             </remarks>
            
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.Throw">
            <summary>
            Throw an exception when extraction would overwrite an existing file. (For
            COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.OverwriteSilently">
            <summary>
            When extraction would overwrite an existing file, overwrite the file silently.
            The overwrite will happen even if the target file is marked as read-only.
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.DoNotOverwrite">
            <summary>
            When extraction would overwrite an existing file, don't overwrite the file, silently. 
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ExtractExistingFileAction.InvokeExtractProgressEvent">
            <summary>
            When extraction would overwrite an existing file, invoke the ExtractProgress
            event, using an event type of <see cref="F:Ionic.Zip.ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite"/>.  In
            this way, the application can decide, just-in-time, whether to overwrite the
            file. For example, a GUI application may wish to pop up a dialog to allow
            the user to choose. You may want to examine the <see cref="P:Ionic.Zip.ExtractProgressEventArgs.ExtractLocation"/> property before making
            the decision. If, after your processing in the Extract progress event, you
            want to NOT extract the file, set <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
            on the <c>ZipProgressEventArgs.CurrentEntry</c> to <c>DoNotOverwrite</c>.
            If you do want to extract the file, set <c>ZipEntry.ExtractExistingFile</c>
            to <c>OverwriteSilently</c>.  If you want to cancel the Extraction, set
            <c>ZipProgressEventArgs.Cancel</c> to true.  Cancelling differs from using
            DoNotOverwrite in that a cancel will not extract any further entries, if
            there are any.  (For COM clients, the value of this enum is a 3.)
            </summary>
        </member>
        <member name="T:Ionic.LogicalConjunction">
            <summary>
            Enumerates the options for a logical conjunction. This enum is intended for use
            internally by the FileSelector class.
            </summary>
        </member>
        <member name="T:Ionic.FileSelector">
             <summary>
               FileSelector encapsulates logic that selects files from a source - a zip file
               or the filesystem - based on a set of criteria.  This class is used internally
               by the DotNetZip library, in particular for the AddSelectedFiles() methods.
               This class can also be used independently of the zip capability in DotNetZip.
             </summary>
            
             <remarks>
            
             <para>
               The FileSelector class is used internally by the ZipFile class for selecting
               files for inclusion into the ZipFile, when the <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)"/> method, or one of
               its overloads, is called.  It's also used for the <see cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String)"/> methods.  Typically, an
               application that creates or manipulates Zip archives will not directly
               interact with the FileSelector class.
             </para>
            
             <para>
               Some applications may wish to use the FileSelector class directly, to
               select files from disk volumes based on a set of criteria, without creating or
               querying Zip archives.  The file selection criteria include: a pattern to
               match the filename; the last modified, created, or last accessed time of the
               file; the size of the file; and the attributes of the file.
             </para>
            
             <para>
               Consult the documentation for <see cref="P:Ionic.FileSelector.SelectionCriteria"/>
               for more information on specifying the selection criteria.
             </para>
            
             </remarks>
        </member>
        <member name="M:Ionic.FileSelector.#ctor(System.String)">
             <summary>
             Constructor that allows the caller to specify file selection criteria.
             </summary>
            
             <remarks>
             <para>
             This constructor allows the caller to specify a set of criteria for selection of files.
             </para>
            
             <para>
             See <see cref="P:Ionic.FileSelector.SelectionCriteria"/> for a description of the syntax of
             the selectionCriteria string.
             </para>
            
             <para>
             By default the FileSelector will traverse NTFS Reparse Points.
             To change this, use <see cref="M:Ionic.FileSelector.#ctor(System.String,System.Boolean)">FileSelector(String, bool)</see>.
             </para>
             </remarks>
            
             <param name="selectionCriteria">The criteria for file selection.</param>
        </member>
        <member name="M:Ionic.FileSelector.#ctor(System.String,System.Boolean)">
             <summary>
             Constructor that allows the caller to specify file selection criteria.
             </summary>
            
             <remarks>
             <para>
             This constructor allows the caller to specify a set of criteria for selection of files.
             </para>
            
             <para>
             See <see cref="P:Ionic.FileSelector.SelectionCriteria"/> for a description of the syntax of
             the selectionCriteria string.
             </para>
             </remarks>
            
             <param name="selectionCriteria">The criteria for file selection.</param>
             <param name="traverseDirectoryReparsePoints">
             whether to traverse NTFS reparse points (junctions).
             </param>
        </member>
        <member name="M:Ionic.FileSelector.ToString">
            <summary>
            Returns a string representation of the FileSelector object.
            </summary>
            <returns>The string representation of the boolean logic statement of the file
            selection criteria for this instance. </returns>
        </member>
        <member name="M:Ionic.FileSelector.SelectFiles(System.String)">
             <summary>
             Returns the names of the files in the specified directory
             that fit the selection criteria specified in the FileSelector.
             </summary>
            
             <remarks>
             This is equivalent to calling <see cref="M:Ionic.FileSelector.SelectFiles(System.String,System.Boolean)"/>
             with recurseDirectories = false.
             </remarks>
            
             <param name="directory">
             The name of the directory over which to apply the FileSelector criteria.
             </param>
            
             <returns>
             A collection of strings containing fully-qualified pathnames of files
             that match the criteria specified in the FileSelector instance.
             </returns>
        </member>
        <member name="M:Ionic.FileSelector.SelectFiles(System.String,System.Boolean)">
             <summary>
             Returns the names of the files in the specified directory that fit the selection
             criteria specified in the FileSelector, optionally recursing through subdirectories.
             </summary>
            
             <remarks>
             This method applies the file selection criteria contained in the FileSelector to the
             files contained in the given directory, and returns the names of files that
             conform to the criteria.
             </remarks>
            
             <param name="directory">
             The name of the directory over which to apply the FileSelector criteria.
             </param>
            
             <param name="recurseDirectories">
             Whether to recurse through subdirectories when applying the file selection criteria.
             </param>
            
             <returns>
             An collection of strings containing fully-qualified pathnames of files
             that match the criteria specified in the FileSelector instance.
             </returns>
        </member>
        <member name="M:Ionic.FileSelector.SelectEntries(Ionic.Zip.ZipFile)">
             <summary>
             Retrieve the ZipEntry items in the ZipFile that conform to the specified criteria.
             </summary>
             <remarks>
            
             <para>
             This method applies the criteria set in the FileSelector instance (as described in
             the <see cref="P:Ionic.FileSelector.SelectionCriteria"/>) to the specified ZipFile.  Using this
             method, for example, you can retrieve all entries from the given ZipFile that
             have filenames ending in .txt.
             </para>
            
             <para>
             Normally, applications would not call this method directly.  This method is used
             by the ZipFile class.
             </para>
            
             <para>
             Using the appropriate SelectionCriteria, you can retrieve entries based on size,
             time, and attributes. See <see cref="P:Ionic.FileSelector.SelectionCriteria"/> for a
             description of the syntax of the SelectionCriteria string.
             </para>
            
             </remarks>
            
             <param name="zip">The ZipFile from which to retrieve entries.</param>
            
             <returns>a collection of ZipEntry objects that conform to the criteria.</returns>
        </member>
        <member name="M:Ionic.FileSelector.SelectEntries(Ionic.Zip.ZipFile,System.String)">
             <summary>
             Retrieve the ZipEntry items in the ZipFile that conform to the specified criteria.
             </summary>
             <remarks>
            
             <para>
             This method applies the criteria set in the FileSelector instance (as described in
             the <see cref="P:Ionic.FileSelector.SelectionCriteria"/>) to the specified ZipFile.  Using this
             method, for example, you can retrieve all entries from the given ZipFile that
             have filenames ending in .txt.
             </para>
            
             <para>
             Normally, applications would not call this method directly.  This method is used
             by the ZipFile class.
             </para>
            
             <para>
             This overload allows the selection of ZipEntry instances from the ZipFile to be restricted
             to entries contained within a particular directory in the ZipFile.
             </para>
            
             <para>
             Using the appropriate SelectionCriteria, you can retrieve entries based on size,
             time, and attributes. See <see cref="P:Ionic.FileSelector.SelectionCriteria"/> for a
             description of the syntax of the SelectionCriteria string.
             </para>
            
             </remarks>
            
             <param name="zip">The ZipFile from which to retrieve entries.</param>
            
             <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            
             <returns>a collection of ZipEntry objects that conform to the criteria.</returns>
        </member>
        <member name="P:Ionic.FileSelector.SelectionCriteria">
             <summary>
             The string specifying which files to include when retrieving.
             </summary>
             <remarks>
            
             <para>
             Specify the criteria in statements of 3 elements: a noun, an operator, and a value.
             Consider the string "name != *.doc" .  The noun is "name".  The operator is "!=",
             implying "Not Equal".  The value is "*.doc".  That criterion, in English, says "all
             files with a name that does not end in the .doc extension."
             </para>
            
             <para>
             Supported nouns include "name" for the filename; "atime", "mtime", and "ctime" for
             last access time, last modfied time, and created time of the file, respectively;
             "attributes" for the file attributes; and "size" for the file length (uncompressed).
             The "attributes" and "name" nouns both support = and != as operators.  The "size",
             "atime", "mtime", and "ctime" nouns support = and !=, and &gt;, &gt;=, &lt;, &lt;=
             as well.
             </para>
            
             <para>
             Specify values for the file attributes as a string with one or more of the
             characters H,R,S,A,I in any order, implying Hidden, ReadOnly, System, Archive, and
             NotContextIndexed, respectively.  To specify a time, use YYYY-MM-DD-HH:mm:ss or
             YYYY/MM/DD-HH:mm:ss as the format.  If you omit the HH:mm:ss portion, it is assumed
             to be 00:00:00 (midnight). The value for a size criterion is expressed in integer
             quantities of bytes, kilobytes (use k or kb after the number), megabytes (m or mb),
             or gigabytes (g or gb).  The value for a name is a pattern to match against the
             filename, potentially including wildcards.  The pattern follows CMD.exe glob rules:
             * implies one or more of any character, while ?  implies one character.  If the name
             pattern contains any slashes, it is matched to the entire filename, including the
             path; otherwise, it is matched against only the filename without the path.  This
             means a pattern of "*\*.*" matches all files one directory level deep, while a
             pattern of "*.*" matches all files in all directories.  </para>
            
             <para>
             To specify a name pattern that includes spaces, use single quotes around the pattern.
             A pattern of "'* *.*'" will match all files that have spaces in the filename.  The full
             criteria string for that would be "name = '* *.*'" .
             </para>
            
             <para>
             Some examples:
             </para>
            
             <list type="table">
               <listheader>
                 <term>criteria</term>
                 <description>Files retrieved</description>
               </listheader>
            
               <item>
                 <term>name != *.xls </term>
                 <description>any file with an extension that is not .xls
                 </description>
               </item>
            
               <item>
                 <term>name = *.mp3 </term>
                 <description>any file with a .mp3 extension.
                 </description>
               </item>
            
               <item>
                 <term>*.mp3</term>
                 <description>(same as above) any file with a .mp3 extension.
                 </description>
               </item>
            
               <item>
                 <term>attributes = A </term>
                 <description>all files whose attributes include the Archive bit.
                 </description>
               </item>
            
               <item>
                 <term>attributes != H </term>
                 <description>all files whose attributes do not include the Hidden bit.
                 </description>
               </item>
            
               <item>
                 <term>mtime &gt; 2009-01-01</term>
                 <description>all files with a last modified time after January 1st, 2009.
                 </description>
               </item>
            
               <item>
                 <term>ctime &gt; 2009/01/01-03:00:00</term>
                 <description>all files with a created time after 3am (local time), on January 1st, 2009.
                 </description>
               </item>
            
               <item>
                 <term>size &gt; 2gb</term>
                 <description>all files whose uncompressed size is greater than 2gb.
                 </description>
               </item>
            
             </list>
            
             <para>
             You can combine criteria with the conjunctions AND, OR, and XOR. Using a string like
             "name = *.txt AND size &gt;= 100k" for the selectionCriteria retrieves entries whose
             names end in .txt, and whose uncompressed size is greater than or equal to 100
             kilobytes.
             </para>
            
             <para>
             For more complex combinations of criteria, you can use parenthesis to group clauses
             in the boolean logic.  Absent parenthesis, the precedence of the criterion atoms is
             determined by order of appearance.  Unlike the C# language, the AND conjunction does
             not take precendence over the logical OR.  This is important only in strings that
             contain 3 or more criterion atoms.  In other words, "name = *.txt and size &gt; 1000
             or attributes = H" implies "((name = *.txt AND size &gt; 1000) OR attributes = H)"
             while "attributes = H OR name = *.txt and size &gt; 1000" evaluates to "((attributes
             = H OR name = *.txt) AND size &gt; 1000)".  When in doubt, use parenthesis.
             </para>
            
             <para>
             Using time properties requires some extra care. If you want to retrieve all entries
             that were last updated on 2009 February 14, specify "mtime &gt;= 2009-02-14 AND
             mtime &lt; 2009-02-15".  Read this to say: all files updated after 12:00am on
             February 14th, until 12:00am on February 15th.  You can use the same bracketing
             approach to specify any time period - a year, a month, a week, and so on.
             </para>
            
             <para>
             The syntax allows one special case: if you provide a string with no spaces, it is treated as
             a pattern to match for the filename.  Therefore a string like "*.xls" will be equivalent to
             specifying "name = *.xls".  This "shorthand" notation does not work with compound criteria.
             </para>
            
             <para>
             There is no logic in this class that insures that the inclusion criteria
             are internally consistent.  For example, it's possible to specify criteria that
             says the file must have a size of less than 100 bytes, as well as a size that
             is greater than 1000 bytes.  Obviously no file will ever satisfy such criteria,
             but this class does not check for or detect such inconsistencies.
             </para>
            
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown in the setter if the value has an invalid syntax.
             </exception>
        </member>
        <member name="P:Ionic.FileSelector.TraverseReparsePoints">
            <summary>
             Indicates whether searches will traverse NTFS reparse points, like Junctions.
            </summary>
        </member>
        <member name="T:Ionic.EnumUtil">
            <summary>
            Summary description for EnumUtil.
            </summary>
        </member>
        <member name="M:Ionic.EnumUtil.GetDescription(System.Enum)">
            <summary>
            Returns the value of the DescriptionAttribute if the specified Enum value has one.
            If not, returns the ToString() representation of the Enum value.
            </summary>
            <param name="value">The Enum to get the description for</param>
            <returns></returns>
        </member>
        <member name="M:Ionic.EnumUtil.Parse(System.Type,System.String)">
            <summary>
            Converts the string representation of the name or numeric value of one or more
            enumerated constants to an equivalent enumerated object.
            Note: use the DescriptionAttribute on enum values to enable this.
            </summary>
            <param name="enumType">The System.Type of the enumeration.</param>
            <param name="stringRepresentation">A string containing the name or value to convert.</param>
            <returns></returns>
        </member>
        <member name="M:Ionic.EnumUtil.Parse(System.Type,System.String,System.Boolean)">
            <summary>
            Converts the string representation of the name or numeric value of one or more
            enumerated constants to an equivalent enumerated object.
            A parameter specified whether the operation is case-sensitive.
            Note: use the DescriptionAttribute on enum values to enable this.
            </summary>
            <param name="enumType">The System.Type of the enumeration.</param>
            <param name="stringRepresentation">A string containing the name or value to convert.</param>
            <param name="ignoreCase">Whether the operation is case-sensitive or not.</param>
            <returns></returns>
        </member>
        <member name="T:Ionic.Zlib.GZipStream">
             <summary>
               A class for compressing and decompressing GZIP streams.
             </summary>
             <remarks>
            
             <para>
               The <c>GZipStream</c> is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a
               <see cref="T:System.IO.Stream"/>. It adds GZIP compression or decompression to any
               stream.
             </para>
            
             <para>
               Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base Class Library, the
               <c>Ionic.Zlib.GZipStream</c> can compress while writing, or decompress while
               reading, but not vice versa.  The compression method used is GZIP, which is
               documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC
               1952</see>, "GZIP file format specification version 4.3".</para>
            
             <para>
               A <c>GZipStream</c> can be used to decompress data (through <c>Read()</c>) or
               to compress data (through <c>Write()</c>), but not both.
             </para>
            
             <para>
               If you wish to use the <c>GZipStream</c> to compress data, you must wrap it
               around a write-able stream. As you call <c>Write()</c> on the <c>GZipStream</c>, the
               data will be compressed into the GZIP format.  If you want to decompress data,
               you must wrap the <c>GZipStream</c> around a readable stream that contains an
               IETF RFC 1952-compliant stream.  The data will be decompressed as you call
               <c>Read()</c> on the <c>GZipStream</c>.
             </para>
            
             <para>
               Though the GZIP format allows data from multiple files to be concatenated
               together, this stream handles only a single segment of GZIP format, typically
               representing a single file.
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.ZlibStream"/> and <see cref="T:Ionic.Zlib.DeflateStream"/>.
               <c>ZlibStream</c> handles RFC1950-compliant streams.  <see cref="T:Ionic.Zlib.DeflateStream"/>
               handles RFC1951-compliant streams. This class handles RFC1952-compliant streams.
             </para>
            
             </remarks>
            
             <seealso cref="T:Ionic.Zlib.DeflateStream"/>
             <seealso cref="T:Ionic.Zlib.ZlibStream"/>
        </member>
        <member name="F:Ionic.Zlib.GZipStream.LastModified">
             <summary>
               The last modified time for the GZIP stream.
             </summary>
            
             <remarks>
               GZIP allows the storage of a last modified time with each GZIP entry.
               When compressing data, you can set this before the first call to
               <c>Write()</c>.  When decompressing, you can retrieve this value any time
               after the first call to <c>Read()</c>.
             </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>GZipStream</c> will use the
               default compression level.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with
               <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a GZipStream to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <example>
             This example shows how to use a GZipStream to uncompress a file.
             <code>
             private void GunZipFile(string filename)
             {
                 if (!filename.EndsWith(".gz))
                     throw new ArgumentException("filename");
                 var DecompressedFile = filename.Substring(0,filename.Length-3);
                 byte[] working = new byte[WORKING_BUFFER_SIZE];
                 int n= 1;
                 using (System.IO.Stream input = System.IO.File.OpenRead(filename))
                 {
                     using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                     {
                         using (var output = System.IO.File.Create(DecompressedFile))
                         {
                             while (n !=0)
                             {
                                 n= decompressor.Read(working, 0, working.Length);
                                 if (n > 0)
                                 {
                                     output.Write(working, 0, n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub GunZipFile(ByVal filename as String)
                 If Not (filename.EndsWith(".gz)) Then
                     Throw New ArgumentException("filename")
                 End If
                 Dim DecompressedFile as String = filename.Substring(0,filename.Length-3)
                 Dim working(WORKING_BUFFER_SIZE) as Byte
                 Dim n As Integer = 1
                 Using input As Stream = File.OpenRead(filename)
                     Using decompressor As Stream = new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, True)
                         Using output As Stream = File.Create(UncompressedFile)
                             Do
                                 n= decompressor.Read(working, 0, working.Length)
                                 If n > 0 Then
                                     output.Write(working, 0, n)
                                 End IF
                             Loop While (n  > 0)
                         End Using
                     End Using
                 End Using
             End Sub
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
             <remarks>
            
             <para>
               The <c>CompressionMode</c> (Compress or Decompress) also establishes the
               "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A
               <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a <c>GZipStream</c> to compress a file into a .gz file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
                 {
                     using (Stream compressor = new GZipStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
                     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>GZipStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the stream should be left open after Deflation
               or Inflation.
             </summary>
            
             <remarks>
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to leave
               the stream open.
             </para>
            
             <para>
               The <see cref="T:Ionic.Zlib.CompressionMode"/> (Compress or Decompress) also
               establishes the "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A <c>GZipStream</c>
               with <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             <para>
               The <c>GZipStream</c> will use the default compression level. If you want
               to specify the compression level, see <see cref="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)"/>.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the "captive"
               stream in other places in this documentation.
             </param>
            
             <param name="mode">Indicates whether the GZipStream will compress or decompress.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the base stream to remain open after
               inflation/deflation.
             </param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and the
               specified <c>CompressionLevel</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to
               leave the stream open.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a <c>GZipStream</c> to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Dispose(System.Boolean)">
            <summary>
            Dispose the stream.
            </summary>
            <remarks>
            This may or may not result in a <c>Close()</c> call on the captive stream.
            See the doc on constructors that take a <c>leaveOpen</c> parameter for more information.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read and decompress data from the source stream.
             </summary>
            
             <remarks>
               With a <c>GZipStream</c>, decompression is done through reading.
             </remarks>
            
             <example>
             <code>
             byte[] working = new byte[WORKING_BUFFER_SIZE];
             using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
             {
                 using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                 {
                     using (var output = System.IO.File.Create(_DecompressedFile))
                     {
                         int n;
                         while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                         {
                             output.Write(working, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
             <param name="buffer">The buffer into which the decompressed data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">irrelevant; it will always throw!</param>
            <param name="origin">irrelevant; it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.SetLength(System.Int64)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">irrelevant; this method will always throw!</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
             <para>
               If you wish to use the <c>GZipStream</c> to compress data while writing,
               you can create a <c>GZipStream</c> with <c>CompressionMode.Compress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that <c>GZipStream</c>,
               providing uncompressed data as input.  The data sent to the output stream
               will be the compressed form of the data written.
             </para>
            
             <para>
               A <c>GZipStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not
               both. Writing implies compression.  Reading implies decompression.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a single string.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing GZIP-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a byte array.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing data that has been compressed with GZip.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Comment">
             <summary>
               The comment on the GZIP stream.
             </summary>
            
             <remarks>
             <para>
               The GZIP format allows for each file to optionally have an associated
               comment stored with the file.  The comment is encoded with the ISO-8859-1
               code page.  To include a comment in a GZIP stream you create, set this
               property before calling <c>Write()</c> for the first time on the
               <c>GZipStream</c>.
             </para>
            
             <para>
               When using <c>GZipStream</c> to decompress, you can retrieve this property
               after the first call to <c>Read()</c>.  If no comment has been set in the
               GZIP bytestream, the Comment property will return <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.FileName">
             <summary>
               The FileName for the GZIP stream.
             </summary>
            
             <remarks>
            
             <para>
               The GZIP format optionally allows each file to have an associated
               filename.  When compressing data (through <c>Write()</c>), set this
               FileName before calling <c>Write()</c> the first time on the <c>GZipStream</c>.
               The actual filename is encoded into the GZIP bytestream with the
               ISO-8859-1 code page, according to RFC 1952. It is the application's
               responsibility to insure that the FileName can be encoded and decoded
               correctly with this code page.
             </para>
            
             <para>
               When decompressing (through <c>Read()</c>), you can retrieve this value
               any time after the first <c>Read()</c>.  In the case where there was no filename
               encoded into the GZIP bytestream, the property will return <c>null</c> (<c>Nothing</c>
               in VB).
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Crc32">
            <summary>
            The CRC on the GZIP stream.
            </summary>
            <remarks>
            This is used for internal error checking. You probably don't need to look at this property.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.GZipStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="T:Ionic.Zlib.ParallelDeflateOutputStream">
             <summary>
               A class for compressing and decompressing streams using the
               Deflate algorithm with multiple threads.
             </summary>
            
             <remarks>
             <para>
               This class is for compression only, and that can be only
               through writing.
             </para>
            
             <para>
               For more information on the Deflate algorithm, see IETF RFC 1951, "DEFLATE
               Compressed Data Format Specification version 1.3."
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.DeflateStream"/>, except
               that this implementation uses an approach that employs multiple worker
               threads to perform the DEFLATE.  On a multi-cpu or multi-core computer,
               the performance of this class can be significantly higher than the
               single-threaded DeflateStream, particularly for larger streams.  How
               large?  Anything over 10mb is a good candidate for parallel compression.
             </para>
            
             <para>
               The tradeoff is that this class uses more memory and more CPU than the
               vanilla DeflateStream, and also is less efficient as a compressor. For
               large files the size of the compressed data stream can be less than 1%
               larger than the size of a compressed data stream from the vanialla
               DeflateStream.  For smaller files the difference can be larger.  The
               difference will also be larger if you set the BufferSize to be lower
               than the default value.  Your mileage may vary. Finally, for small
               files, the ParallelDeflateOutputStream can be much slower than the vanilla
               DeflateStream, because of the overhead of using the thread pool.
             </para>
            
             </remarks>
             <seealso cref="T:Ionic.Zlib.DeflateStream"/>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)">
             <summary>
             Create a ParallelDeflateOutputStream.
             </summary>
             <remarks>
            
             <para>
               This stream compresses data written into it via the DEFLATE
               algorithm (see RFC 1951), and writes out the compressed byte stream.
             </para>
            
             <para>
               The instance will use the default compression level, the default
               buffer sizes and the default number of threads and buffers per
               thread.
             </para>
            
             <para>
               This class is similar to <see cref="T:Ionic.Zlib.DeflateStream"/>,
               except that this implementation uses an approach that employs
               multiple worker threads to perform the DEFLATE.  On a multi-cpu or
               multi-core computer, the performance of this class can be
               significantly higher than the single-threaded DeflateStream,
               particularly for larger streams.  How large?  Anything over 10mb is
               a good candidate for parallel compression.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a ParallelDeflateOutputStream to compress
             data.  It reads a file, compresses it, and writes the compressed data to
             a second, output file.
            
             <code>
             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
             int n= -1;
             String outputFile = fileToCompress + ".compressed";
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new ParallelDeflateOutputStream(raw))
                     {
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim buffer As Byte() = New Byte(4096) {}
             Dim n As Integer = -1
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                     Using compressor As Stream = New ParallelDeflateOutputStream(raw)
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to which compressed data will be written.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel)">
            <summary>
              Create a ParallelDeflateOutputStream using the specified CompressionLevel.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream using the specified
            CompressionLevel and CompressionStrategy, and specifying whether to
            leave the captive stream open when the ParallelDeflateOutputStream is
            closed.
            </summary>
            <remarks>
              See the <see cref="M:Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="strategy">
              By tweaking this parameter, you may be able to optimize the compression for
              data with particular characteristics.
            </param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
            
             <para>
               To use the ParallelDeflateOutputStream to compress data, create a
               ParallelDeflateOutputStream with CompressionMode.Compress, passing a
               writable output stream.  Then call Write() on that
               ParallelDeflateOutputStream, providing uncompressed data as input.  The
               data sent to the output stream will be the compressed form of the data
               written.
             </para>
            
             <para>
               To decompress data, use the <see cref="T:Ionic.Zlib.DeflateStream"/> class.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Close">
            <summary>
            Close the stream.
            </summary>
            <remarks>
            You must call Close on the stream to guarantee that all of the data written in has
            been compressed, and the compressed data has been written out.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Dispose">
            <summary>Dispose the object</summary>
            <remarks>
              <para>
                Because ParallelDeflateOutputStream is IDisposable, the
                application must call this method when finished using the instance.
              </para>
              <para>
                This method is generally called implicitly upon exit from
                a <c>using</c> scope in C# (<c>Using</c> in VB).
              </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Dispose(System.Boolean)">
            <summary>The Dispose method</summary>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Reset(System.IO.Stream)">
             <summary>
               Resets the stream for use with another stream.
             </summary>
             <remarks>
               Because the ParallelDeflateOutputStream is expensive to create, it
               has been designed so that it can be recycled and re-used.  You have
               to call Close() on the stream first, then you can call Reset() on
               it, to use it again on another stream.
             </remarks>
            
             <example>
             <code>
             ParallelDeflateOutputStream deflater = null;
             foreach (var inputFile in listOfFiles)
             {
                 string outputFile = inputFile + ".compressed";
                 using (System.IO.Stream input = System.IO.File.OpenRead(inputFile))
                 {
                     using (var outStream = System.IO.File.Create(outputFile))
                     {
                         if (deflater == null)
                             deflater = new ParallelDeflateOutputStream(outStream,
                                                                        CompressionLevel.Best,
                                                                        CompressionStrategy.Default,
                                                                        true);
                         deflater.Reset(outStream);
            
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             deflater.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotImplementedException.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            This method always throws a NotImplementedException.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ParallelDeflateOutputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotImplementedException.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.BuffersPerCore">
             <summary>
             The number of buffers per CPU or CPU core.
             </summary>
            
             <remarks>
             <para>
               This property sets the number of memory buffers to create, for every
               CPU or CPU core in the machine.  The divide-and-conquer approach
               taken by this class assumes a single thread from the application
               will call Write().  There will be multiple background threads that
               then compress (DEFLATE) the data written into the stream, and also a
               single output thread, also operating in the background, aggregating
               those results and finally emitting the output.
             </para>
            
             <para>
               The default value is 4.  Different values may deliver better or
               worse results, depending on the dynamic performance characteristics
               of your storage and compute resources.
             </para>
            
             <para>
               The total amount of storage space allocated for buffering will be
               (n*M*S*2), where n is the number of CPUs, M is the multiple (this
               property), S is the size of each buffer (<see cref="P:Ionic.Zlib.ParallelDeflateOutputStream.BufferSize"/>),
               and there are 2 buffers used by the compressor, one for input and
               one for output. For example, if your machine has 4 cores, and you
               set BuffersPerCore to 3, and you retain the default buffer size of
               128k, then the ParallelDeflateOutputStream will use 3mb of buffer
               memory in total.
             </para>
            
             <para>
               The application can set this value at any time, but it is effective
               only before the first call to Write(), which is when the buffers are
               allocated.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.BufferSize">
             <summary>
               The size of the buffers used by the compressor threads.
             </summary>
             <remarks>
            
             <para>
               The default buffer size is 128k. The application can set this value at any
               time, but it is effective only before the first Write().
             </para>
            
             <para>
               Larger buffer sizes implies larger memory consumption but allows
               more efficient compression. Using smaller buffer sizes consumes less
               memory but result in less effective compression.  For example, using
               the default buffer size of 128k, the compression delivered is within
               1% of the compression delivered by the single-threaded <see cref="T:Ionic.Zlib.DeflateStream"/>.  On the other hand, using a
               BufferSize of 8k can result in a compressed data stream that is 5%
               larger than that delivered by the single-threaded
               <c>DeflateStream</c>.  Excessively small buffer sizes can also cause
               the speed of the ParallelDeflateOutputStream to drop, because of
               larger thread scheduling overhead dealing with many many small
               buffers.
             </para>
            
             <para>
               The total amount of storage space allocated for buffering will be
               (n*M*S*2), where n is the number of CPUs, M is the multiple (<see cref="P:Ionic.Zlib.ParallelDeflateOutputStream.BuffersPerCore"/>), S is the size of each buffer (this
               property), and there are 2 buffers used by the compressor, one for
               input and one for output. For example, if your machine has a total
               of 4 cores, and if you set <see cref="P:Ionic.Zlib.ParallelDeflateOutputStream.BuffersPerCore"/> to 3, and
               you keep the default buffer size of 128k, then the
               <c>ParallelDeflateOutputStream</c> will use 3mb of buffer memory in
               total.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Crc32">
            <summary>
            The CRC32 for the data that was written out, prior to compression.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.BytesProcessed">
            <summary>
            The total number of uncompressed bytes processed by the ParallelDeflateOutputStream.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanRead">
            <summary>
            Indicates whether the stream supports Read operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.CanWrite">
            <summary>
            Indicates whether the stream supports Write operations.
            </summary>
            <remarks>
            Returns true if the provided stream is writable.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Length">
            <summary>
            Reading this property always throws a NotImplementedException.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ParallelDeflateOutputStream.Position">
            <summary>
            Reading or Writing this property always throws a NotImplementedException.
            </summary>
        </member>
        <member name="T:Ionic.Zip.SharedUtilities">
            <summary>
            Collects general purpose utility methods.
            </summary>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.#ctor">
            private null constructor
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.NormalizePathForUseInZipFile(System.String)">
            <summary>
            Utility routine for transforming path names from filesystem format (on Windows that means backslashes) to
            a format suitable for use within zipfiles. This means trimming the volume letter and colon (if any) And
            swapping backslashes for forward slashes.
            </summary>
            <param name="pathName">source path.</param>
            <returns>transformed path</returns>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.FindSignature(System.IO.Stream,System.Int32)">
             <summary>
               Finds a signature in the zip stream. This is useful for finding
               the end of a zip entry, for example, or the beginning of the next ZipEntry.
             </summary>
            
             <remarks>
               <para>
                 Scans through 64k at a time.
               </para>
            
               <para>
                 If the method fails to find the requested signature, the stream Position
                 after completion of this method is unchanged. If the method succeeds in
                 finding the requested signature, the stream position after completion is
                 direct AFTER the signature found in the stream.
               </para>
             </remarks>
            
             <param name="stream">The stream to search</param>
             <param name="SignatureToFind">The 4-byte signature to find</param>
             <returns>The number of bytes read</returns>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.CreateAndOpenUniqueTempFile(System.String,System.IO.Stream@,System.String@)">
            <summary>
            Create a pseudo-random filename, suitable for use as a temporary file, and open it.
            </summary>
            <remarks>
            <para>
            The System.IO.Path.GetRandomFileName() method is not available on the Compact
            Framework, so this library provides its own substitute on NETCF.
            </para>
            <para>
            produces a filename of the form DotNetZip-xxxxxxxx.tmp, where xxxxxxxx is replaced
            by randomly chosen characters, and creates that file.
            </para>
            </remarks>
        </member>
        <member name="M:Ionic.Zip.SharedUtilities.ReadWithRetry(System.IO.Stream,System.Byte[],System.Int32,System.Int32,System.String)">
            <summary>
            Workitem 7889: handle ERROR_LOCK_VIOLATION during read
            </summary>
            <remarks>
            This could be gracefully handled with an extension attribute, but
            This assembly is built for .NET 2.0, so I cannot use them.
            </remarks>
        </member>
        <member name="T:Ionic.Zip.CountingStream">
            <summary>
            A Stream wrapper, used for bookkeeping on input or output
            streams.  In some cases, it is not possible to get the Position
            of a stream, let's say, on a write-only output stream like
            ASP.NET's Response.Output, or on a different write-only stream
            provided as the destination for the zip by the application.
            In this case, we can use this counting stream to count the bytes
            read or written.
            </summary>
        </member>
        <member name="M:Ionic.Zip.CountingStream.#ctor(System.IO.Stream)">
            <summary>
            The  constructor.
            </summary>
            <param name="s">The underlying stream</param>
        </member>
        <member name="M:Ionic.Zlib.Tree.DistanceCode(System.Int32)">
            <summary>
            Map from a distance to a distance code.
            </summary>
            <remarks> 
            No side effects. _dist_code[256] and _dist_code[257] are never used.
            </remarks>
        </member>
        <member name="T:Ionic.Zip.ZipCrypto">
            <summary> 
            This class implements the "traditional" or "classic" PKZip encryption,
            which today is considered to be weak. On the other hand it is
            ubiquitous. This class is intended for use only by the DotNetZip library.
            </summary>
            <remarks>
            Most uses of the DotNetZip library will not involve direct calls into the
            ZipCrypto class.  Instead, the ZipCrypto class is instantiated and used by
            the ZipEntry() class when encryption or decryption on an entry is employed.
            If for some reason you really wanted to use a weak encryption algorithm
            in some other application, you might use this library.  But you would be much
            better off using one of the built-in strong encryption libraries in the 
            .NET Framework, like the AES algorithm or SHA. 
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.#ctor">
             <summary>
             The default constructor for ZipCrypto.
             </summary>
            
             <remarks>
             This class is intended for internal use by the library only. It's probably not useful to you. Seriously.
             Stop reading this documentation.  It's a waste of your time.  Go do something else.
             Check the football scores. Go get an ice cream with a friend.  Seriously.
             </remarks>
             
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.DecryptMessage(System.Byte[],System.Int32)">
            <summary> 
            Call this method on a cipher text to render the plaintext. You must
            first initialize the cipher with a call to InitCipher.
            </summary>          
            <example>
            <code>
            var cipher = new ZipCrypto();
            cipher.InitCipher(Password);
            // Decrypt the header.  This has a side effect of "further initializing the
            // encryption keys" in the traditional zip encryption. 
            byte[] DecryptedMessage = cipher.DecryptMessage(EncryptedMessage);
            </code>
            </example>
            <param name="cipherText">The encrypted buffer.</param>
            <param name="length">
            The number of bytes to encrypt.  
            Should be less than or equal to CipherText.Length.
            </param>
            <returns>The plaintext.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.EncryptMessage(System.Byte[],System.Int32)">
            <summary>
            This is the converse of DecryptMessage.  It encrypts the plaintext
            and produces a ciphertext. 
            </summary>
            <param name="plaintext">The plain text buffer.</param>
            <param name="length">
            The number of bytes to encrypt.  
            Should be less than or equal to PlainText.Length.
            </param>
            <returns>The ciphertext.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipCrypto.InitCipher(System.String)">
             <summary>
             This initializes the cipher with the given password. 
             See AppNote.txt for details. 
             </summary>
             <param name="passphrase">The passphrase for encrypting or decrypting with this cipher.
             </param>
             <remarks>
             <code>
             Step 1 - Initializing the encryption keys
             -----------------------------------------
             Start with these keys:        
             Key(0) := 305419896 (0x12345678)
             Key(1) := 591751049 (0x23456789)
             Key(2) := 878082192 (0x34567890)
             
             Then, initialize the keys with a password:
             
             loop for i from 0 to length(password)-1
                 update_keys(password(i))
             end loop
             
             Where update_keys() is defined as:
             
             update_keys(char):
               Key(0) := crc32(key(0),char)
               Key(1) := Key(1) + (Key(0) bitwiseAND 000000ffH)
               Key(1) := Key(1) * 134775813 + 1
               Key(2) := crc32(key(2),key(1) rightshift 24)
             end update_keys
             
             Where crc32(old_crc,char) is a routine that given a CRC value and a
             character, returns an updated CRC value after applying the CRC-32
             algorithm described elsewhere in this document.
            
             </code>
             <para>
             After the keys are initialized, then you can use the cipher to encrypt
             the plaintext. 
             </para>
             <para>
             Essentially we encrypt the password with the keys, then discard the 
             ciphertext for the password. This initializes the keys for later use.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipCrypto.MagicByte">
            <summary> 
            From AppNote.txt:
            unsigned char decrypt_byte()
                local unsigned short temp
                temp :=- Key(2) | 2
                decrypt_byte := (temp * (temp ^ 1)) bitshift-right 8
            end decrypt_byte
            </summary>          
        </member>
        <member name="T:Ionic.Zip.ZipCipherStream">
            <summary>
            A Stream for reading and concurrently decrypting data from a zip file, 
            or for writing and concurrently encrypting data to a zip file.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipCipherStream.#ctor(System.IO.Stream,Ionic.Zip.ZipCrypto,Ionic.Zip.CryptoMode)">
            <summary>
            The  constructor.
            </summary>
            <param name="s">The underlying stream</param>
            <param name="mode">To either encrypt or decrypt.</param>
            <param name="cipher">The pre-initialized ZipCrypto object.</param>
        </member>
        <member name="T:Ionic.Zip.ZipEntry">
            <summary>
            Represents a single entry in a ZipFile. Typically, applications get a ZipEntry
            by enumerating the entries within a ZipFile, or by adding an entry to a ZipFile.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ReadDirEntry(Ionic.Zip.ZipFile)">
            <summary>
            Reads one entry from the zip directory structure in the zip file.
            </summary>
            <param name="zf">
            The zipfile for which a directory entry will be read.  From this param, the
            method gets the ReadStream and the expected text encoding
            (ProvisionalAlternateEncoding) which is used if the entry is not marked
            UTF-8.
            </param>
            <returns>the entry read from the archive.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.IsNotValidZipDirEntrySig(System.Int32)">
            <summary>
            Returns true if the passed-in value is a valid signature for a ZipDirEntry.
            </summary>
            <param name="signature">the candidate 4-byte signature value.</param>
            <returns>true, if the signature is valid according to the PKWare spec.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.#ctor">
            <summary>
            Default constructor.
            </summary>
            <remarks>
            Applications should never need to call this directly.  It is exposed to
            support COM Automation environments.
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)">
             <summary>
               Sets the NTFS Creation, Access, and Modified times for the given entry.
             </summary>
            
             <remarks>
             <para>
               When adding an entry from a file or directory, the Creation, Access, and
               Modified times for the given entry are automatically set from the
               filesystem values. When adding an entry from a stream or string, the
               values are implicitly set to DateTime.Now.  The application may wish to
               set these values to some arbitrary value, before saving the archive, and
               can do so using the various setters.  If you want to set all of the times,
               this method is more efficient.
             </para>
            
             <para>
               The values you set here will be retrievable with the <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/> and <see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/> properties.
             </para>
            
             <para>
               When this method is called, if both <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> and <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/> are false, then the
               <c>EmitTimesInWindowsFormatWhenSaving</c> flag is automatically set.
             </para>
            
             <para>
               DateTime values provided here without a DateTimeKind are assumed to be Local Time.
             </para>
            
             </remarks>
             <param name="created">the creation time of the entry.</param>
             <param name="accessed">the last access time of the entry.</param>
             <param name="modified">the last modified time of the entry.</param>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract">
             <summary>
             Extract the entry to the filesystem, starting at the current working directory.
             </summary>
            
             <overloads>
             This method has a bunch of overloads! One of them is sure to be
             the right one for you... If you don't like these, check out the
             <c>ExtractWithPassword()</c> methods.
             </overloads>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.Extract(Ionic.Zip.ExtractExistingFileAction)"/>
            
             <remarks>
            
             <para> This method extracts an entry from a zip file into the current working
             directory.  The path of the entry as extracted is the full path as specified in
             the zip archive, relative to the current working directory.  After the file is
             extracted successfully, the file attributes and timestamps are set.  </para>
            
             <para>
             The action taken when extraction an entry would overwrite an existing file
             is determined by the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/> property.
             </para>
            
             <para>
             See the remarks the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some details
             about how the last modified time of the file is set after extraction.
             </para>
            
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(Ionic.Zip.ExtractExistingFileAction)">
            <summary>
            Extract the entry to a file in the filesystem, using the specified behavior
            when extraction would overwrite an existing file.
            </summary>
            <remarks>
            <para>
            See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some details
            about how the last modified time of the file is set after extraction.
            </para>
            </remarks>
            <param name="extractExistingFile">The action to take if extraction would
            overwrite an existing file.</param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)">
             <summary>
             Extracts the entry to the specified stream.
             </summary>
            
             <remarks>
            
             <para>
             The caller can specify any write-able stream, for example <see cref="M:System.Console.OpenStandardOutput"/>, a <see cref="T:System.IO.FileStream"/>, a <see cref="T:System.IO.MemoryStream"/>, or
             ASP.NET's <c>Response.OutputStream</c>.
             The content will be decrypted and decompressed as necessary. If the entry is
             encrypted and no password is provided, this method will throw.
             </para>
            
             </remarks>
            
             <param name="stream">the stream to which the entry should be extracted.  </param>
            
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(System.String)">
             <summary>
             Extract the entry to the filesystem, starting at the specified base directory.
             </summary>
            
             <param name="baseDirectory">the pathname of the base directory</param>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)"/>
            
             <example>
             This example extracts only the entries in a zip file that are .txt files,
             into a directory called "textfiles".
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                 {
                   zip[s1].Extract("textfiles");
                 }
               }
             }
             </code>
             <code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code>
             </example>
            
             <remarks>
            
             <para> Using this method, existing entries in the filesystem will not be
             overwritten. If you would like to force the overwrite of existing files, see the
             <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/> property, or call <see cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)"/>. </para>
            
             <para>
             See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some details
             about how the last modified time of the created file is set.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)">
             <summary>
             Extract the entry to the filesystem, starting at the specified base directory, and
             using the specified behavior when extraction would overwrite an existing file.
             </summary>
            
             <remarks>
             <para>
             See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some details
             about how the last modified time of the created file is set.
             </para>
             </remarks>
            
             <example>
             <code lang="C#">
             String sZipPath = "Airborne.zip";
             String sFilePath = "Readme.txt";
             String sRootFolder = "Digado";
             using (ZipFile zip = ZipFile.Read(sZipPath))
             {
               if (zip.EntryFileNames.Contains(sFilePath))
               {
                 // use the string indexer on the zip file
                 zip[sFileName].Extract(sRootFolder,
                                        ExtractExistingFileAction.OverwriteSilently);
               }
             }
             </code>
            
             <code lang="VB">
             Dim sZipPath as String = "Airborne.zip"
             Dim sFilePath As String = "Readme.txt"
             Dim sRootFolder As String = "Digado"
             Using zip As ZipFile = ZipFile.Read(sZipPath)
               If zip.EntryFileNames.Contains(sFilePath)
                 ' use the string indexer on the zip file
                 zip(sFilePath).Extract(sRootFolder, _
                                        ExtractExistingFileAction.OverwriteSilently)
               End If
             End Using
             </code>
             </example>
            
             <param name="baseDirectory">the pathname of the base directory</param>
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String)">
             <summary>
             Extract the entry to the filesystem, using the current working directory
             and the specified password.
             </summary>
            
             <overloads>
             This method has a bunch of overloads! One of them is sure to be
             the right one for you...
             </overloads>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)"/>
            
             <remarks>
            
             <para> Existing entries in the filesystem will not be overwritten. If you would
             like to force the overwrite of existing files, see the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>property, or call <see cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)"/>.</para>
            
             <para>
             See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property for some details
             about how the "last modified" time of the created file is set.
             </para>
             </remarks>
            
             <example>
             In this example, entries that use encryption are extracted using a particular password.
             <code>
             using (var zip = ZipFile.Read(FilePath))
             {
                 foreach (ZipEntry e in zip)
                 {
                     if (e.UsesEncryption)
                         e.ExtractWithPassword("Secret!");
                     else
                         e.Extract();
                 }
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(FilePath)
                 Dim e As ZipEntry
                 For Each e In zip
                     If (e.UsesEncryption)
                       e.ExtractWithPassword("Secret!")
                     Else
                       e.Extract
                     End If
                 Next
             End Using
             </code>
             </example>
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,System.String)">
             <summary>
             Extract the entry to the filesystem, starting at the specified base directory,
             and using the specified password.
             </summary>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,Ionic.Zip.ExtractExistingFileAction,System.String)"/>
            
             <remarks>
             <para> Existing entries in the filesystem will not be overwritten. If you would
             like to force the overwrite of existing files, see the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>property, or call <see cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)"/>.</para>
            
             <para>
             See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some details
             about how the last modified time of the created file is set.
             </para>
             </remarks>
            
             <param name="baseDirectory">The pathname of the base directory.</param>
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)">
             <summary>
             Extract the entry to a file in the filesystem, relative to the current directory,
             using the specified behavior when extraction would overwrite an existing file.
             </summary>
            
             <remarks>
             <para>
             See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some details
             about how the last modified time of the created file is set.
             </para>
             </remarks>
            
             <param name="password">The Password to use for decrypting the entry.</param>
            
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,Ionic.Zip.ExtractExistingFileAction,System.String)">
             <summary>
             Extract the entry to the filesystem, starting at the specified base directory, and
             using the specified behavior when extraction would overwrite an existing file.
             </summary>
            
             <remarks>
             See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some details
             about how the last modified time of the created file is set.
             </remarks>
            
             <param name="baseDirectory">the pathname of the base directory</param>
            
             <param name="extractExistingFile">The action to take if extraction would
             overwrite an existing file.</param>
            
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.IO.Stream,System.String)">
             <summary>
             Extracts the entry to the specified stream, using the specified Password.
             For example, the caller could extract to Console.Out, or to a MemoryStream.
             </summary>
            
             <remarks>
             See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property, for some details
             about how the last modified time of the created file is set.
             </remarks>
            
             <param name="stream">the stream to which the entry should be extracted.  </param>
             <param name="password">The password to use for decrypting the entry.</param>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.OpenReader">
             <summary>
             Opens the backing stream for the zip entry in the archive, for reading.
             </summary>
            
             <remarks>
            
             <para>
             DotNetZip offers a variety of ways to extract entries from a zip file.  This
             method allows an application to extract and entry by reading a Stream.
             </para>
            
             <para>
             The return value is a <see cref="T:Ionic.Zlib.CrcCalculatorStream"/>.  Use it
             as you would any stream for reading.  The data you get by calling <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> on that stream will be decrypted and
             decompressed.
             </para>
            
             <para>
             CrcCalculatorStream adds one additional feature: it keeps a CRC32 checksum
             on the bytes of the stream as it is read.  The CRC value is available in the
             <see cref="P:Ionic.Zlib.CrcCalculatorStream.Crc"/> property on the
             <c>CrcCalculatorStream</c>.  When the read is complete, this CRC
             <em>should</em> be checked against the <see cref="P:Ionic.Zip.ZipEntry.Crc"/> property
             on the <c>ZipEntry</c> to validate the content of the ZipEntry.  You don't
             have to validate the entry using the CRC, but you should. Check the example
             for how to do this.
             </para>
            
             <para>
             If the entry is protected with a password, then you need to provide a
             password prior to calling <see cref="M:Ionic.Zip.ZipEntry.OpenReader"/>, either by setting the
             <see cref="P:Ionic.Zip.ZipEntry.Password"/> property on the entry, or the <see cref="P:Ionic.Zip.ZipFile.Password"/> property on the <c>ZipFile</c> itself. Or, you can
             use <see cref="M:Ionic.Zip.ZipEntry.OpenReader(System.String)"/>, the overload of OpenReader that
             accepts a password parameter.
             </para>
            
             <para>
             If you want to extract entry data into a stream that is already opened, like
             a <see cref="T:System.IO.FileStream"/>, consider the <see cref="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)"/> method.
             </para>
            
             </remarks>
            
             <example>
             This example shows how to open a zip archive, then read in a named entry via
             a stream.  After the read loop is complete, the code compares the calculated
             during the read loop with the expected CRC on the <c>ZipEntry</c>, to verify
             the extraction.
             <code>
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               ZipEntry e1= zip["Elevation.mp3"];
               using (Ionic.Zlib.CrcCalculatorStream s = e1.OpenReader())
               {
                 byte[] buffer = new byte[4096];
                 int n, totalBytesRead= 0;
                 do {
                   n = s.Read(buffer,0, buffer.Length);
                   totalBytesRead+=n;
                 } while (n&gt;0);
                  if (s.Crc32 != e1.Crc32)
                   throw new Exception(string.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32));
                  if (totalBytesRead != e1.UncompressedSize)
                   throw new Exception(string.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize));
               }
             }
             </code>
             <code lang="VB">
               Using zip As New ZipFile(ZipFileToRead)
                   Dim e1 As ZipEntry = zip.Item("Elevation.mp3")
                   Using s As Ionic.Zlib.CrcCalculatorStream = e1.OpenReader
                       Dim n As Integer
                       Dim buffer As Byte() = New Byte(4096) {}
                       Dim totalBytesRead As Integer = 0
                       Do
                           n = s.Read(buffer, 0, buffer.Length)
                           totalBytesRead = (totalBytesRead + n)
                       Loop While (n &gt; 0)
                       If (s.Crc32 &lt;&gt; e1.Crc32) Then
                           Throw New Exception(String.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32))
                       End If
                       If (totalBytesRead &lt;&gt; e1.UncompressedSize) Then
                           Throw New Exception(String.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize))
                       End If
                   End Using
               End Using
             </code>
             </example>
             <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)"/>
             <returns>The Stream for reading.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.OpenReader(System.String)">
             <summary>
             Opens the backing stream for an encrypted zip entry in the archive, for reading.
             </summary>
            
             <remarks>
             <para>
             See the documentation on the <see cref="M:Ionic.Zip.ZipEntry.OpenReader"/> method for full
             details.  This overload allows the application to specify a password for the
             <c>ZipEntry</c> to be read.
             </para>
             </remarks>
            
             <param name="password">The password to use for decrypting the entry.</param>
             <returns>The Stream for reading.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ValidateOutput(System.String,System.IO.Stream,System.String@)">
            <summary>
            Validates that the args are consistent.
            </summary>
            <remarks>
            Only one of {baseDir, outStream} can be non-null.
            If baseDir is non-null, then the outputFile is created.
            </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.ReadEntry(Ionic.Zip.ZipContainer,System.Boolean)">
            <summary>
            Reads one <c>ZipEntry</c> from the given stream.  If the entry is encrypted, we don't
            decrypt at this point.  We also do not decompress.  Mostly we read metadata.
            </summary>
            <param name="zc">the ZipContainer this entry belongs to.</param>
            <param name="first">true of this is the first entry being read from the stream.</param>
            <returns>the <c>ZipEntry</c> read from the stream.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.PrepSourceStream">
             <summary>
               Stores the position of the entry source stream, or, if the position is
               already stored, seeks to that position.
             </summary>
            
             <remarks>
             <para>
               This method is called in prep for reading the source stream.  If PKZIP
               encryption is used, then we need to calc the CRC32 before doing the
               encryption, because the CRC is used in the 12th byte of the PKZIP
               encryption header.  So, we need to be able to seek backward in the source
               when saving the ZipEntry. This method is called from the place that
               calculates the CRC, and also from the method that does the encryption of
               the file data.
             </para>
            
             <para>
               The first time through, this method sets the _sourceStreamOriginalPosition
               field. Subsequent calls to this method seek to that position.
             </para>
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.CopyMetaData(Ionic.Zip.ZipEntry)">
            <summary>
            Copy metadata that may have been changed by the app.  We do this when
            resetting the zipFile instance.  If the app calls Save() on a ZipFile, then
            tries to party on that file some more, we may need to Reset() it , which
            means re-reading the entries and then copying the metadata.  I think.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipEntry.SetInputAndFigureFileLength(System.IO.Stream@)">
            <summary>
            Set the input stream and get its length, if possible.  The
            length is used for progress updates, AND, to allow an
            optimization in case of a stream/file of zero length. In
            that case we skip the Encrypt and DeflateStream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.AttributesIndicateDirectory">
            <summary>
            True if the referenced entry is a directory.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Info">
            <summary>
            Provides a human-readable string with information about the ZipEntry.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.LastModified">
             <summary>
               The time and date at which the file indicated by the <c>ZipEntry</c> was
               last modified.
             </summary>
            
             <remarks>
             <para>
               The DotNetZip library sets the LastModified value for an entry, equal to
               the Last Modified time of the file in the filesystem.  If an entry is
               added from a stream, the library uses <c>System.DateTime.Now</c> for this
               value, for the given entry.
             </para>
            
             <para>
               This property allows the application to retrieve and possibly set the
               LastModified value on an entry, to an arbitrary value.  <see cref="T:System.DateTime"/> values with a <see cref="T:System.DateTimeKind"/>
               setting of <c>DateTimeKind.Unspecified</c> are taken to be expressed as
               <c>DateTimeKind.Local</c>.
             </para>
            
             <para>
               Be aware that because of the way <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWare's
               Zip specification</see> describes how times are stored in the zip file,
               the full precision of the <c>System.DateTime</c> datatype is not stored
               for the last modified time when saving zip files.  For more information on
               how times are formatted, see the PKZip specification.
             </para>
            
             <para>
               The actual last modified time of a file can be stored in multiple ways in
               the zip file, and they are not mutually exclusive:
             </para>
            
             <list type="bullet">
               <item>
                 In the so-called "DOS" format, which has a 2-second precision. Values
                 are rounded to the nearest even second. For example, if the time on the
                 file is 12:34:43, then it will be stored as 12:34:44. This first value
                 is accessible via the <c>LastModified</c> property. This value is always
                 present in the metadata for each zip entry.  In some cases the value is
                 invalid, or zero.
               </item>
            
               <item>
                 In the so-called "Windows" or "NTFS" format, as an 8-byte integer
                 quantity expressed as the number of 1/10 milliseconds (in other words
                 the number of 100 nanosecond units) since January 1, 1601 (UTC).  This
                 format is how Windows represents file times.  This time is accessible
                 via the <c>ModifiedTime</c> property.
               </item>
            
               <item>
                 In the "Unix" format, a 4-byte quantity specifying the number of seconds since
                 January 1, 1970 UTC.
               </item>
            
               <item>
                 In an older format, now deprecated but still used by some current
                 tools. This format is also a 4-byte quantity specifying the number of
                 seconds since January 1, 1970 UTC.
               </item>
            
             </list>
            
             <para>
               Zip tools and libraries will always at least handle (read or write) the
               DOS time, and may also handle the other time formats.  Keep in mind that
               while the names refer to particular operating systems, there is nothing in
               the time formats themselves that prevents their use on other operating
               systems.
             </para>
            
             <para>
               When reading ZIP files, The DotNetZip library reads the Windoes-formatted
               time, if it is stored in the entry, and sets both <c>LastModified</c> and
               <c>ModifiedTime</c> to that value. When writing ZIP files, the DotNetZip
               library by default will write both time quantities. It can also emit the
               Unix-formatted time if desired (See <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>.)
             </para>
            
             <para>
               The last modified time of the file created upon a call to
               <c>ZipEntry.Extract()</c> may be adjusted during extraction to compensate
               for differences in how the .NET Base Class Library deals with daylight
               saving time (DST) versus how the Windows filesystem deals with daylight
               saving time.  Raymond Chen <see href="http://blogs.msdn.com/oldnewthing/archive/2003/10/24/55413.aspx">provides
               some good context</see>.
             </para>
            
             <para>
               In a nutshell: Daylight savings time rules change regularly.  In 2007, for
               example, the inception week of DST changed.  In 1977, DST was in place all
               year round. In 1945, likewise.  And so on.  Win32 does not attempt to
               guess which time zone rules were in effect at the time in question.  It
               will render a time as "standard time" and allow the app to change to DST
               as necessary.  .NET makes a different choice.
             </para>
            
             <para>
               Compare the output of FileInfo.LastWriteTime.ToString("f") with what you
               see in the Windows Explorer property sheet for a file that was last
               written to on the other side of the DST transition. For example, suppose
               the file was last modified on October 17, 2003, during DST but DST is not
               currently in effect. Explorer's file properties reports Thursday, October
               17, 2003, 8:45:38 AM, but .NETs FileInfo reports Thursday, October 17,
               2003, 9:45 AM.
             </para>
            
             <para>
               Win32 says, "Thursday, October 17, 2002 8:45:38 AM PST". Note: Pacific
               STANDARD Time. Even though October 17 of that year occurred during Pacific
               Daylight Time, Win32 displays the time as standard time because that's
               what time it is NOW.
             </para>
            
             <para>
               .NET BCL assumes that the current DST rules were in place at the time in
               question.  So, .NET says, "Well, if the rules in effect now were also in
               effect on October 17, 2003, then that would be daylight time" so it
               displays "Thursday, October 17, 2003, 9:45 AM PDT" - daylight time.
             </para>
            
             <para>
               So .NET gives a value which is more intuitively correct, but is also
               potentially incorrect, and which is not invertible. Win32 gives a value
               which is intuitively incorrect, but is strictly correct.
             </para>
            
             <para>
               Because of this funkiness, this library adds one hour to the LastModified
               time on the extracted file, if necessary.  That is to say, if the time in
               question had occurred in what the .NET Base Class Library assumed to be
               DST. This assumption may be wrong given the constantly changing DST rules,
               but it is the best we can do.
             </para>
            
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ModifiedTime">
             <summary>
             Last Modified time for the file represented by the entry.
             </summary>
            
             <remarks>
            
             <para>
               This value corresponds to the "last modified" time in the NTFS file times
               as described in <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</see>.  When getting this property, the value may be
               different from <see cref="P:Ionic.Zip.ZipEntry.LastModified"/>.  When setting the property,
               the <see cref="P:Ionic.Zip.ZipEntry.LastModified"/> property also gets set, but with a lower
               precision.
             </para>
            
             <para>
               Let me explain. It's going to take a while, so get
               comfortable. Originally, waaaaay back in 1989 when the ZIP specification
               was originally described by the esteemed Mr. Phil Katz, the dominant
               operating system of the time was MS-DOS. MSDOS stored file times with a
               2-second precision, because, c'mon, <em>who is ever going to need better
               resolution than THAT?</em> And so ZIP files, regardless of the platform on
               which the zip file was created, store file times in exactly <see href="http://www.vsft.com/hal/dostime.htm">the same format that DOS used
               in 1989</see>.
             </para>
            
             <para>
               Since then, the ZIP spec has evolved, but the internal format for file
               timestamps remains the same.  Despite the fact that the way times are
               stored in a zip file is rooted in DOS heritage, any program on any
               operating system can format a time in this way, and most zip tools and
               libraries DO - they round file times to the nearest even second and store
               it just like DOS did 25+ years ago.
             </para>
            
             <para>
               PKWare extended the ZIP specification to allow a zip file to store what
               are called "NTFS Times" and "Unix(tm) times" for a file.  These are the
               <em>last write</em>, <em>last access</em>, and <em>file creation</em>
               times of a particular file. These metadata are not actually specific to
               NTFS or Unix. They are tracked for each file by NTFS and by various Unix
               filesystems, but they are also tracked by other filesystems, too.  The key
               point is that the times are <em>formatted in the zip file</em> in the same
               way that NTFS formats the time (ticks since win32 epoch), or in the same
               way that Unix formats the time (seconds since Unix epoch).
             </para>
            
             <para>
               These extended times are higher precision quantities than the DOS time.
               As described above, the (DOS) LastModified has a precision of 2 seconds.
               The Unix time is stored with a precision of 1 second. The NTFS time is
               stored with a precision of 0.0000001 seconds. The quantities are easily
               convertible, except for the loss of precision you may incur.
             </para>
            
             <para>
               A zip archive can store the {C,A,M} times in NTFS format, in Unix format,
               or not at all.  Often a tool running on Unix or Mac will embed the times
               in Unix format (1 second precision), while WinZip running on Windows might
               embed the times in NTFS format (precision of of 0.0000001 seconds).  When
               reading a zip file with these "extended" times, in either format,
               DotNetZip represents the values with the
               <c>ModifiedTime</c>, <c>AccessedTime</c> and <c>CreationTime</c>
               properties on the <c>ZipEntry</c>.
             </para>
            
             <para>
               As with the DOS time, any tool or library running on any operating system
               is capable of formatting a time in one of these ways and embedding it into
               the zip file. The key is, not all zip tools or libraries support all these
               formats.  Storing the higher-precision times for each entry is optional
               for zip files, and many tools and libraries don't use the higher precision
               quantities at all, though it is much nicer than the DOS time.  And futher,
               there are also cases where the timestamp of the file entry is not known,
               and is not stored. For example, this happens when content for the entry is
               obtained from a stream.  The bottom line is that the higher-resolution
               times, in either format, are not guaranteed to be present for a ZipEntry.
               The old DOS time, represented by <see cref="P:Ionic.Zip.ZipEntry.LastModified"/>, is guaranteed
               to be present, though it sometimes unset.
             </para>
            
             <para>
               Ok, getting back to the question about how the <c>LastModified</c>
               property relates to this <c>ModifiedTime</c>
               property... <c>LastModified</c> is always set, while <c>ModifiedTime</c>
               is not. (The other times stored in the <em>NTFS times extension</em>,
               <c>CreationTime</c> and <c>AccessedTime</c> also may not be set on an
               entry that is read from an existing zip file.) When reading a zip file,
               then <c>LastModified</c> takes the DOS time that is stored with the
               file. If the DOS time has been stored as zero in the zipfile, then this
               library will use <c>DateTime.Now</c> for the <c>LastModified</c> value.
               If the ZIP file was created by an evolved tool, then there will also be
               NTFS times in the zip file.  In that case, this library will read those
               times, and set <c>LastModified</c> and <c>ModifiedTime</c> to the same
               value, the one corresponding to the last write time of the file.  If there
               are no "NTFS times" stored for the entry, then <c>ModifiedTime</c> remains
               unset (likewise <c>AccessedTime</c> and <c>CreationTime</c>), and
               <c>LastModified</c> keeps its DOS time.
             </para>
            
             <para>
               When creating zip files with this library, by default the extended time
               properties (<c>ModifiedTime</c>, <c>AccessedTime</c>, and
               <c>CreationTime</c>) are set on the ZipEntry instance, and these data are
               stored in the zip archive for each entry, in NTFS format. If you add an
               entry from an actual filesystem file, then the entry gets the actual file
               times for that file, to NTFS-level precision.  If you add an entry from a
               stream, or a string, then the times get the value <c>DateTime.Now</c>.  In
               this case <c>LastModified</c> and <c>ModifiedTime</c> will be identical,
               to 2 seconds of precision.  You can explicitly set the
               <c>CreationTime</c>, <c>AccessedTime</c>, and <c>ModifiedTime</c> of an
               entry using the property setters.  If you want to set all of those
               quantities, it's more efficient to use the <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/> method.  Those
               changes are not made permanent in the zip file until you call <see cref="M:Ionic.Zip.ZipFile.Save"/> or one of its cousins.
             </para>
            
             <para>
               When creating a zip file, you can override the default behavior for
               formatting times in the zip file, disabling the embedding of file times in
               NTFS format or enabling the storage of file times in Unix format, or both.
               You may want to do this, for example, when creating a zip file on Windows,
               that will be consumed on a Mac, by an application that is not hip to the
               "NTFS times" format. To do this, use the <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> and <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/> properties.  A valid zip file may
               store the file times in both formats.  But, there are no guarantees that a
               program running on Mac or Linux will gracefully handle the NTFS Formatted
               times, or that a non-DotNetZip-powered application running on Windows will
               be able to handle file times in Unix format. When in doubt, test.
             </para>
            
             <para>
               I'll bet you didn't think one person could type so much about time, eh?
               And reading it was so enjoyable, too!  Well, in appreciation, <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">maybe you
               should donate</see>?
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.LastModified"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.AccessedTime">
            <summary>
            Last Access time for the file represented by the entry.
            </summary>
            <remarks>
            This value may or may not be meaningful.  If the <c>ZipEntry</c> was read from an existing
            Zip archive, this information may not be available. For an explanation of why, see
            <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>.
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
            <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
            <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CreationTime">
             <summary>
             The file creation time for the file represented by the entry.
             </summary>
            
             <remarks>
             This value may or may not be meaningful.  If the <c>ZipEntry</c> was read
             from an existing zip archive, and the creation time was not set on the entry
             when the zip file was created, then this property may be meaningless. For an
             explanation of why, see <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>.
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving">
             <summary>
               Specifies whether the Creation, Access, and Modified times for the given
               entry will be emitted in "Windows format" when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entry should or should not be stored
               in the zip archive in the format used by Windows. The default value of
               this property is <c>true</c>.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified
               (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are automatically
               set from the filesystem values. When adding an entry from a stream or
               string, all three values are implicitly set to DateTime.Now.  Applications
               can also explicitly set those times by calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
             </para>
            
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since Jan 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since January 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455.
             </para>
            
             <para>
               Not all zip tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Although the time values are
               easily convertible, subject to a loss of precision, some tools and
               libraries may be able to read only one or the other. DotNetZip can read or
               write times in either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               This property is not mutually exclusive from the <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/> property.  It is
               possible that a zip entry can embed the timestamps in both forms, one
               form, or neither.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle NTFS Formatted times, or that a
               non-DotNetZip-powered application running on Windows will be able to
               handle file times in Unix format. When in doubt, test.
             </para>
            
             <para>
               Normally you will use the <see cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving">ZipFile.EmitTimesInWindowsFormatWhenSaving</see>
               property, to specify the behavior for all entries in a zip, rather than
               the property on each individual entry.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving">
             <summary>
               Specifies whether the Creation, Access, and Modified times for the given
               entry will be emitted in "Unix(tm) format" when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entry should or should not be stored
               in the zip archive in the format used by Unix. By default this flag is
               <c>false</c>, meaning the Unix-format times are not stored in the zip
               archive.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified
               (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are automatically
               set from the filesystem values. When adding an entry from a stream or
               string, all three values are implicitly set to DateTime.Now.  Applications
               can also explicitly set those times by calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
             </para>
            
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since Jan 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since Jan 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455.
             </para>
            
             <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Although the time values are
               easily convertible, subject to a loss of precision, some tools and
               libraries may be able to read only one or the other. DotNetZip can read or
               write times in either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               This property is not mutually exclusive from the <see cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> property.  It is
               possible that a zip entry can embed the timestamps in both forms, one
               form, or neither.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle NTFS Formatted times, or that a
               non-DotNetZip-powered application running on Windows will be able to
               handle file times in Unix format. When in doubt, test.
             </para>
            
             <para>
               Normally you will use the <see cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving">ZipFile.EmitTimesInUnixFormatWhenSaving</see>
               property, to specify the behavior for all entries, rather than the
               property on each individual entry.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Timestamp">
             <summary>
             The type of timestamp attached to the ZipEntry.
             </summary>
            
             <remarks>
             This property is valid only for a ZipEntry that was read from a zip archive.
             It indicates the type of timestamp attached to the entry.
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Attributes">
             <summary>
               The file attributes for the entry.
             </summary>
            
             <remarks>
            
             <para>
               The <see cref="T:System.IO.FileAttributes">attributes</see> in NTFS include
               ReadOnly, Archive, Hidden, System, and Indexed.  When adding a
               <c>ZipEntry</c> to a ZipFile, these attributes are set implicitly when
               adding an entry from the filesystem.  When adding an entry from a stream
               or string, the Attributes are not set implicitly.  Regardless of the way
               an entry was added to a <c>ZipFile</c>, you can set the attributes
               explicitly if you like.
             </para>
            
             <para>
               When reading a <c>ZipEntry</c> from a <c>ZipFile</c>, the attributes are
               set according to the data stored in the <c>ZipFile</c>. If you extract the
               entry from the archive to a filesystem file, DotNetZip will set the
               attributes on the resulting file accordingly.
             </para>
            
             <para>
               The attributes can be set explicitly by the application.  For example the
               application may wish to set the <c>FileAttributes.ReadOnly</c> bit for all
               entries added to an archive, so that on unpack, this attribute will be set
               on the extracted file.  Any changes you make to this property are made
               permanent only when you call a <c>Save()</c> method on the <c>ZipFile</c>
               instance that contains the ZipEntry.
             </para>
            
             <para>
               For example, an application may wish to zip up a directory and set the
               ReadOnly bit on every file in the archive, so that upon later extraction,
               the resulting files will be marked as ReadOnly.  Not every extraction tool
               respects these attributes, but if you unpack with DotNetZip, as for
               example in a self-extracting archive, then the attributes will be set as
               they are stored in the <c>ZipFile</c>.
             </para>
            
             <para>
               These attributes may not be interesting or useful if the resulting archive
               is extracted on a non-Windows platform.  How these attributes get used
               upon extraction depends on the platform and tool used.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.LocalFileName">
             <summary>
               The name of the filesystem file, referred to by the ZipEntry.
             </summary>
            
             <remarks>
              <para>
                This property specifies the thing-to-be-zipped on disk, and is set only
                when the <c>ZipEntry</c> is being created from a filesystem file.  If the
                <c>ZipFile</c> is instantiated by reading an existing .zip archive, then
                the LocalFileName will be <c>null</c> (<c>Nothing</c> in VB).
              </para>
            
              <para>
                When it is set, the value of this property may be different than <see cref="P:Ionic.Zip.ZipEntry.FileName"/>, which is the path used in the archive itself.  If you
                call <c>Zip.AddFile("foop.txt", AlternativeDirectory)</c>, then the path
                used for the <c>ZipEntry</c> within the zip archive will be different
                than this path.
              </para>
            
              <para>
               If the entry is being added from a stream, then this is null (Nothing in VB).
              </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.FileName"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.FileName">
             <summary>
               The name of the file contained in the ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               This is the name of the entry in the <c>ZipFile</c> itself.  When creating
               a zip archive, if the <c>ZipEntry</c> has been created from a filesystem
               file, via a call to <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/> or <see cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>, or a related overload, the value
               of this property is derived from the name of that file. The
               <c>FileName</c> property does not include drive letters, and may include a
               different directory path, depending on the value of the
               <c>directoryPathInArchive</c> parameter used when adding the entry into
               the <c>ZipFile</c>.
             </para>
            
             <para>
               In some cases there is no related filesystem file - for example when a
               <c>ZipEntry</c> is created using <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)"/> or one of the similar overloads.  In this case, the value of
               this property is derived from the fileName and the directory path passed
               to that method.
             </para>
            
             <para>
               When reading a zip file, this property takes the value of the entry name
               as stored in the zip file. If you extract such an entry, the extracted
               file will take the name given by this property.
             </para>
            
             <para>
               Applications can set this property when creating new zip archives or when
               reading existing archives. When setting this property, the actual value
               that is set will replace backslashes with forward slashes, in accordance
               with <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</see>, for compatibility with Unix(tm) and ... get
               this.... Amiga!
             </para>
            
             <para>
               If an application reads a <c>ZipFile</c> via <see cref="M:Ionic.Zip.ZipFile.Read(System.String)"/> or a related overload, and then explicitly
               sets the FileName on an entry contained within the <c>ZipFile</c>, and
               then calls <see cref="M:Ionic.Zip.ZipFile.Save"/>, the application will effectively
               rename the entry within the zip archive.
             </para>
            
             <para>
               If an application sets the value of <c>FileName</c>, then calls
               <c>Extract()</c> on the entry, the entry is extracted to a file using the
               newly set value as the filename.  The <c>FileName</c> value is made
               permanent in the zip archive only <em>after</em> a call to one of the
               <c>ZipFile.Save()</c> methods on the <c>ZipFile</c> that contains the
               ZipEntry.
             </para>
            
             <para>
               If an application attempts to set the <c>FileName</c> to a value that
               would result in a duplicate entry in the <c>ZipFile</c>, an exception is
               thrown.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.InputStream">
             <summary>
             The stream that provides content for the ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               The application can use this property to set the input stream for an
               entry on a just-in-time basis. Imagine a scenario where the application
               creates a <c>ZipFile</c> comprised of content obtained from hundreds of
               files, via calls to <c>AddFile()</c>. The DotNetZip library opens streams
               on these files on a just-in-time basis, only when writing the entry out to
               an external store within the scope of a <c>ZipFile.Save()</c> call.  Only
               one input stream is opened at a time, as each entry is being written out.
             </para>
            
             <para>
               Now imagine a different application that creates a <c>ZipFile</c>
               with content obtained from hundreds of streams, added through <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/>.  Normally the
               application would supply an open stream to that call.  But when large
               numbers of streams are being added, this can mean many open streams at one
               time, unnecessarily.
             </para>
            
             <para>
               To avoid this, call <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/> and specify delegates that open and close the stream at
               the time of Save.
             </para>
            
            
             <para>
               Setting the value of this property when the entry was not added from a
               stream (for example, when the <c>ZipEntry</c> was added with <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String)"/> or <see cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/>, or when the entry was added by
               reading an existing zip archive) will throw an exception.
             </para>
            
             </remarks>
            
        </member>
        <member name="P:Ionic.Zip.ZipEntry.InputStreamWasJitProvided">
             <summary>
               A flag indicating whether the InputStream was provided Just-in-time.
             </summary>
            
             <remarks>
            
             <para>
               When creating a zip archive, an application can obtain content for one or
               more of the <c>ZipEntry</c> instances from streams, using the <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/> method.  At the time
               of calling that method, the application can supply null as the value of
               the stream parameter.  By doing so, the application indicates to the
               library that it will provide a stream for the entry on a just-in-time
               basis, at the time one of the <c>ZipFile.Save()</c> methods is called and
               the data for the various entries are being compressed and written out.
             </para>
            
             <para>
               In this case, the application can set the <see cref="P:Ionic.Zip.ZipEntry.InputStream"/>
               property, typically within the SaveProgress event (event type: <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry"/>) for that entry.
             </para>
            
             <para>
               The application will later want to call Close() and Dispose() on that
               stream.  In the SaveProgress event, when the event type is <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry"/>, the application can
               do so.  This flag indicates that the stream has been provided by the
               application on a just-in-time basis and that it is the application's
               responsibility to call Close/Dispose on that stream.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.InputStream"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Source">
            <summary>
            An enum indicating the source of the ZipEntry.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.VersionNeeded">
             <summary>
             The version of the zip engine needed to read the ZipEntry.
             </summary>
            
             <remarks>
             <para>
               This is a readonly property, indicating the version of <a
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</a> that the extracting tool or library must support to
               extract the given entry.  Generally higher versions indicate newer
               features.  Older zip engines obviously won't know about new features, and
               won't be able to extract entries that depend on those newer features.
             </para>
            
             <list type="table">
             <listheader>
             <term>value</term>
             <description>Features</description>
             </listheader>
            
             <item>
             <term>20</term>
             <description>a basic Zip Entry, potentially using PKZIP encryption.
             </description>
             </item>
            
             <item>
             <term>45</term>
             <description>The ZIP64 extension is used on the entry.
             </description>
             </item>
            
             <item>
             <term>46</term>
             <description> File is compressed using BZIP2 compression*</description>
             </item>
            
             <item>
             <term>50</term>
             <description> File is encrypted using PkWare's DES, 3DES, (broken) RC2 or RC4</description>
             </item>
            
             <item>
             <term>51</term>
             <description> File is encrypted using PKWare's AES encryption or corrected RC2 encryption.</description>
             </item>
            
             <item>
             <term>52</term>
             <description> File is encrypted using corrected RC2-64 encryption**</description>
             </item>
            
             <item>
             <term>61</term>
             <description> File is encrypted using non-OAEP key wrapping***</description>
             </item>
            
             <item>
             <term>63</term>
             <description> File is compressed using LZMA, PPMd+, Blowfish, or Twofish</description>
             </item>
            
             </list>
            
             <para>
               There are other values possible, not listed here. DotNetZip supports
               regular PKZip encryption, and ZIP64 extensions.  DotNetZip cannot extract
               entries that require a zip engine higher than 45.
             </para>
            
             <para>
               This value is set upon reading an existing zip file, or after saving a zip
               archive.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Comment">
             <summary>
             The comment attached to the ZipEntry.
             </summary>
            
             <remarks>
             <para>
               Each entry in a zip file can optionally have a comment associated to
               it. The comment might be displayed by a zip tool during extraction, for
               example.
             </para>
            
             <para>
               By default, the <c>Comment</c> is encoded in IBM437 code page. You can
               specify an alternative with <see cref="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding"/>
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.RequiresZip64">
             <summary>
             Indicates whether the entry requires ZIP64 extensions.
             </summary>
            
             <remarks>
            
             <para>
               This property is null (Nothing in VB) until a <c>Save()</c> method on the
               containing <see cref="T:Ionic.Zip.ZipFile"/> instance has been called. The property is
               non-null (<c>HasValue</c> is true) only after a <c>Save()</c> method has
               been called.
             </para>
            
             <para>
               After the containing <c>ZipFile</c> has been saved, the Value of this
               property is true if any of the following three conditions holds: the
               uncompressed size of the entry is larger than 0xFFFFFFFF; the compressed
               size of the entry is larger than 0xFFFFFFFF; the relative offset of the
               entry within the zip archive is larger than 0xFFFFFFFF.  These quantities
               are not known until a <c>Save()</c> is attempted on the zip archive and
               the compression is applied.
             </para>
            
             <para>
               If none of the three conditions holds, then the <c>Value</c> is false.
             </para>
            
             <para>
               A <c>Value</c> of false does not indicate that the entry, as saved in the
               zip archive, does not use ZIP64.  It merely indicates that ZIP64 is
               <em>not required</em>.  An entry may use ZIP64 even when not required if
               the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property on the containing
               <c>ZipFile</c> instance is set to <see cref="F:Ionic.Zip.Zip64Option.Always"/>, or if
               the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property on the containing
               <c>ZipFile</c> instance is set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/>
               and the output stream was not seekable.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.OutputUsedZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.OutputUsedZip64">
             <summary>
               Indicates whether the entry actually used ZIP64 extensions, as it was most
               recently written to the output file or stream.
             </summary>
            
             <remarks>
            
             <para>
               This Nullable property is null (Nothing in VB) until a <c>Save()</c>
               method on the containing <see cref="T:Ionic.Zip.ZipFile"/> instance has been
               called. <c>HasValue</c> is true only after a <c>Save()</c> method has been
               called.
             </para>
            
             <para>
               The value of this property for a particular <c>ZipEntry</c> may change
               over successive calls to <c>Save()</c> methods on the containing ZipFile,
               even if the file that corresponds to the <c>ZipEntry</c> does not. This
               may happen if other entries contained in the <c>ZipFile</c> expand,
               causing the offset for this particular entry to exceed 0xFFFFFFFF.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.RequiresZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.BitField">
             <summary>
             The bitfield for the entry as defined in the zip spec. You probably never need to look at this.
             </summary>
            
             <remarks>
             <list type="table">
             <listheader>
             <term>bit</term>
             <description>meaning</description>
             </listheader>
            
             <item>
             <term>0</term>
             <description>set if encryption is used.</description>
             </item>
            
             <item>
             <term>1-2</term>
             <description>
             set to determine whether normal, max, fast deflation.  DotNetZip library
             always leaves these bits unset when writing (indicating "normal"
             deflation"), but can read an entry with any value here.
             </description>
             </item>
            
             <item>
             <term>3</term>
             <description>
             Indicates that the Crc32, Compressed and Uncompressed sizes are zero in the
             local header.  This bit gets set on an entry during writing a zip file, when
             it is saved to a non-seekable output stream.
             </description>
             </item>
            
            
             <item>
             <term>4</term>
             <description>reserved for "enhanced deflating". This library doesn't do enhanced deflating.</description>
             </item>
            
             <item>
             <term>5</term>
             <description>set to indicate the zip is compressed patched data.  This library doesn't do that.</description>
             </item>
            
             <item>
             <term>6</term>
             <description>
             set if PKWare's strong encryption is used (must also set bit 1 if bit 6 is
             set). This bit is not set if WinZip's AES encryption is set.</description>
             </item>
            
             <item>
             <term>7</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>8</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>9</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>10</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>11</term>
             <description>
             Language encoding flag (EFS).  If this bit is set, the filename and comment
             fields for this file must be encoded using UTF-8. This library currently
             does not support UTF-8.
             </description>
             </item>
            
             <item>
             <term>12</term>
             <description>Reserved by PKWARE for enhanced compression.</description>
             </item>
            
             <item>
             <term>13</term>
             <description>
               Used when encrypting the Central Directory to indicate selected data
               values in the Local Header are masked to hide their actual values.  See
               the section in <a
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</a> describing the Strong Encryption Specification for
               details.
             </description>
             </item>
            
             <item>
             <term>14</term>
             <description>Reserved by PKWARE.</description>
             </item>
            
             <item>
             <term>15</term>
             <description>Reserved by PKWARE.</description>
             </item>
            
             </list>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressionMethod">
             <summary>
               The compression method employed for this ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
               Zip specification</see> allows a variety of compression methods.  This
               library supports just two: 0x08 = Deflate.  0x00 = Store (no compression),
               for reading or writing.
             </para>
            
             <para>
               When reading an entry from an existing zipfile, the value you retrieve
               here indicates the compression method used on the entry by the original
               creator of the zip.  When writing a zipfile, you can specify either 0x08
               (Deflate) or 0x00 (None).  If you try setting something else, you will get
               an exception.
             </para>
            
             <para>
               You may wish to set <c>CompressionMethod</c> to <c>CompressionMethod.None</c> (0)
               when zipping already-compressed data like a jpg, png, or mp3 file.
               This can save time and cpu cycles.
             </para>
            
             <para>
               When setting this property on a <c>ZipEntry</c> that is read from an
               existing zip file, calling <c>ZipFile.Save()</c> will cause the new
               CompressionMethod to be used on the entry in the newly saved zip file.
             </para>
            
             <para>
               Setting this property may have the side effect of modifying the
               <c>CompressionLevel</c> property. If you set the <c>CompressionMethod</c> to a
               value other than <c>None</c>, and <c>CompressionLevel</c> is previously
               set to <c>None</c>, then <c>CompressionLevel</c> will be set to
               <c>Default</c>.
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.CompressionMethod"/>
            
             <example>
               In this example, the first entry added to the zip archive uses the default
               behavior - compression is used where it makes sense.  The second entry,
               the MP3 file, is added to the archive without being compressed.
             <code>
             using (ZipFile zip = new ZipFile(ZipFileToCreate))
             {
               ZipEntry e1= zip.AddFile(@"notes\Readme.txt");
               ZipEntry e2= zip.AddFile(@"music\StopThisTrain.mp3");
               e2.CompressionMethod = CompressionMethod.None;
               zip.Save();
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile(ZipFileToCreate)
               zip.AddFile("notes\Readme.txt")
               Dim e2 as ZipEntry = zip.AddFile("music\StopThisTrain.mp3")
               e2.CompressionMethod = CompressionMethod.None
               zip.Save
             End Using
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressionLevel">
             <summary>
               Sets the compression level to be used for the entry when saving the zip
               archive.
             </summary>
            
             <remarks>
              <para>
                Varying the compression level used on entries can affect the
                size-vs-speed tradeoff when compression and decompressing data streams
                or files.
              </para>
            
              <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
            
              <para>
                When setting this property on a <c>ZipEntry</c> that is read from an
                existing zip file, calling <c>ZipFile.Save()</c> will cause the new
                <c>CompressionLevel</c> to be used on the entry in the newly saved zip file.
              </para>
            
              <para>
                Setting this property may have the side effect of modifying the
                <c>CompressionMethod</c> property. If you set the <c>CompressionLevel</c>
                to a value other than <c>None</c>, <c>CompressionMethod</c> will be set
                to <c>Deflate</c>, if it was previously <c>None</c>.
              </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.CompressionMethod"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressedSize">
             <summary>
               The compressed size of the file, in bytes, within the zip archive.
             </summary>
            
             <remarks>
               The compressed size is computed during compression. The value is valid
               AFTER reading in an existing zip file, or AFTER saving a zipfile you are
               creating.
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.UncompressedSize"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.UncompressedSize">
             <summary>
               The size of the file, in bytes, before compression, or after extraction.
             </summary>
            
             <remarks>
               This property is valid AFTER reading in an existing zip file, or AFTER saving the
               <c>ZipFile</c> that contains the ZipEntry.
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.CompressedSize"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.CompressionRatio">
             <summary>
             The ratio of compressed size to uncompressed size of the ZipEntry.
             </summary>
            
             <remarks>
             <para>
               This is a ratio of the compressed size to the uncompressed size of the
               entry, expressed as a double in the range of 0 to 100+. A value of 100
               indicates no compression at all.  It could be higher than 100 when the
               compression algorithm actually inflates the data, as may occur for small
               files, or uncompressible data that is encrypted.
             </para>
            
             <para>
               You could format it for presentation to a user via a format string of
               "{3,5:F0}%" to see it as a percentage.
             </para>
            
             <para>
               If the size of the original uncompressed file is 0, (indicating a
               denominator of 0) the return value will be zero.
             </para>
            
             <para>
               This property is valid AFTER reading in an existing zip file, or AFTER
               saving the <c>ZipFile</c> that contains the ZipEntry. You cannot know the
               effect of a compression transform until you try it.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Crc">
             <summary>
             The 32-bit CRC (Cyclic Redundancy Check) on the contents of the ZipEntry.
             </summary>
            
             <remarks>
            
             <para> You probably don't need to concern yourself with this. It is used
             internally by DotNetZip to verify files or streams upon extraction.  </para>
            
             <para> The value is a <see href="http://en.wikipedia.org/wiki/CRC32">32-bit
             CRC</see> using 0xEDB88320 for the polynomial. This is the same CRC-32 used in
             PNG, MPEG-2, and other protocols and formats.  It is a read-only property; when
             creating a Zip archive, the CRC for each entry is set only after a call to
             <c>Save()</c> on the containing ZipFile. When reading an existing zip file, the value
             of this property reflects the stored CRC for the entry.  </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.IsDirectory">
            <summary>
            True if the entry is a directory (not a file).
            This is a readonly property on the entry.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.UsesEncryption">
             <summary>
             A derived property that is <c>true</c> if the entry uses encryption.
             </summary>
            
             <remarks>
             <para>
               This is a readonly property on the entry.  When reading a zip file,
               the value for the <c>ZipEntry</c> is determined by the data read
               from the zip file.  After saving a ZipFile, the value of this
               property for each <c>ZipEntry</c> indicates whether encryption was
               actually used (which will have been true if the <see cref="P:Ionic.Zip.ZipEntry.Password"/> was set and the <see cref="P:Ionic.Zip.ZipEntry.Encryption"/> property
               was something other than <see cref="F:Ionic.Zip.EncryptionAlgorithm.None"/>.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Encryption">
             <summary>
               Set this to specify which encryption algorithm to use for the entry when
               saving it to a zip archive.
             </summary>
            
             <remarks>
            
             <para>
               Set this property in order to encrypt the entry when the <c>ZipFile</c> is
               saved. When setting this property, you must also set a <see cref="P:Ionic.Zip.ZipEntry.Password"/> on the entry.  If you set a value other than <see cref="F:Ionic.Zip.EncryptionAlgorithm.None"/> on this property and do not set a
               <c>Password</c> then the entry will not be encrypted. The <c>ZipEntry</c>
               data is encrypted as the <c>ZipFile</c> is saved, when you call <see cref="M:Ionic.Zip.ZipFile.Save"/> or one of its cousins on the containing
               <c>ZipFile</c> instance. You do not need to specify the <c>Encryption</c>
               when extracting entries from an archive.
             </para>
            
             <para>
               The Zip specification from PKWare defines a set of encryption algorithms,
               and the data formats for the zip archive that support them, and PKWare
               supports those algorithms in the tools it produces. Other vendors of tools
               and libraries, such as WinZip or Xceed, typically support <em>a
               subset</em> of the algorithms specified by PKWare. These tools can
               sometimes support additional different encryption algorithms and data
               formats, not specified by PKWare. The AES Encryption specified and
               supported by WinZip is the most popular example. This library supports a
               subset of the complete set of algorithms specified by PKWare and other
               vendors.
             </para>
            
             <para>
               There is no common, ubiquitous multi-vendor standard for strong encryption
               within zip files. There is broad support for so-called "traditional" Zip
               encryption, sometimes called Zip 2.0 encryption, as <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specified
               by PKWare</see>, but this encryption is considered weak and
               breakable. This library currently supports the Zip 2.0 "weak" encryption,
               and also a stronger WinZip-compatible AES encryption, using either 128-bit
               or 256-bit key strength. If you want DotNetZip to support an algorithm
               that is not currently supported, call the author of this library and maybe
               we can talk business.
             </para>
            
             <para>
               The <see cref="T:Ionic.Zip.ZipFile"/> class also has a <see cref="P:Ionic.Zip.ZipFile.Encryption"/> property.  In most cases you will use
               <em>that</em> property when setting encryption. This property takes
               precedence over any <c>Encryption</c> set on the <c>ZipFile</c> itself.
               Typically, you would use the per-entry Encryption when most entries in the
               zip archive use one encryption algorithm, and a few entries use a
               different one.  If all entries in the zip file use the same Encryption,
               then it is simpler to just set this property on the ZipFile itself, when
               creating a zip archive.
             </para>
            
             <para>
               Some comments on updating archives: If you read a <c>ZipFile</c>, you can
               modify the Encryption on an encrypted entry: you can remove encryption
               from an entry that was encrypted; you can encrypt an entry that was not
               encrypted previously; or, you can change the encryption algorithm.  The
               changes in encryption are not made permanent until you call Save() on the
               <c>ZipFile</c>.  To effect changes in encryption, the entry content is
               streamed through several transformations, depending on the modification
               the application has requested. For example if the entry is not encrypted
               and the application sets <c>Encryption</c> to <c>PkzipWeak</c>, then at
               the time of <c>Save()</c>, the original entry is read and decompressed,
               then re-compressed and encrypted.  Conversely, if the original entry is
               encrypted with <c>PkzipWeak</c> encryption, and the application sets the
               <c>Encryption</c> property to <c>WinZipAes128</c>, then at the time of
               <c>Save()</c>, the original entry is decrypted via PKZIP encryption and
               decompressed, then re-compressed and re-encrypted with AES.  This all
               happens automatically within the library, but it can be time-consuming for
               large entries.
             </para>
            
             <para>
               Additionally, when updating archives, it is not possible to change the
               password when changing the encryption algorithm.  To change both the
               algorithm and the password, you need to Save() the zipfile twice.  First
               set the <c>Encryption</c> to None, then call <c>Save()</c>.  Then set the
               <c>Encryption</c> to the new value (not "None"), then call <c>Save()</c>
               once again.
             </para>
            
             <para>
               The WinZip AES encryption algorithms are not supported on the .NET Compact
               Framework.
             </para>
             </remarks>
            
             <example>
             <para>
               This example creates a zip archive that uses encryption, and then extracts
               entries from the archive.  When creating the zip archive, the ReadMe.txt
               file is zipped without using a password or encryption.  The other file
               uses encryption.
             </para>
             <code>
             // Create a zip archive with AES Encryption.
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt")
                 ZipEntry e1= zip.AddFile("2008-Regional-Sales-Report.pdf");
                 e1.Encryption= EncryptionAlgorithm.WinZipAes256;
                 e1.Password= "Top.Secret.No.Peeking!";
                 zip.Save("EncryptedArchive.zip");
             }
            
             // Extract a zip archive that uses AES Encryption.
             // You do not need to specify the algorithm during extraction.
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 // Specify the password that is used during extraction, for
                 // all entries that require a password:
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.ExtractAll("extractDirectory");
             }
             </code>
            
             <code lang="VB">
             ' Create a zip that uses Encryption.
             Using zip As New ZipFile()
                 zip.AddFile("ReadMe.txt")
                 Dim e1 as ZipEntry
                 e1= zip.AddFile("2008-Regional-Sales-Report.pdf")
                 e1.Encryption= EncryptionAlgorithm.WinZipAes256
                 e1.Password= "Top.Secret.No.Peeking!"
                 zip.Save("EncryptedArchive.zip")
             End Using
            
             ' Extract a zip archive that uses AES Encryption.
             ' You do not need to specify the algorithm during extraction.
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 ' Specify the password that is used during extraction, for
                 ' all entries that require a password:
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.ExtractAll("extractDirectory")
             End Using
             </code>
            
             </example>
            
             <exception cref="T:System.InvalidOperationException">
             Thrown in the setter if EncryptionAlgorithm.Unsupported is specified.
             </exception>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.Password">ZipEntry.Password</seealso>
             <seealso cref="P:Ionic.Zip.ZipFile.Encryption">ZipFile.Encryption</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.Password">
             <summary>
             The Password to be used when encrypting a <c>ZipEntry</c> upon
             <c>ZipFile.Save()</c>, or when decrypting an entry upon Extract().
             </summary>
            
             <remarks>
             <para>
               This is a write-only property on the entry. Set this to request that the
               entry be encrypted when writing the zip archive, or set it to specify the
               password to be used when extracting an existing entry that is encrypted.
             </para>
            
             <para>
               The password set here is implicitly used to encrypt the entry during the
               <see cref="M:Ionic.Zip.ZipFile.Save"/> operation, or to decrypt during the <see cref="M:Ionic.Zip.ZipEntry.Extract"/> or <see cref="M:Ionic.Zip.ZipEntry.OpenReader"/> operation.  If you set
               the Password on a <c>ZipEntry</c> after calling <c>Save()</c>, there is no
               effect.
             </para>
            
             <para>
               Consider setting the <see cref="P:Ionic.Zip.ZipEntry.Encryption"/> property when using a
               password. Answering concerns that the standard password protection
               supported by all zip tools is weak, WinZip has extended the ZIP
               specification with a way to use AES Encryption to protect entries in the
               Zip file. Unlike the "PKZIP 2.0" encryption specified in the PKZIP
               specification, <see href="http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES
               Encryption</see> uses a standard, strong, tested, encryption
               algorithm. DotNetZip can create zip archives that use WinZip-compatible
               AES encryption, if you set the <see cref="P:Ionic.Zip.ZipEntry.Encryption"/> property. But,
               archives created that use AES encryption may not be readable by all other
               tools and libraries. For example, Windows Explorer cannot read a
               "compressed folder" (a zip file) that uses AES encryption, though it can
               read a zip file that uses "PKZIP encryption."
             </para>
            
             <para>
               The <see cref="T:Ionic.Zip.ZipFile"/> class also has a <see cref="P:Ionic.Zip.ZipFile.Password"/>
               property.  This property takes precedence over any password set on the
               ZipFile itself.  Typically, you would use the per-entry Password when most
               entries in the zip archive use one password, and a few entries use a
               different password.  If all entries in the zip file use the same password,
               then it is simpler to just set this property on the ZipFile itself,
               whether creating a zip archive or extracting a zip archive.
             </para>
            
             <para>
               Some comments on updating archives: If you read a <c>ZipFile</c>, you
               cannot modify the password on any encrypted entry, except by extracting
               the entry with the original password (if any), removing the original entry
               via <see cref="M:Ionic.Zip.ZipFile.RemoveEntry(Ionic.Zip.ZipEntry)"/>, and then adding a new
               entry with a new Password.
             </para>
            
             <para>
               For example, suppose you read a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the Password property on that <c>ZipEntry</c> and then
               calling <c>Save()</c> on the <c>ZipFile</c> does not update the password
               on that entry in the archive.  Neither is an exception thrown. Instead,
               what happens during the <c>Save()</c> is the existing entry is copied
               through to the new zip archive, in its original encrypted form. Upon
               re-reading that archive, the entry can be decrypted with its original
               password.
             </para>
            
             <para>
               If you read a ZipFile, and there is an un-encrypted entry, you can set the
               <c>Password</c> on the entry and then call Save() on the ZipFile, and get
               encryption on that entry.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example creates a zip file with two entries, and then extracts the
               entries from the zip file.  When creating the zip file, the two files are
               added to the zip file using password protection. Each entry uses a
               different password.  During extraction, each file is extracted with the
               appropriate password.
             </para>
             <code>
             // create a file with encryption
             using (ZipFile zip = new ZipFile())
             {
                 ZipEntry entry;
                 entry= zip.AddFile("Declaration.txt");
                 entry.Password= "123456!";
                 entry = zip.AddFile("Report.xls");
                 entry.Password= "1Secret!";
                 zip.Save("EncryptedArchive.zip");
             }
            
             // extract entries that use encryption
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 ZipEntry entry;
                 entry = zip["Declaration.txt"];
                 entry.Password = "123456!";
                 entry.Extract("extractDir");
                 entry = zip["Report.xls"];
                 entry.Password = "1Secret!";
                 entry.Extract("extractDir");
             }
            
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 Dim entry as ZipEntry
                 entry= zip.AddFile("Declaration.txt")
                 entry.Password= "123456!"
                 entry = zip.AddFile("Report.xls")
                 entry.Password= "1Secret!"
                 zip.Save("EncryptedArchive.zip")
             End Using
            
            
             ' extract entries that use encryption
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 Dim entry as ZipEntry
                 entry = zip("Declaration.txt")
                 entry.Password = "123456!"
                 entry.Extract("extractDir")
                 entry = zip("Report.xls")
                 entry.Password = "1Secret!"
                 entry.Extract("extractDir")
             End Using
            
             </code>
            
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.Encryption"/>
             <seealso cref="P:Ionic.Zip.ZipFile.Password">ZipFile.Password</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ExtractExistingFile">
             <summary>
             The action the library should take when extracting a file that already exists.
             </summary>
            
             <remarks>
               <para>
                 This property affects the behavior of the Extract methods (one of the
                 <c>Extract()</c> or <c>ExtractWithPassword()</c> overloads), when
                 extraction would would overwrite an existing filesystem file. If you do
                 not set this property, the library throws an exception when extracting
                 an entry would overwrite an existing file.
               </para>
            
               <para>
                 This property has no effect when extracting to a stream, or when the file to be
                 extracted does not already exist.
               </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>
            
             <example>
               This example shows how to set the <c>ExtractExistingFile</c> property in
               an <c>ExtractProgress</c> event, in response to user input. The
               <c>ExtractProgress</c> event is invoked if and only if the
               <c>ExtractExistingFile</c> property was previously set to
               <c>ExtractExistingFileAction.InvokeExtractProgressEvent</c>.
             <code lang="C#">
             public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
                     Console.WriteLine("extract {0} ", e.CurrentEntry.FileName);
            
                 else if (e.EventType == ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite)
                 {
                     ZipEntry entry = e.CurrentEntry;
                     string response = null;
                     // Ask the user if he wants overwrite the file
                     do
                     {
                         Console.Write("Overwrite {0} in {1} ? (y/n/C) ", entry.FileName, e.ExtractLocation);
                         response = Console.ReadLine();
                         Console.WriteLine();
            
                     } while (response != null &amp;&amp; response[0]!='Y' &amp;&amp;
                              response[0]!='N' &amp;&amp; response[0]!='C');
            
                     if  (response[0]=='C')
                         e.Cancel = true;
                     else if (response[0]=='Y')
                         entry.ExtractExistingFile = ExtractExistingFileAction.OverwriteSilently;
                     else
                         entry.ExtractExistingFile= ExtractExistingFileAction.DoNotOverwrite;
                 }
             }
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ZipErrorAction">
             <summary>
               The action to take when an error is encountered while
               opening or reading files as they are saved into a zip archive.
             </summary>
            
             <remarks>
              <para>
                 Errors can occur within a call to <see cref="M:Ionic.Zip.ZipFile.Save">ZipFile.Save</see>, as the various files contained
                 in a ZipFile are being saved into the zip archive.  During the
                 <c>Save</c>, DotNetZip will perform a <c>File.Open</c> on the file
                 associated to the ZipEntry, and then will read the entire contents of
                 the file as it is zipped. Either the open or the Read may fail, because
                 of lock conflicts or other reasons.  Using this property, you can
                 specify the action to take when such errors occur.
              </para>
            
              <para>
                 Typically you will NOT set this property on individual ZipEntry
                 instances.  Instead, you will set the <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction">ZipFile.ZipErrorAction</see> property on
                 the ZipFile instance, before adding any entries to the
                 <c>ZipFile</c>. If you do this, errors encountered on behalf of any of
                 the entries in the ZipFile will be handled the same way.
              </para>
            
              <para>
                 But, if you use a <see cref="E:Ionic.Zip.ZipFile.ZipError"/> handler, you will want
                 to set this property on the <c>ZipEntry</c> within the handler, to
                 communicate back to DotNetZip what you would like to do with the
                 particular error.
              </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ZipError"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.IncludedInMostRecentSave">
            <summary>
            Indicates whether the entry was included in the most recent save.
            </summary>
            <remarks>
            An entry can be excluded or skipped from a save if there is an error
            opening or reading the entry.
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipEntry.ZipErrorAction"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.SetCompression">
             <summary>
               A callback that allows the application to specify the compression to use
               for a given entry that is about to be added to the zip archive.
             </summary>
            
             <remarks>
             <para>
               See <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.UseUnicodeAsNecessary">
             <summary>
               Set to indicate whether to use UTF-8 encoding for filenames and comments.
             </summary>
            
             <remarks>
            
             <para>
               If this flag is set, the comment and filename for the entry will be
               encoded with UTF-8, as described in <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</see>, if necessary. "Necessary" means, the filename or
               entry comment (if any) cannot be reflexively encoded and decoded using the
               default code page, IBM437.
             </para>
            
             <para>
               Setting this flag to true is equivalent to setting <see cref="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding"/> to <c>System.Text.Encoding.UTF8</c>.
             </para>
            
             <para>
               This flag has no effect or relation to the text encoding used within the
               file itself.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding">
             <summary>
             The text encoding to use for the FileName and Comment on this ZipEntry, when the
             default encoding is insufficient.
             </summary>
            
             <remarks>
            
             <para>
               This is a long and odd name for a property, but there's a good reason for
               it. According to <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification from PKWare</see>, filenames and comments for a
               <c>ZipEntry</c> are encoded either with IBM437 or with UTF8.  But, some
               zip archiver tools or libraries do not follow the specification, and
               instead encode characters using the system default code page, or an
               arbitrary code page.  For example, WinRAR when run on a machine in
               Shanghai may encode filenames with the Chinese (Big-5) code page.  This
               behavior is contrary to the Zip specification, but it occurs anyway.  This
               property exists to support that non-compliant behavior when reading or
               writing zip files.
             </para>
            
             <para>
               When writing zip archives that will be read by one of these other
               archivers, use this property to specify the code page to use when encoding
               filenames and comments into the zip file, when the IBM437 code page will
               not suffice.
             </para>
            
             <para>
               Be aware that a zip file created after you've explicitly specified the
               code page will not be compliant to the PKWare specification, and may not
               be readable by compliant archivers.  On the other hand, many archivers are
               non-compliant and can read zip files created in arbitrary code pages. For
               example, if you run WinRar on your PC desktop in Kyoto, Japan, you will
               probably be able to open zip files that we encoded by DotNetZip in the
               Shift_JIS code page.
             </para>
            
             <para>
               When using an arbitrary, non-UTF8 code page for encoding, there is no
               standard way for the creator (DotNetZip) to specify in the zip file which
               code page has been used. DotNetZip is not able to inspect the zip file and
               determine the codepage used for the entries within it. Therefore, you, the
               application author, must determine that.  If you read a zip file using a
               codepage other than the one used to encode the zipfile, this may result in
               filenames that are not legal in the filesystem, and you will get
               exceptions during calls to <c>Extract()</c> methods for those entries.
               Caveat Emptor.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.ActualEncoding">
             <summary>
             The text encoding actually used for this ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               This read-only property describes the encoding used by the
               <c>ZipEntry</c>.  If the entry has been read in from an existing ZipFile,
               then it may take the value UTF-8, if the entry is coded to specify UTF-8.
               If the entry does not specify UTF-8, the typical case, then the encoding
               used is whatever the application specified in the call to
               <c>ZipFile.Read()</c>. If the application has used one of the overloads of
               <c>ZipFile.Read()</c> that does not accept an encoding parameter, then the
               encoding used is IBM437, which is the default encoding described in the
               ZIP specification.  </para>
            
             <para>
               If the entry is being created, then the value of ActualEncoding is taken
               according to the logic described in the documentation for <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>.  </para>
            
             <para>
               An application might be interested in retrieving this property to see if
               an entry read in from a file has used Unicode (UTF-8).  </para>
            
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Ionic.Zip.ZipEntry.IsText">
             <summary>
             Indicates whether an entry is mark as a text file.
             </summary>
             <remarks>
            
             <para>
               The ZIP format includes a provision for specifying whether an entry in the
               zip archive is a text or binary file.  Such a distinction may seem
               irrelevant now, but some zip tools or libraries, in particular older
               PKUnzip on IBM mainframes, require this bit to be set in order to unzip
               text and binary files properly.  Set this property to true to set the Text
               bit for an entry that represents a text file, if you want your zip files
               to be readable by these older zip tools and libraries.
             </para>
            
             <para>
               When writing a zip file, you must set the property before calling
               <c>Save()</c> on the ZipFile.
             </para>
            
             <para>
               If you are not having compatibility problems with zip archives, you can
               safely ignore this property.
             </para>
             </remarks>
            
             <example>
             <code>
             using (var zip = new ZipFile())
             {
                 var e = zip.UpdateFile("Descriptions.txt", "");
                 e.IsText = true;
                 zip.Save(zipPath);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 Dim e2 as ZipEntry = zip.AddFile("Descriptions.txt", "")
                 e.IsText= True
                 zip.Save(zipPath)
             End Using
             </code>
             </example>
        </member>
        <member name="T:Ionic.Zip.ZipEntryTimestamp">
             <summary>
               An enum that specifies the type of timestamp available on the ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               The last modified time of a file can be stored in multiple ways in
               a zip file, and they are not mutually exclusive:
             </para>
            
             <list type="bullet">
               <item>
                 In the so-called "DOS" format, which has a 2-second precision. Values
                 are rounded to the nearest even second. For example, if the time on the
                 file is 12:34:43, then it will be stored as 12:34:44. This first value
                 is accessible via the <c>LastModified</c> property. This value is always
                 present in the metadata for each zip entry.  In some cases the value is
                 invalid, or zero.
               </item>
            
               <item>
                 In the so-called "Windows" or "NTFS" format, as an 8-byte integer
                 quantity expressed as the number of 1/10 milliseconds (in other words
                 the number of 100 nanosecond units) since January 1, 1601 (UTC).  This
                 format is how Windows represents file times.  This time is accessible
                 via the <c>ModifiedTime</c> property.
               </item>
            
               <item>
                 In the "Unix" format, a 4-byte quantity specifying the number of seconds since
                 January 1, 1970 UTC.
               </item>
            
               <item>
                 In an older format, now deprecated but still used by some current
                 tools. This format is also a 4-byte quantity specifying the number of
                 seconds since January 1, 1970 UTC.
               </item>
            
             </list>
            
             <para>
               This bit field describes which of the formats were found in a <c>ZipEntry</c> that was read.
             </para>
            
             </remarks>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.None">
            <summary>
            Default value.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.DOS">
            <summary>
            A DOS timestamp with 2-second precision.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.Windows">
            <summary>
            A Windows timestamp with 100-ns precision.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.Unix">
            <summary>
            A Unix timestamp with 1-second precision.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntryTimestamp.InfoZip1">
            <summary>
            A Unix timestamp with 1-second precision, stored in InfoZip v1 format.  This
            format is outdated and is supported for reading archives only.
            </summary>
        </member>
        <member name="T:Ionic.Zip.CompressionMethod">
             <summary>
               The method of compression to use for a particular ZipEntry.
             </summary>
            
             <remarks>
               <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWare's
               ZIP Specification</see> describes a number of distinct
               cmopression methods that can be used within a zip file. The
               standard DEFLATE method is the only one supported by this
               library.  Imploding, Deflate64, LZMA, and others are not
               supported by this library, either for reading or writing zip
               archives.
             </remarks>
        </member>
        <member name="F:Ionic.Zip.CompressionMethod.None">
            <summary>
            No compression at all. For COM environments, the value is 0 (zero).
            </summary>
        </member>
        <member name="F:Ionic.Zip.CompressionMethod.Deflate">
            <summary>
              DEFLATE cmopression, as described in <see
              href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC
              1951</see>.  This is the "normal" compression used in zip
              files. For COM environments, the value is 8.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipEntrySource">
            <summary>
            An enum that specifies the source of the ZipEntry. 
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.None">
            <summary>
            Default value.  Invalid on a bonafide ZipEntry.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.FileSystem">
            <summary>
            The entry was instantiated by calling AddFile() or another method that 
            added an entry from the filesystem.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.Stream">
            <summary>
            The entry was instantiated via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)"/> or
            <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/> .
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.ZipFile">
            <summary>
            The ZipEntry was instantiated by reading a zipfile.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.WriteDelegate">
            <summary>
            The content for the ZipEntry will be or was provided by the WriteDelegate.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.JitStream">
            <summary>
            The content for the ZipEntry will be obtained from the stream dispensed by the <c>OpenDelegate</c>.
            The entry was instantiated via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipEntrySource.ZipOutputStream">
            <summary>
            The content for the ZipEntry will be or was obtained from a <c>ZipOutputStream</c>.
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipErrorAction">
             <summary>
             An enum providing the options when an error occurs during opening or reading
             of a file or directory that is being saved to a zip file. 
             </summary>
            
             <remarks>
              <para>
                This enum describes the actions that the library can take when an error occurs
                opening or reading a file, as it is being saved into a Zip archive. 
              </para>
            
              <para>
                 In some cases an error will occur when DotNetZip tries to open a file to be
                 added to the zip archive.  In other cases, an error might occur after the
                 file has been successfully opened, while DotNetZip is reading the file.
              </para>
             
              <para>
                The first problem might occur when calling AddDirectory() on a directory
                that contains a Clipper .dbf file; the file is locked by Clipper and
                cannot be opened by another process. An example of the second problem is
                the ERROR_LOCK_VIOLATION that results when a file is opened by another
                process, but not locked, and a range lock has been taken on the file.
                Microsoft Outlook takes range locks on .PST files.
              </para>
             </remarks>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.Throw">
            <summary>
            Throw an exception when an error occurs while zipping.  This is the default
            behavior.  (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.Skip">
            <summary>
            When an error occurs during zipping, for example a file cannot be opened,
            skip the file causing the error, and continue zipping.  (For COM clients,
            this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.Retry">
            <summary>
            When an error occurs during zipping, for example a file cannot be opened,
            retry the operation that caused the error. Be careful with this option. If
            the error is not temporary, the library will retry forever.  (For COM
            clients, this is a 2.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipErrorAction.InvokeErrorEvent">
            <summary>
            When an error occurs, invoke the zipError event.  The event type used is
            <see cref="F:Ionic.Zip.ZipProgressEventType.Error_Saving"/>.  A typical use of this option:
            a GUI application may wish to pop up a dialog to allow the user to view the
            error that occurred, and choose an appropriate action.  After your
            processing in the error event, if you want to skip the file, set <see cref="P:Ionic.Zip.ZipEntry.ZipErrorAction"/> on the
            <c>ZipProgressEventArgs.CurrentEntry</c> to <c>Skip</c>.  If you want the
            exception to be thrown, set <c>ZipErrorAction</c> on the <c>CurrentEntry</c>
            to <c>Throw</c>.  If you want to cancel the zip, set
            <c>ZipProgressEventArgs.Cancel</c> to true.  Cancelling differs from using
            Skip in that a cancel will not save any further entries, if there are any.
            (For COM clients, the value of this enum is a 3.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipFile">
            <summary>
              The ZipFile type represents a zip archive file.  This is the main type in the
              DotNetZip class library. This class reads and writes zip files, as defined in
              the format for zip described by PKWare.  The compression for this
              implementation is provided by a managed-code version of Zlib,
              included with DotNetZip in the classes in the Ionic.Zlib namespace.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddItem(System.String)">
             <summary>
               Adds an item, either a file or a directory, to a zip file archive.
             </summary>
            
             <remarks>
             <para>
               This method is handy if you are adding things to zip archive and don't
               want to bother distinguishing between directories or files.  Any files are
               added as single entries.  A directory added through this method is added
               recursively: all files and subdirectories contained within the directory
               are added to the <c>ZipFile</c>.
             </para>
            
             <para>
               The name of the item may be a relative path or a fully-qualified
               path. Remember, the items contained in <c>ZipFile</c> instance get written
               to the disk only when you call <see cref="M:Ionic.Zip.ZipFile.Save"/> or a similar
               save method.
             </para>
            
             <para>
               The directory name used for the file within the archive is the same as the
               directory name (potentially a relative path) specified in the
               <paramref name="fileOrDirectoryName"/>.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <overloads>This method has two overloads.</overloads>
             <param name="fileOrDirectoryName">
             the name of the file or directory to add.</param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)">
             <summary>
               Adds an item, either a file or a directory, to a zip file archive,
               explicitly specifying the directory path to be used in the archive.
             </summary>
            
             <remarks>
             <para>
               If adding a directory, the add is recursive on all files and
               subdirectories contained within it.
             </para>
             <para>
               The name of the item may be a relative path or a fully-qualified path.
               The item added by this call to the <c>ZipFile</c> is not read from the
               disk nor written to the zip file archive until the application calls
               Save() on the <c>ZipFile</c>.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive, which would override the
               "natural" path of the filesystem file.
             </para>
            
             <para>
               Encryption will be used on the file data if the <c>Password</c> has been set on
               the <c>ZipFile</c> object, prior to calling this method.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <exception cref="T:System.IO.FileNotFoundException">
               Thrown if the file or directory passed in does not exist.
             </exception>
            
             <param name="fileOrDirectoryName">the name of the file or directory to add.
             </param>
            
             <param name="directoryPathInArchive">
               The name of the directory path to use within the zip archive.  This path
               need not refer to an extant directory in the current filesystem.  If the
               files within the zip are later extracted, this is the path used for the
               extracted file.  Passing <c>null</c> (<c>Nothing</c> in VB) will use the
               path on the fileOrDirectoryName.  Passing the empty string ("") will
               insert the item at the root path within the archive.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <example>
               This example shows how to zip up a set of files into a flat hierarchy,
               regardless of where in the filesystem the files originated. The resulting
               zip archive will contain a toplevel directory named "flat", which itself
               will contain files Readme.txt, MyProposal.docx, and Image1.jpg.  A
               subdirectory under "flat" called SupportFiles will contain all the files
               in the "c:\SupportFiles" directory on disk.
            
             <code>
             String[] itemnames= {
               "c:\\fixedContent\\Readme.txt",
               "MyProposal.docx",
               "c:\\SupportFiles",  // a directory
               "images\\Image1.jpg"
             };
            
             try
             {
               using (ZipFile zip = new ZipFile())
               {
                 for (int i = 1; i &lt; itemnames.Length; i++)
                 {
                   // will add Files or Dirs, recurses and flattens subdirectories
                   zip.AddItem(itemnames[i],"flat");
                 }
                 zip.Save(ZipToCreate);
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
            
             <code lang="VB">
               Dim itemnames As String() = _
                 New String() { "c:\fixedContent\Readme.txt", _
                                "MyProposal.docx", _
                                "SupportFiles", _
                                "images\Image1.jpg" }
               Try
                   Using zip As New ZipFile
                       Dim i As Integer
                       For i = 1 To itemnames.Length - 1
                           ' will add Files or Dirs, recursing and flattening subdirectories.
                           zip.AddItem(itemnames(i), "flat")
                       Next i
                       zip.Save(ZipToCreate)
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString())
               End Try
             </code>
             </example>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFile(System.String)">
             <summary>
               Adds a File to a Zip file archive.
             </summary>
             <remarks>
            
             <para>
               This call collects metadata for the named file in the filesystem,
               including the file attributes and the timestamp, and inserts that metadata
               into the resulting ZipEntry.  Only when the application calls Save() on
               the <c>ZipFile</c>, does DotNetZip read the file from the filesystem and
               then write the content to the zip file archive.
             </para>
            
             <para>
               This method will throw an exception if an entry with the same name already
               exists in the <c>ZipFile</c>.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               In this example, three files are added to a Zip archive. The ReadMe.txt
               file will be placed in the root of the archive. The .png file will be
               placed in a folder within the zip called photos\personal.  The pdf file
               will be included into a folder within the zip called Desktop.
             </para>
             <code>
                try
                {
                  using (ZipFile zip = new ZipFile())
                  {
                    zip.AddFile("c:\\photos\\personal\\7440-N49th.png");
                    zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf");
                    zip.AddFile("ReadMe.txt");
            
                    zip.Save("Package.zip");
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: " + ex1);
                }
             </code>
            
             <code lang="VB">
              Try
                   Using zip As ZipFile = New ZipFile
                       zip.AddFile("c:\photos\personal\7440-N49th.png")
                       zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf")
                       zip.AddFile("ReadMe.txt")
                       zip.Save("Package.zip")
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString)
               End Try
             </code>
             </example>
            
             <overloads>This method has two overloads.</overloads>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)"/>
            
             <param name="fileName">
               The name of the file to add. It should refer to a file in the filesystem.
               The name of the file may be a relative path or a fully-qualified path.
             </param>
             <returns>The <c>ZipEntry</c> corresponding to the File added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">
             <summary>
               Adds a File to a Zip file archive, potentially overriding the path to be
               used within the zip archive.
             </summary>
            
             <remarks>
             <para>
               The file added by this call to the <c>ZipFile</c> is not written to the
               zip file archive until the application calls Save() on the <c>ZipFile</c>.
             </para>
            
             <para>
               This method will throw an exception if an entry with the same name already
               exists in the <c>ZipFile</c>.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               In this example, three files are added to a Zip archive. The ReadMe.txt
               file will be placed in the root of the archive. The .png file will be
               placed in a folder within the zip called images.  The pdf file will be
               included into a folder within the zip called files\docs, and will be
               encrypted with the given password.
             </para>
             <code>
             try
             {
               using (ZipFile zip = new ZipFile())
               {
                 // the following entry will be inserted at the root in the archive.
                 zip.AddFile("c:\\datafiles\\ReadMe.txt", "");
                 // this image file will be inserted into the "images" directory in the archive.
                 zip.AddFile("c:\\photos\\personal\\7440-N49th.png", "images");
                 // the following will result in a password-protected file called
                 // files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
                 zip.Password = "EncryptMe!";
                 zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf", "files\\docs");
                 zip.Save("Archive.zip");
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
            
             <code lang="VB">
               Try
                   Using zip As ZipFile = New ZipFile
                       ' the following entry will be inserted at the root in the archive.
                       zip.AddFile("c:\datafiles\ReadMe.txt", "")
                       ' this image file will be inserted into the "images" directory in the archive.
                       zip.AddFile("c:\photos\personal\7440-N49th.png", "images")
                       ' the following will result in a password-protected file called
                       ' files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
                       zip.Password = "EncryptMe!"
                       zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf", "files\documents")
                       zip.Save("Archive.zip")
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1)
               End Try
             </code>
             </example>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
            
             <param name="fileName">
               The name of the file to add.  The name of the file may be a relative path
               or a fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the fileName.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on the fileName, if any.  Passing the empty string
               ("") will insert the item at the root path within the archive.
             </param>
            
             <returns>The <c>ZipEntry</c> corresponding to the file added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntries(System.Collections.Generic.ICollection{Ionic.Zip.ZipEntry})">
             <summary>
               This method removes a collection of entries from the <c>ZipFile</c>.
             </summary>
            
             <param name="entriesToRemove">
               A collection of ZipEntry instances from this zip file to be removed. For
               example, you can pass in an array of ZipEntry instances; or you can call
               SelectEntries(), and then add or remove entries from that
               ICollection&lt;ZipEntry&gt; (ICollection(Of ZipEntry) in VB), and pass
               that ICollection to this method.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.SelectEntries(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntries(System.Collections.Generic.ICollection{System.String})">
             <summary>
               This method removes a collection of entries from the <c>ZipFile</c>, by name.
             </summary>
            
             <param name="entriesToRemove">
               A collection of strings that refer to names of entries to be removed from
               the <c>ZipFile</c>.  For example, you can pass in an array or a List of Strings
               that provide the names of entries to be removed.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.SelectEntries(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String})">
             <summary>
               This method adds a set of files to the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               Use this method to add a set of files to the zip archive, in one call.
               For example, a list of files received from
               <c>System.IO.Directory.GetFiles()</c> can be added to a zip archive in one
               call.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The collection of names of the files to add. Each string should refer to a
               file in the filesystem. The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <example>
               This example shows how to create a zip file, and add a few files into it.
             <code>
             String ZipFileToCreate = "archive1.zip";
             String DirectoryToZip = "c:\\reports";
             using (ZipFile zip = new ZipFile())
             {
               // Store all files found in the top level directory, into the zip archive.
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames);
               zip.Save(ZipFileToCreate);
             }
             </code>
            
             <code lang="VB">
             Dim ZipFileToCreate As String = "archive1.zip"
             Dim DirectoryToZip As String = "c:\reports"
             Using zip As ZipFile = New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames)
                 zip.Save(ZipFileToCreate)
             End Using
             </code>
             </example>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFiles(System.Collections.Generic.IEnumerable{System.String})">
             <summary>
               Adds or updates a set of files in the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               Any files that already exist in the archive are updated. Any files that
               don't yet exist in the archive are added.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The collection of names of the files to update. Each string should refer to a file in
               the filesystem. The name of the file may be a relative path or a fully-qualified path.
             </param>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String},System.String)">
             <summary>
               Adds a set of files to the <c>ZipFile</c>, using the
               specified directory path in the archive.
             </summary>
            
             <remarks>
             <para>
               Any directory structure that may be present in the
               filenames contained in the list is "flattened" in the
               archive.  Each file in the list is added to the archive in
               the specified top-level directory.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>, <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their respective values at the
               time of this call will be applied to each ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The names of the files to add. Each string should refer to
               a file in the filesystem.  The name of the file may be a
               relative path or a fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the file name.
               Th is path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.String)">
             <summary>
               Adds a set of files to the <c>ZipFile</c>, using the specified directory
               path in the archive, and preserving the full directory structure in the
               filenames.
             </summary>
            
             <remarks>
             <para>
               If preserveDirHierarchy is true, any directory structure present in the
               filenames contained in the list is preserved in the archive.  On the other
               hand, if preserveDirHierarchy is false, any directory structure that may
               be present in the filenames contained in the list is "flattened" in the
               archive; Each file in the list is added to the archive in the specified
               top-level directory.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            
             </remarks>
            
             <param name="fileNames">
               The names of the files to add. Each string should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the file name.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            
             <param name="preserveDirHierarchy">
               whether the entries in the zip archive will reflect the directory
               hierarchy that is present in the various filenames.  For example, if <paramref name="fileNames"/>
               includes two paths, \Animalia\Chordata\Mammalia\Info.txt and
               \Plantae\Magnoliophyta\Dicotyledon\Info.txt, then calling this method with
               <paramref name="preserveDirHierarchy"/> = <c>false</c> will result in an
               exception because of a duplicate entry name, while calling this method
               with <paramref name="preserveDirHierarchy"/> = <c>true</c> will result in the
               full direcory paths being included in the entries added to the ZipFile.
             </param>
             <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFiles(System.Collections.Generic.IEnumerable{System.String},System.String)">
             <summary>
               Adds or updates a set of files to the <c>ZipFile</c>, using the specified
               directory path in the archive.
             </summary>
            
             <remarks>
            
             <para>
               Any files that already exist in the archive are updated. Any files that
               don't yet exist in the archive are added.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The names of the files to add or update. Each string should refer to a
               file in the filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the file name.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFile(System.String)">
             <summary>
               Adds or Updates a File in a Zip file archive.
             </summary>
            
             <remarks>
             <para>
               This method adds a file to a zip archive, or, if the file already exists
               in the zip archive, this method Updates the content of that given filename
               in the zip archive.  The <c>UpdateFile</c> method might more accurately be
               called "AddOrUpdateFile".
             </para>
            
             <para>
               Upon success, there is no way for the application to learn whether the file
               was added versus updated.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <example>
            
               This example shows how to Update an existing entry in a zipfile. The first
               call to UpdateFile adds the file to the newly-created zip archive.  The
               second call to UpdateFile updates the content for that file in the zip
               archive.
            
             <code>
             using (ZipFile zip1 = new ZipFile())
             {
               // UpdateFile might more accurately be called "AddOrUpdateFile"
               zip1.UpdateFile("MyDocuments\\Readme.txt");
               zip1.UpdateFile("CustomerList.csv");
               zip1.Comment = "This zip archive has been created.";
               zip1.Save("Content.zip");
             }
            
             using (ZipFile zip2 = ZipFile.Read("Content.zip"))
             {
               zip2.UpdateFile("Updates\\Readme.txt");
               zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed.";
               zip2.Save();
             }
            
             </code>
             <code lang="VB">
               Using zip1 As New ZipFile
                   ' UpdateFile might more accurately be called "AddOrUpdateFile"
                   zip1.UpdateFile("MyDocuments\Readme.txt")
                   zip1.UpdateFile("CustomerList.csv")
                   zip1.Comment = "This zip archive has been created."
                   zip1.Save("Content.zip")
               End Using
            
               Using zip2 As ZipFile = ZipFile.Read("Content.zip")
                   zip2.UpdateFile("Updates\Readme.txt")
                   zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed."
                   zip2.Save
               End Using
             </code>
             </example>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <param name="fileName">
               The name of the file to add or update. It should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <returns>
               The <c>ZipEntry</c> corresponding to the File that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)">
             <summary>
               Adds or Updates a File in a Zip file archive.
             </summary>
            
             <remarks>
             <para>
               This method adds a file to a zip archive, or, if the file already exists
               in the zip archive, this method Updates the content of that given filename
               in the zip archive.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive.  The entry to be added or
               updated is found by using the specified directory path, combined with the
               basename of the specified filename.
             </para>
            
             <para>
               Upon success, there is no way for the application to learn if the file was
               added versus updated.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <param name="fileName">
               The name of the file to add or update. It should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>fileName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>fileName</c>, if any.  Passing the empty string ("") will insert the
               item at the root path within the archive.
             </param>
            
             <returns>
               The <c>ZipEntry</c> corresponding to the File that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)">
             <summary>
               Add or update a directory in a zip archive.
             </summary>
            
             <remarks>
               If the specified directory does not exist in the archive, then this method
               is equivalent to calling <c>AddDirectory()</c>.  If the specified
               directory already exists in the archive, then this method updates any
               existing entries, and adds any new entries. Any entries that are in the
               zip archive but not in the specified directory, are left alone.  In other
               words, the contents of the zip file will be a union of the previous
               contents and the new files.
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <param name="directoryName">
               The path to the directory to be added to the zip archive, or updated in
               the zip archive.
             </param>
            
             <returns>
             The <c>ZipEntry</c> corresponding to the Directory that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)">
             <summary>
               Add or update a directory in the zip archive at the specified root
               directory in the archive.
             </summary>
            
             <remarks>
               If the specified directory does not exist in the archive, then this method
               is equivalent to calling <c>AddDirectory()</c>.  If the specified
               directory already exists in the archive, then this method updates any
               existing entries, and adds any new entries. Any entries that are in the
               zip archive but not in the specified directory, are left alone.  In other
               words, the contents of the zip file will be a union of the previous
               contents and the new files.
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <param name="directoryName">
               The path to the directory to be added to the zip archive, or updated in the
               zip archive.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>directoryName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>directoryName</c>, if any.  Passing the empty string ("") will insert
               the item at the root path within the archive.
             </param>
            
             <returns>
               The <c>ZipEntry</c> corresponding to the Directory that was added or updated.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateItem(System.String)">
             <summary>
               Add or update a file or directory in the zip archive.
             </summary>
            
             <remarks>
             <para>
               This is useful when the application is not sure or does not care if the
               item to be added is a file or directory, and does not know or does not
               care if the item already exists in the <c>ZipFile</c>. Calling this method
               is equivalent to calling <c>RemoveEntry()</c> if an entry by the same name
               already exists, followed calling by <c>AddItem()</c>.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)"/>
            
             <param name="itemName">the path to the file or directory to be added or updated.</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)">
             <summary>
               Add or update a file or directory.
             </summary>
            
             <remarks>
             <para>
               This method is useful when the application is not sure or does not care if
               the item to be added is a file or directory, and does not know or does not
               care if the item already exists in the <c>ZipFile</c>. Calling this method
               is equivalent to calling <c>RemoveEntry()</c>, if an entry by that name
               exists, and then calling <c>AddItem()</c>.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used for the item being added to the archive.  The
               entry or entries that are added or updated will use the specified
               <c>DirectoryPathInArchive</c>. Extracting the entry from the archive will
               result in a file stored in that directory path.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
            
             <param name="itemName">The path for the File or Directory to be added or updated.</param>
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>itemName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>itemName</c>, if any.  Passing the empty string ("") will insert the
               item at the root path within the archive.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)">
             <summary>
               Adds a named entry into the zip archive, taking content for the entry
               from a string.
             </summary>
            
             <remarks>
               Calling this method creates an entry using the given fileName and
               directory path within the archive.  There is no need for a file by the
               given name to exist in the filesystem; the name is used within the zip
               archive only. The content for the entry is encoded using the default text
               encoding (<see cref="P:System.Text.Encoding.Default"/>).
             </remarks>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <param name="entryName">
               The name, including any path, to use for the entry within the archive.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
             <example>
            
             This example shows how to add an entry to the zipfile, using a string as
             content for that entry.
            
             <code lang="C#">
             string Content = "This string will be the content of the Readme.txt file in the zip archive.";
             using (ZipFile zip1 = new ZipFile())
             {
               zip1.AddFile("MyDocuments\\Resume.doc", "files");
               zip1.AddEntry("Readme.txt", Content);
               zip1.Comment = "This zip file was created at " + System.DateTime.Now.ToString("G");
               zip1.Save("Content.zip");
             }
            
             </code>
             <code lang="VB">
             Public Sub Run()
               Dim Content As String = "This string will be the content of the Readme.txt file in the zip archive."
               Using zip1 As ZipFile = New ZipFile
                 zip1.AddEntry("Readme.txt", Content)
                 zip1.AddFile("MyDocuments\Resume.doc", "files")
                 zip1.Comment = ("This zip file was created at " &amp; DateTime.Now.ToString("G"))
                 zip1.Save("Content.zip")
               End Using
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.Text.Encoding)">
             <summary>
               Adds a named entry into the zip archive, taking content for the entry
               from a string, and using the specified text encoding.
             </summary>
            
             <remarks>
            
             <para>
               Calling this method creates an entry using the given fileName and
               directory path within the archive.  There is no need for a file by the
               given name to exist in the filesystem; the name is used within the zip
               archive only.
             </para>
            
             <para>
               The content for the entry, a string value, is encoded using the given text
               encoding. No Byte-order-mark (BOM) is emitted into the file.
             </para>
            
             <para>
               If you wish to create within a zip file a file entry with Unicode-encoded
               content that includes a byte-order-mark, you can convert your string to a
               byte array using the appropriate <see cref="M:System.Text.Encoding.GetBytes(System.String)">System.Text.Encoding.GetBytes()</see>
               method, then prepend to that byte array the output of <see cref="M:System.Text.Encoding.GetPreamble">System.Text.Encoding.GetPreamble()</see>,
               and use the <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.Byte[])"/> method, to add the
               entry.
             </para>
            
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <param name="encoding">
               The text encoding to use when encoding the string. Be aware: This is
               distinct from the text encoding used to encode the fileName, as specified
               in <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)">
             <summary>
               Create an entry in the <c>ZipFile</c> using the given <c>Stream</c> as input.
               The entry will have the given filename.
             </summary>
            
             <remarks>
            
             <para>
               The application can provide an open, readable stream; in this case it will
               be read during the call to <see cref="M:Ionic.Zip.ZipFile.Save"/> or one of its
               overloads.
             </para>
            
             <para>
               In cases where a large number of streams will be added to the
               <c>ZipFile</c>, the application may wish to avoid maintaining all of the
               streams open simultaneously.  To handle this situation, the application
               should use the <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)"/>
               overload.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example adds a single entry to a <c>ZipFile</c> via a <c>Stream</c>.
             </para>
            
             <code lang="C#">
             String zipToCreate = "Content.zip";
             String fileNameInArchive = "Content-From-Stream.bin";
             using (System.IO.Stream streamToRead = MyStreamOpener())
             {
               using (ZipFile zip = new ZipFile())
               {
                 ZipEntry entry= zip.AddEntry(fileNameInArchive, streamToRead);
                 zip.AddFile("Readme.txt");
                 zip.Save(zipToCreate);  // the stream is read implicitly here
               }
             }
             </code>
            
             <code lang="VB">
             Dim zipToCreate As String = "Content.zip"
             Dim fileNameInArchive As String = "Content-From-Stream.bin"
             Using streamToRead as System.IO.Stream = MyStreamOpener()
               Using zip As ZipFile = New ZipFile()
                 Dim entry as ZipEntry = zip.AddEntry(fileNameInArchive, streamToRead)
                 zip.AddFile("Readme.txt")
                 zip.Save(zipToCreate)  '' the stream is read implicitly, here
               End Using
             End Using
             </code>
             </example>
            
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.IO.Stream)"/>
            
             <param name="entryName">
               The name, including any path, which is shown in the zip file for the added
               entry.
             </param>
             <param name="stream">The input stream from which to grab content for the file</param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.WriteDelegate)">
             <summary>
               Add a ZipEntry for which content is written directly by the application.
             </summary>
            
             <remarks>
             <para>
               When the application needs to write the zip entry data, use this method to
               add the ZipEntry.  For example, in the case that the application wishes to
               write the XML representation of a DataSet into a ZipEntry, the application
               can use this method to do so.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             <para>
               NB: With PKZip encryption, it's necessary to compute the CRC before
               compressing or encrypting the data.  Therefore, when using PKZip
               encryption with a WriteDelegate, the WriteDelegate will be called twice:
               once to compute the CRC, and the second time to (potentially) compress and
               encrypt. For each call of the delegate, your application must stream the
               same entry data in its entirety. If your application writes different data
               during the second call, it will result in a corrupt zip file.
             </para>
            
             </remarks>
            
             <param name="entryName">the name of the entry to add</param>
             <param name="writer">the delegate which will write the entry content</param>
             <returns>the ZipEntry added</returns>
            
             <example>
            
               This example shows an application filling a DataSet, then saving the
               contents of that DataSet as XML, into a ZipEntry in a ZipFile, using an
               anonymous delegate in C#. The DataSet XML is never saved to a disk file.
            
             <code lang="C#">
             var c1= new System.Data.SqlClient.SqlConnection(connstring1);
             var da = new System.Data.SqlClient.SqlDataAdapter()
                 {
                     SelectCommand=  new System.Data.SqlClient.SqlCommand(strSelect, c1)
                 };
            
             DataSet ds1 = new DataSet();
             da.Fill(ds1, "Invoices");
            
             using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
             {
                 zip.AddEntry(zipEntryName, (name,stream) =&gt; ds1.WriteXml(stream) );
                 zip.Save(zipFileName);
             }
             </code>
             </example>
            
             <example>
            
             This example uses an anonymous method in C# as the WriteDelegate to provide
             the data for the ZipEntry. The example is a bit contrived - the
             <c>AddFile()</c> method is a simpler way to insert the contents of a file
             into an entry in a zip file. On the other hand, if there is some sort of
             processing or transformation of the file contents required before writing,
             the application could use the <c>WriteDelegate</c> to do it, in this way.
            
             <code lang="C#">
             using (var input = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ))
             {
                 using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
                 {
                     zip.AddEntry(zipEntryName, (name,output) =&gt;
                         {
                             byte[] buffer = new byte[BufferSize];
                             int n;
                             while ((n = input.Read(buffer, 0, buffer.Length)) != 0)
                             {
                                 // could transform the data here...
                                 output.Write(buffer, 0, n);
                                 // could update a progress bar here
                             }
                         });
            
                     zip.Save(zipFileName);
                 }
             }
             </code>
             </example>
            
             <example>
            
             This example uses a named delegate in VB to write data for the given
             ZipEntry (VB9 does not have anonymous delegates). The example here is a bit
             contrived - a simpler way to add the contents of a file to a ZipEntry is to
             simply use the appropriate <c>AddFile()</c> method.  The key scenario for
             which the <c>WriteDelegate</c> makes sense is saving a DataSet, in XML
             format, to the zip file. The DataSet can write XML to a stream, and the
             WriteDelegate is the perfect place to write into the zip file.  There may be
             other data structures that can write to a stream, but cannot be read as a
             stream.  The <c>WriteDelegate</c> would be appropriate for those cases as
             well.
            
             <code lang="VB">
             Private Sub WriteEntry (ByVal name As String, ByVal output As Stream)
                 Using input As FileStream = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                     Dim n As Integer = -1
                     Dim buffer As Byte() = New Byte(BufferSize){}
                     Do While n &lt;&gt; 0
                         n = input.Read(buffer, 0, buffer.Length)
                         output.Write(buffer, 0, n)
                     Loop
                 End Using
             End Sub
            
             Public Sub Run()
                 Using zip = New ZipFile
                     zip.AddEntry(zipEntryName, New WriteDelegate(AddressOf WriteEntry))
                     zip.Save(zipFileName)
                 End Using
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,Ionic.Zip.OpenDelegate,Ionic.Zip.CloseDelegate)">
             <summary>
               Add an entry, for which the application will provide a stream, just-in-time.
             </summary>
            
             <remarks>
             <para>
               In cases where the application wishes to open the stream that holds the content for
               the ZipEntry, on a just-in-time basis, the application can use this method and
               provide delegates to open and close the stream.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses anonymous methods in C# to open and close
               the source stream for the content for a zip entry.  In a real application, the
               logic for the OpenDelegate would probably be more involved.
            
             <code lang="C#">
             using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
             {
                 zip.AddEntry(zipEntryName,
                              (name) =&gt;  File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ),
                              (name, stream) =&gt;  stream.Close()
                              );
            
                 zip.Save(zipFileName);
             }
             </code>
            
             </example>
            
             <example>
            
               This example uses delegates in VB.NET to open and close the
               the source stream for the content for a zip entry.  VB 9.0 lacks
               support for "Sub" lambda expressions, and so the CloseDelegate must
               be an actual, named Sub.
            
             <code lang="VB">
            
             Function MyStreamOpener(ByVal entryName As String) As Stream
                 '' This simply opens a file.  You probably want to do somethinig
                 '' more involved here: open a stream to read from a database,
                 '' open a stream on an HTTP connection, and so on.
                 Return File.OpenRead(entryName)
             End Function
            
             Sub MyStreamCloser(entryName As String, stream As Stream)
                 stream.Close()
             End Sub
            
             Public Sub Run()
                 Dim dirToZip As String = "fodder"
                 Dim zipFileToCreate As String = "Archive.zip"
                 Dim opener As OpenDelegate = AddressOf MyStreamOpener
                 Dim closer As CloseDelegate = AddressOf MyStreamCloser
                 Dim numFilestoAdd As Int32 = 4
                 Using zip As ZipFile = New ZipFile
                     Dim i As Integer
                     For i = 0 To numFilesToAdd - 1
                         zip.AddEntry(String.Format("content-{0:000}.txt"), opener, closer)
                     Next i
                     zip.Save(zipFileToCreate)
                 End Using
             End Sub
            
             </code>
             </example>
            
             <param name="entryName">the name of the entry to add</param>
             <param name="opener">the delegate that will be invoked to open the stream</param>
             <param name="closer">the delegate that will be invoked to close the stream</param>
             <returns>the ZipEntry added</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given string as
               input.
             </summary>
            
             <remarks>
            
             <para>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for the
               given file name and directory path, if it exists, and then calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String)"/>.  See the documentation for that
               method for further explanation.
             </para>
            
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String,System.Text.Encoding)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given string as
               content for the <c>ZipEntry</c>.
             </summary>
            
             <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for the
               given file name and directory path, if it exists, and then calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.Text.Encoding)"/>.  See the
               documentation for that method for further explanation.
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <param name="encoding">
               The text encoding to use when encoding the string. Be aware: This is
               distinct from the text encoding used to encode the filename. See <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.IO.Stream)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given stream as
               input, and the given filename and given directory Path.
             </summary>
            
             <remarks>
             <para>
               Calling the method is equivalent to calling <c>RemoveEntry()</c> if an
               entry by the same name already exists, and then calling <c>AddEntry()</c>
               with the given <c>fileName</c> and stream.
             </para>
            
             <para>
               The stream must be open and readable during the call to
               <c>ZipFile.Save</c>.  You can dispense the stream on a just-in-time basis
               using the <see cref="P:Ionic.Zip.ZipEntry.InputStream"/> property. Check the
               documentation of that property for more information.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/>
             <seealso cref="P:Ionic.Zip.ZipEntry.InputStream"/>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="stream">The input stream from which to read file data.</param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.Byte[])">
             <summary>
             Add an entry into the zip archive using the given filename and directory
             path within the archive, and the given content for the file. No file is
             created in the filesystem.
             </summary>
            
             <param name="byteContent">The data to use for the entry.</param>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.Byte[])">
             <summary>
             Updates the given entry in the <c>ZipFile</c>, using the given byte array as
             content for the entry.
             </summary>
            
             <remarks>
             Calling this method is equivalent to removing the <c>ZipEntry</c> for the
             given filename and directory path, if it exists, and then calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.Byte[])"/>.
             See the documentation for that method for further explanation.
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="byteContent">The content to use for the <c>ZipEntry</c>.</param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddDirectory(System.String)">
             <summary>
               Adds the contents of a filesystem directory to a Zip file archive.
             </summary>
            
             <remarks>
            
             <para>
               The name of the directory may be a relative path or a fully-qualified
               path. Any files within the named directory are added to the archive.  Any
               subdirectories within the named directory are also added to the archive,
               recursively.
             </para>
            
             <para>
               Top-level entries in the named directory will appear as top-level entries
               in the zip archive.  Entries in subdirectories in the named directory will
               result in entries in subdirectories in the zip archive.
             </para>
            
             <para>
               If you want the entries to appear in a containing directory in the zip
               archive itself, then you should call the AddDirectory() overload that
               allows you to explicitly specify a directory path for use in the archive.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
            
             <overloads>This method has 2 overloads.</overloads>
            
             <param name="directoryName">The name of the directory to add.</param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)">
             <summary>
               Adds the contents of a filesystem directory to a Zip file archive,
               overriding the path to be used for entries in the archive.
             </summary>
            
             <remarks>
             <para>
               The name of the directory may be a relative path or a fully-qualified
               path. The add operation is recursive, so that any files or subdirectories
               within the name directory are also added to the archive.
             </para>
            
             <para>
               Top-level entries in the named directory will appear as top-level entries
               in the zip archive.  Entries in subdirectories in the named directory will
               result in entries in subdirectories in the zip archive.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.SetCompression"/>, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               In this code, calling the ZipUp() method with a value of "c:\reports" for
               the directory parameter will result in a zip file structure in which all
               entries are contained in a toplevel "reports" directory.
             </para>
            
             <code lang="C#">
             public void ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile())
               {
                 zip.AddDirectory(directory, System.IO.Path.GetFileName(directory));
                 zip.Save(targetZip);
               }
             }
             </code>
             </example>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
            
             <param name="directoryName">The name of the directory to add.</param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               DirectoryName.  This path may, or may not, correspond to a real directory
               in the current filesystem.  If the zip is later extracted, this is the
               path used for the extracted file or directory.  Passing <c>null</c>
               (<c>Nothing</c> in VB) or the empty string ("") will insert the items at
               the root path within the archive.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddDirectoryByName(System.String)">
             <summary>
               Creates a directory in the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               Use this when you want to create a directory in the archive but there is
               no corresponding filesystem representation for that directory.
             </para>
            
             <para>
               You will probably not need to do this in your code. One of the only times
               you will want to do this is if you want an empty directory in the zip
               archive.  The reason: if you add a file to a zip archive that is stored
               within a multi-level directory, all of the directory tree is implicitly
               created in the zip archive.
             </para>
            
             </remarks>
            
             <param name="directoryNameInArchive">
               The name of the directory to create in the archive.
             </param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ContainsEntry(System.String)">
            <summary>
            Returns true if an entry by the given name exists in the ZipFile.
            </summary>
        </member>
        <member name="F:Ionic.Zip.ZipFile.DefaultEncoding">
            <summary>
            The default text encoding used in zip archives.  It is numeric 437, also
            known as IBM437.
            </summary>
            <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String)">
             <summary>
               Creates a new <c>ZipFile</c> instance, using the specified filename.
             </summary>
            
             <remarks>
             <para>
               Applications can use this constructor to create a new ZipFile for writing,
               or to slurp in an existing zip archive for read and update purposes.
             </para>
            
             <para>
               To create a new zip archive, an application can call this constructor,
               passing the name of a file that does not exist.  The name may be a fully
               qualified path. Then the application can add directories or files to the
               <c>ZipFile</c> via <c>AddDirectory()</c>, <c>AddFile()</c>, <c>AddItem()</c>
               and then write the zip archive to the disk by calling <c>Save()</c>. The
               zip file is not actually opened and written to the disk until the
               application calls <c>ZipFile.Save()</c>.  At that point the new zip file
               with the given name is created.
             </para>
            
             <para>
               If you won't know the name of the <c>Zipfile</c> until the time you call
               <c>ZipFile.Save()</c>, or if you plan to save to a stream (which has no
               name), then you should use the no-argument constructor.
             </para>
            
             <para>
               The application can also call this constructor to read an existing zip
               archive.  passing the name of a valid zip file that does exist. But, it's
               better form to use the static <see cref="M:Ionic.Zip.ZipFile.Read(System.String)"/> method,
               passing the name of the zip file, because using <c>ZipFile.Read()</c> in
               your code communicates very clearly what you are doing.  In either case,
               the file is then read into the <c>ZipFile</c> instance.  The app can then
               enumerate the entries or can modify the zip file, for example adding
               entries, removing entries, changing comments, and so on.
             </para>
            
             <para>
               One advantage to this parameterized constructor: it allows applications to
               use the same code to add items to a zip archive, regardless of whether the
               zip file exists.
             </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            
             <para>
               By the way, since DotNetZip is so easy to use, don't you think <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">you should
               donate $5 or $10</see>?
             </para>
            
             </remarks>
            
             <exception cref="T:Ionic.Zip.ZipException">
             Thrown if name refers to an existing file that is not a valid zip file.
             </exception>
            
             <example>
             This example shows how to create a zipfile, and add a few files into it.
             <code>
             String ZipFileToCreate = "archive1.zip";
             String DirectoryToZip  = "c:\\reports";
             using (ZipFile zip = new ZipFile())
             {
               // Store all files found in the top level directory, into the zip archive.
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames, "files");
               zip.Save(ZipFileToCreate);
             }
             </code>
            
             <code lang="VB">
             Dim ZipFileToCreate As String = "archive1.zip"
             Dim DirectoryToZip As String = "c:\reports"
             Using zip As ZipFile = New ZipFile()
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames, "files")
                 zip.Save(ZipFileToCreate)
             End Using
             </code>
             </example>
            
             <param name="fileName">The filename to use for the new zip archive.</param>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.Text.Encoding)">
             <summary>
               Creates a new <c>ZipFile</c> instance, using the specified name for the
               filename, and the specified Encoding.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
            
             <para>
               The Encoding is used as the default alternate encoding for entries with
               filenames or comments that cannot be encoded with the IBM437 code page.
               This is equivalent to setting the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> property on the <c>ZipFile</c>
               instance after construction.
             </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            
             </remarks>
            
             <exception cref="T:Ionic.Zip.ZipException">
             Thrown if name refers to an existing file that is not a valid zip file.
             </exception>
            
             <param name="fileName">The filename to use for the new zip archive.</param>
             <param name="encoding">The Encoding is used as the default alternate
             encoding for entries with filenames or comments that cannot be encoded
             with the IBM437 code page. </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor">
             <summary>
               Create a zip file, without specifying a target filename or stream to save to.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
            
             <para>
               After instantiating with this constructor and adding entries to the
               archive, the application should call <see cref="M:Ionic.Zip.ZipFile.Save(System.String)"/> or
               <see cref="M:Ionic.Zip.ZipFile.Save(System.IO.Stream)"/> to save to a file or a
               stream, respectively.  The application can also set the <see cref="P:Ionic.Zip.ZipFile.Name"/>
               property and then call the no-argument <see cref="M:Ionic.Zip.ZipFile.Save"/> method.  (This
               is the preferred approach for applications that use the library through
               COM interop.)  If you call the no-argument <see cref="M:Ionic.Zip.ZipFile.Save"/> method
               without having set the <c>Name</c> of the <c>ZipFile</c>, either through
               the parameterized constructor or through the explicit property , the
               Save() will throw, because there is no place to save the file.  </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               have multiple threads that each use a distinct <c>ZipFile</c> instance, or
               you can synchronize multi-thread access to a single instance.  </para>
            
             </remarks>
            
             <example>
             This example creates a Zip archive called Backup.zip, containing all the files
             in the directory DirectoryToZip. Files within subdirectories are not zipped up.
             <code>
             using (ZipFile zip = new ZipFile())
             {
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames, "files");
               zip.Save("Backup.zip");
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames, "files")
                 zip.Save("Backup.zip")
             End Using
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.Text.Encoding)">
             <summary>
               Create a zip file, specifying a text Encoding, but without specifying a
               target filename or stream to save to.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
            
             </remarks>
            
             <param name="encoding">
             The Encoding is used as the default alternate encoding for entries with
             filenames or comments that cannot be encoded with the IBM437 code page.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.IO.TextWriter)">
             <summary>
               Creates a new <c>ZipFile</c> instance, using the specified name for the
               filename, and the specified status message writer.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument</see> for basic
               information on all the <c>ZipFile</c> constructors.
             </para>
            
             <para>
               This version of the constructor allows the caller to pass in a TextWriter,
               to which verbose messages will be written during extraction or creation of
               the zip archive.  A console application may wish to pass
               System.Console.Out to get messages on the Console. A graphical or headless
               application may wish to capture the messages in a different
               <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display
               the messages in a TextBox, or generate an audit log of ZipFile operations.
             </para>
            
             <para>
               To encrypt the data for the files added to the <c>ZipFile</c> instance,
               set the Password property after creating the <c>ZipFile</c> instance.
             </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            
             </remarks>
            
             <exception cref="T:Ionic.Zip.ZipException">
             Thrown if name refers to an existing file that is not a valid zip file.
             </exception>
            
             <example>
             <code>
             using (ZipFile zip = new ZipFile("Backup.zip", Console.Out))
             {
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               // Status messages will be written to Console.Out
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames);
               zip.Save();
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile("Backup.zip", Console.Out)
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 ' Status messages will be written to Console.Out
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames)
                 zip.Save()
             End Using
             </code>
             </example>
            
             <param name="fileName">The filename to use for the new zip archive.</param>
             <param name="statusMessageWriter">A TextWriter to use for writing
             verbose status messages.</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.IO.TextWriter,System.Text.Encoding)">
             <summary>
               Creates a new <c>ZipFile</c> instance, using the specified name for the
               filename, the specified status message writer, and the specified Encoding.
             </summary>
            
             <remarks>
             <para>
               This constructor works like the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile
               constructor that accepts a single string argument.</see> See that
               reference for detail on what this constructor does.
             </para>
            
             <para>
               This version of the constructor allows the caller to pass in a
               <c>TextWriter</c>, and an Encoding.  The <c>TextWriter</c> will collect
               verbose messages that are generated by the library during extraction or
               creation of the zip archive.  A console application may wish to pass
               <c>System.Console.Out</c> to get messages on the Console. A graphical or
               headless application may wish to capture the messages in a different
               <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display
               the messages in a <c>TextBox</c>, or generate an audit log of
               <c>ZipFile</c> operations.
             </para>
            
             <para>
               The <c>Encoding</c> is used as the default alternate encoding for entries
               with filenames or comments that cannot be encoded with the IBM437 code
               page.  This is a equivalent to setting the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> property on the <c>ZipFile</c>
               instance after construction.
             </para>
            
             <para>
               To encrypt the data for the files added to the <c>ZipFile</c> instance,
               set the <c>Password</c> property after creating the <c>ZipFile</c>
               instance.
             </para>
            
             <para>
               Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
               not party on a single instance with multiple threads.  You may have
               multiple threads that each use a distinct <c>ZipFile</c> instance, or you
               can synchronize multi-thread access to a single instance.
             </para>
            
             </remarks>
            
             <exception cref="T:Ionic.Zip.ZipException">
             Thrown if <c>fileName</c> refers to an existing file that is not a valid zip file.
             </exception>
            
             <param name="fileName">The filename to use for the new zip archive.</param>
             <param name="statusMessageWriter">A TextWriter to use for writing verbose
             status messages.</param>
             <param name="encoding">
             The Encoding is used as the default alternate encoding for entries with
             filenames or comments that cannot be encoded with the IBM437 code page.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Initialize(System.String)">
             <summary>
               Initialize a <c>ZipFile</c> instance by reading in a zip file.
             </summary>
            
             <remarks>
            
             <para>
               This method is primarily useful from COM Automation environments, when
               reading or extracting zip files. In COM, it is not possible to invoke
               parameterized constructors for a class. A COM Automation application can
               update a zip file by using the <see cref="M:Ionic.Zip.ZipFile.#ctor">default (no argument)
               constructor</see>, then calling <c>Initialize()</c> to read the contents
               of an on-disk zip archive into the <c>ZipFile</c> instance.
             </para>
            
             <para>
               .NET applications are encouraged to use the <c>ZipFile.Read()</c> methods
               for better clarity.
             </para>
            
             </remarks>
             <param name="fileName">the name of the existing zip file to read in.</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntry(Ionic.Zip.ZipEntry)">
             <summary>
               Removes the given <c>ZipEntry</c> from the zip archive.
             </summary>
            
             <remarks>
             <para>
               After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to
               make the changes permanent.
             </para>
             </remarks>
            
             <exception cref="T:System.ArgumentException">
               Thrown if the specified <c>ZipEntry</c> does not exist in the <c>ZipFile</c>.
             </exception>
            
             <example>
               In this example, all entries in the zip archive dating from before
               December 31st, 2007, are removed from the archive.  This is actually much
               easier if you use the RemoveSelectedEntries method.  But I needed an
               example for RemoveEntry, so here it is.
             <code>
             String ZipFileToRead = "ArchiveToModify.zip";
             System.DateTime Threshold = new System.DateTime(2007,12,31);
             using (ZipFile zip = ZipFile.Read(ZipFileToRead))
             {
               var EntriesToRemove = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                 {
                   // We cannot remove the entry from the list, within the context of
                   // an enumeration of said list.
                   // So we add the doomed entry to a list to be removed later.
                   EntriesToRemove.Add(e);
                 }
               }
            
               // actually remove the doomed entries.
               foreach (ZipEntry zombie in EntriesToRemove)
                 zip.RemoveEntry(zombie);
            
               zip.Comment= String.Format("This zip archive was updated at {0}.",
                                          System.DateTime.Now.ToString("G"));
            
               // save with a different name
               zip.Save("Archive-Updated.zip");
             }
             </code>
            
             <code lang="VB">
               Dim ZipFileToRead As String = "ArchiveToModify.zip"
               Dim Threshold As New DateTime(2007, 12, 31)
               Using zip As ZipFile = ZipFile.Read(ZipFileToRead)
                   Dim EntriesToRemove As New System.Collections.Generic.List(Of ZipEntry)
                   Dim e As ZipEntry
                   For Each e In zip
                       If (e.LastModified &lt; Threshold) Then
                           ' We cannot remove the entry from the list, within the context of
                           ' an enumeration of said list.
                           ' So we add the doomed entry to a list to be removed later.
                           EntriesToRemove.Add(e)
                       End If
                   Next
            
                   ' actually remove the doomed entries.
                   Dim zombie As ZipEntry
                   For Each zombie In EntriesToRemove
                       zip.RemoveEntry(zombie)
                   Next
                   zip.Comment = String.Format("This zip archive was updated at {0}.", DateTime.Now.ToString("G"))
                   'save as a different name
                   zip.Save("Archive-Updated.zip")
               End Using
             </code>
             </example>
            
             <param name="entry">
             The <c>ZipEntry</c> to remove from the zip.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)"/>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)">
             <summary>
             Removes the <c>ZipEntry</c> with the given filename from the zip archive.
             </summary>
            
             <remarks>
             <para>
               After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to
               make the changes permanent.
             </para>
            
             </remarks>
            
             <exception cref="T:System.InvalidOperationException">
               Thrown if the <c>ZipFile</c> is not updatable.
             </exception>
            
             <exception cref="T:System.ArgumentException">
               Thrown if a <c>ZipEntry</c> with the specified filename does not exist in
               the <c>ZipFile</c>.
             </exception>
            
             <example>
            
               This example shows one way to remove an entry with a given filename from
               an existing zip archive.
            
             <code>
             String zipFileToRead= "PackedDocuments.zip";
             string candidate = "DatedMaterial.xps";
             using (ZipFile zip = ZipFile.Read(zipFileToRead))
             {
               if (zip.EntryFilenames.Contains(candidate))
               {
                 zip.RemoveEntry(candidate);
                 zip.Comment= String.Format("The file '{0}' has been removed from this archive.",
                                            Candidate);
                 zip.Save();
               }
             }
             </code>
             <code lang="VB">
               Dim zipFileToRead As String = "PackedDocuments.zip"
               Dim candidate As String = "DatedMaterial.xps"
               Using zip As ZipFile = ZipFile.Read(zipFileToRead)
                   If zip.EntryFilenames.Contains(candidate) Then
                       zip.RemoveEntry(candidate)
                       zip.Comment = String.Format("The file '{0}' has been removed from this archive.", Candidate)
                       zip.Save
                   End If
               End Using
             </code>
             </example>
            
             <param name="fileName">
             The name of the file, including any directory path, to remove from the zip.
             The filename match is not case-sensitive by default; you can use the
             <c>CaseSensitiveRetrieval</c> property to change this behavior. The
             pathname can use forward-slashes or backward slashes.
             </param>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Dispose">
             <summary>
               Closes the read and write streams associated
               to the <c>ZipFile</c>, if necessary.
             </summary>
            
             <remarks>
               The Dispose() method is generally employed implicitly, via a <c>using(..) {..}</c>
               statement. (<c>Using...End Using</c> in VB) If you do not employ a using
               statement, insure that your application calls Dispose() explicitly.  For
               example, in a Powershell application, or an application that uses the COM
               interop interface, you must call Dispose() explicitly.
             </remarks>
            
             <example>
             This example extracts an entry selected by name, from the Zip file to the
             Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               foreach (ZipEntry e in zip)
               {
                 if (WantThisEntry(e.FileName))
                   zip.Extract(e.FileName, Console.OpenStandardOutput());
               }
             } // Dispose() is called implicitly here.
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(zipfile)
                 Dim e As ZipEntry
                 For Each e In zip
                   If WantThisEntry(e.FileName) Then
                       zip.Extract(e.FileName, Console.OpenStandardOutput())
                   End If
                 Next
             End Using ' Dispose is implicity called here
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Dispose(System.Boolean)">
             <summary>
               Disposes any managed resources, if the flag is set, then marks the
               instance disposed.  This method is typically not called explicitly from
               application code.
             </summary>
            
             <remarks>
               Applications should call <see cref="M:Ionic.Zip.ZipFile.Dispose">the no-arg Dispose method</see>.
             </remarks>
            
             <param name="disposeManagedResources">
               indicates whether the method should dispose streams or not.
             </param>
        </member>
        <member name="F:Ionic.Zip.ZipFile.IoBufferSizeDefault">
            <summary>
              Default size of the buffer used for IO.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractAll(System.String)">
             <summary>
             Extracts all of the items in the zip archive, to the specified path in the
             filesystem.  The path can be relative or fully-qualified.
             </summary>
            
             <remarks>
             <para>
             This method will extract all entries in the <c>ZipFile</c> to the specified path.
             </para>
            
             <para>
             If an extraction of a file from the zip archive would overwrite an existing
             file in the filesystem, the action taken is dictated by the
             ExtractExistingFile property, which overrides any setting you may have made
             on individual ZipEntry instances.  By default, if you have not set that
             property on the <c>ZipFile</c> instance, the entry will not be extracted,
             the existing file will not be overwritten and an exception will be
             thrown. To change this, set the property, or use the <see cref="M:Ionic.Zip.ZipFile.ExtractAll(System.String,Ionic.Zip.ExtractExistingFileAction)"/>
             overload that allows you to specify an ExtractExistingFileAction parameter.
             </para>
            
             <para>
             The action to take when an extract would overwrite an existing file applies
             to all entries.  If you want to set this on a per-entry basis, then you must
             use one of the <see cref="M:ZipEntry.Extract">ZipEntry.Extract</see> methods.
             </para>
            
             <para>
             This method will send verbose output messages to the
             <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter"/>, if it is set on the <c>ZipFile</c> instance.
             </para>
            
             <para>
             You may wish to take advantage of the <c>ExtractProgress</c> event.
             </para>
            
             <para>
             About Timestamps: When extracting a file entry from a zip archive, the
             extracted file gets the last modified time of the entry as stored in the
             archive. The archive may also store extended file timestamp information,
             including last accessed and created times. If these are present in the
             <c>ZipEntry</c>, then the extracted file will also get these times.
             </para>
            
             <para>
             A Directory entry is somewhat different. It will get the times as described
             for a file entry, but, if there are file entries in the zip archive that,
             when extracted, appear in the just-created directory, then when those file
             entries are extracted, the last modified and last accessed times of the
             directory will change, as a side effect.  The result is that after an
             extraction of a directory and a number of files within the directory, the
             last modified and last accessed timestamps on the directory will reflect the
             time that the last file was extracted into the directory, rather than the
             time stored in the zip archive for the directory.
             </para>
            
             <para>
             To compensate, when extracting an archive with <c>ExtractAll</c>, DotNetZip
             will extract all the file and directory entries as described above, but it
             will then make a second pass on the directories, and reset the times on the
             directories to reflect what is stored in the zip archive.
             </para>
            
             <para>
             This compensation is performed only within the context of an
             <c>ExtractAll</c>. If you call <c>ZipEntry.Extract</c> on a directory entry,
             the timestamps on directory in the filesystem will reflect the times stored
             in the zip.  If you then call <c>ZipEntry.Extract</c> on a file entry, which
             is extracted into the directory, the timestamps on the directory will be
             updated to the current time.
             </para>
             </remarks>
            
             <example>
             This example extracts all the entries in a zip archive file, to the
             specified target directory.  The extraction will overwrite any existing
             files silently.
             <code>
             String TargetDirectory= "unpack";
             using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
             {
                 zip.ExtractExistingFile= ExtractExistingFileAction.OverwriteSilently;
                 zip.ExtractAll(TargetDirectory);
             }
             </code>
            
             <code lang="VB">
             Dim TargetDirectory As String = "unpack"
             Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                 zip.ExtractExistingFile= ExtractExistingFileAction.OverwriteSilently
                 zip.ExtractAll(TargetDirectory)
             End Using
             </code>
             </example>
            
             <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress"/>
             <seealso cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/>
            
             <param name="path">
             The path to which the contents of the zipfile will be extracted.
             The path can be relative or fully-qualified.
             </param>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractAll(System.String,Ionic.Zip.ExtractExistingFileAction)">
             <summary>
             Extracts all of the items in the zip archive, to the specified path in the
             filesystem, using the specified behavior when extraction would overwrite an
             existing file.
             </summary>
            
             <remarks>
            
             <para>
             This method will extract all entries in the <c>ZipFile</c> to the specified
             path.  For an extraction that would overwrite an existing file, the behavior
             is dictated by <paramref name="extractExistingFile"/>, which overrides any
             setting you may have made on individual ZipEntry instances.
             </para>
            
             <para>
             The action to take when an extract would overwrite an existing file
             applies to all entries.  If you want to set this on a per-entry basis,
             then you must use <see cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)"/> or one of the similar methods.
             </para>
            
             <para>
             Calling this method is equivalent to setting the <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile"/> property and then calling <see cref="M:Ionic.Zip.ZipFile.ExtractAll(System.String)"/>.
             </para>
            
             <para>
             This method will send verbose output messages to the
             <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter"/>, if it is set on the <c>ZipFile</c> instance.
             </para>
             </remarks>
            
             <example>
             This example extracts all the entries in a zip archive file, to the
             specified target directory.  It does not overwrite any existing files.
             <code>
             String TargetDirectory= "c:\\unpack";
             using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
             {
               zip.ExtractAll(TargetDirectory, ExtractExistingFileAction.DontOverwrite);
             }
             </code>
            
             <code lang="VB">
             Dim TargetDirectory As String = "c:\unpack"
             Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                 zip.ExtractAll(TargetDirectory, ExtractExistingFileAction.DontOverwrite)
             End Using
             </code>
             </example>
            
             <param name="path">
             The path to which the contents of the zipfile will be extracted.
             The path can be relative or fully-qualified.
             </param>
            
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
             <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String)">
             <summary>
             Reads a zip file archive and returns the instance.
             </summary>
            
             <remarks>
             <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the
             <c>IBM437</c> codepage.
             </para>
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown if the <c>ZipFile</c> cannot be read. The implementation of this method
             relies on <c>System.IO.File.OpenRead</c>, which can throw a variety of exceptions,
             including specific exceptions if a file is not found, an unauthorized access
             exception, exceptions for poorly formatted filenames, and so on.
             </exception>
            
             <param name="fileName">
             The name of the zip archive to open.  This can be a fully-qualified or relative
             pathname.
             </param>
            
             <overloads>This method has a bunch of interesting overloads. They are all
             static (Shared in VB).  One of them is bound to be right for you.  The
             reason there are so many is that there are a few properties on the
             <c>ZipFile</c> class that must be set before you read the zipfile in, for
             them to be useful.  The set of overloads covers the most interesting cases.
             Probably there are still too many, though.</overloads>
            
             <returns>The instance read from the zip archive.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
             <summary>
             Reads a zip file archive and returns the instance, using the specified
             ReadProgress event handler.
             </summary>
            
             <param name="fileName">
             The name of the zip archive to open.
             This can be a fully-qualified or relative pathname.
             </param>
            
             <param name="readProgress">
             An event handler for Read operations.
             </param>
            
             <returns>The instance read from the zip archive.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter)">
             <summary>
             Reads a zip file archive using the specified text encoding, and returns the
             instance.
             </summary>
            
             <remarks>
             <para>
             This version of the method allows the caller to pass in a <c>TextWriter</c>.
             The ZipFile is read in using the default IBM437 encoding for entries where UTF-8
             encoding is not explicitly specified.
             </para>
             </remarks>
            
             <example>
             <code lang="C#">
             var sw = new System.IO.StringWriter();
             using (ZipFile zip =  ZipFile.Read("PackedDocuments.zip", sw))
             {
               var Threshold = new DateTime(2007,7,4);
               // We cannot remove the entry from the list, within the context of
               // an enumeration of said list.
               // So we add the doomed entry to a list to be removed later.
               // pass 1: mark the entries for removal
               var MarkedEntries = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                   MarkedEntries.Add(e);
               }
               // pass 2: actually remove the entry.
               foreach (ZipEntry zombie in MarkedEntries)
                  zip.RemoveEntry(zombie);
               zip.Comment = "This archive has been updated.";
               zip.Save();
             }
             // can now use contents of sw, eg store in an audit log
             </code>
            
             <code lang="VB">
               Dim sw As New System.IO.StringWriter
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip", sw)
                   Dim Threshold As New DateTime(2007, 7, 4)
                   ' We cannot remove the entry from the list, within the context of
                   ' an enumeration of said list.
                   ' So we add the doomed entry to a list to be removed later.
                   ' pass 1: mark the entries for removal
                   Dim MarkedEntries As New System.Collections.Generic.List(Of ZipEntry)
                   Dim e As ZipEntry
                   For Each e In zip
                       If (e.LastModified &lt; Threshold) Then
                           MarkedEntries.Add(e)
                       End If
                   Next
                   ' pass 2: actually remove the entry.
                   Dim zombie As ZipEntry
                   For Each zombie In MarkedEntries
                       zip.RemoveEntry(zombie)
                   Next
                   zip.Comment = "This archive has been updated."
                   zip.Save
               End Using
               ' can now use contents of sw, eg store in an audit log
             </code>
             </example>
            
             <exception cref="T:System.Exception">
             Thrown if the zipfile cannot be read. The implementation of this
             method relies on <c>System.IO.File.OpenRead</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on.
             </exception>
            
             <param name="fileName">
             The name of the zip archive to open.
             This can be a fully-qualified or relative pathname.
             </param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages
             during operations on the zip archive.  A console application may wish to
             pass <c>System.Console.Out</c> to get messages on the Console. A graphical
             or headless application may wish to capture the messages in a different
             <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
             </param>
            
             <returns>The instance read from the zip archive.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
             <summary>
             Reads a zip file archive using the specified text encoding, and the
             specified ReadProgress event handler, and returns the instance.
             </summary>
            
             <param name="fileName">
             The name of the zip archive to open.
             This can be a fully-qualified or relative pathname.
             </param>
            
             <param name="readProgress">
             An event handler for Read operations.
             </param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages
             during operations on the zip archive.  A console application may wish to
             pass <c>System.Console.Out</c> to get messages on the Console. A graphical
             or headless application may wish to capture the messages in a different
             <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
             </param>
            
             <returns>The instance read from the zip archive.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.Text.Encoding)">
             <summary>
             Reads a zip file archive using the specified text encoding, and returns the instance.
             </summary>
            
             <remarks>
             <para>
             This version of the method allows the caller to pass in an <c>Encoding</c>.
             The ZipFile is read in using the specified encoding for entries where UTF-8
             encoding is not explicitly specified.
             </para>
             </remarks>
            
             <example>
             This example shows how to read a zip file using the Big-5 Chinese code page
             (950), and extract each entry in the zip file.  For this code to work as
             desired, the zipfile must have been created using the big5 code page
             (CP950). This is typical, for example, when using WinRar on a machine with
             CP950 set as the default code page.  In that case, the names of entries
             within the Zip archive will be stored in that code page, and reading the zip
             archive must be done using that code page.  If the application did not use
             the correct code page in ZipFile.Read(), then names of entries within the
             zip archive would not be correctly retrieved.
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read(ZipToExtract,
                                               System.Text.Encoding.GetEncoding(950)))
             {
               foreach (ZipEntry e in zip)
               {
                  e.Extract(extractDirectory);
               }
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipToExtract, System.Text.Encoding.GetEncoding(950))
                 Dim e As ZipEntry
                 For Each e In zip
                  e.Extract(extractDirectory)
                 Next
             End Using
             </code>
             </example>
            
             <exception cref="T:System.Exception">
             Thrown if the zipfile cannot be read. The implementation of this
             method relies on <c>System.IO.File.OpenRead</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on.
             </exception>
            
             <param name="fileName">
             The name of the zip archive to open.
             This can be a fully-qualified or relative pathname.
             </param>
            
             <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
             careful specifying the encoding.  If the value you use here is not the same
             as the Encoding used when the zip archive was created (possibly by a
             different archiver) you will get unexpected results and possibly exceptions.
             </param>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>.
            
             <returns>The instance read from the zip archive.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
             <summary>
             Reads a zip file archive using the specified text encoding and ReadProgress
             event handler, and returns the instance.
             </summary>
            
             <param name="fileName">
             The name of the zip archive to open.
             This can be a fully-qualified or relative pathname.
             </param>
            
             <param name="readProgress">
             An event handler for Read operations.
             </param>
            
             <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
             careful specifying the encoding.  If the value you use here is not the same
             as the Encoding used when the zip archive was created (possibly by a
             different archiver) you will get unexpected results and possibly exceptions.
             </param>
            
             <returns>The instance read from the zip archive.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter,System.Text.Encoding)">
             <summary>
             Reads a zip file archive using the specified text encoding and the specified
             TextWriter for status messages, and returns the instance.
             </summary>
            
             <remarks>
             <para>
             This version of the method allows the caller to pass in a <c>TextWriter</c>
             and an <c>Encoding</c>.  The ZipFile is read in using the specified encoding
             for entries where UTF-8 encoding is not explicitly specified.
             </para>
             </remarks>
            
            
             <example>
             This example shows how to read a zip file using the Big-5 Chinese code page
             (950), and extract each entry in the zip file, while sending status messages
             out to the Console.
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read(ZipToExtract,
                                               System.Console.Out,
                                               System.Text.Encoding.GetEncoding(950)))
             {
               foreach (ZipEntry e in zip)
               {
                  e.Extract(extractDirectory);
               }
             }
             </code>
             </example>
            
             <exception cref="T:System.Exception">
             Thrown if the zipfile cannot be read. The implementation of this
             method relies on <c>System.IO.File.OpenRead</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on.
             </exception>
            
             <param name="fileName">
             The name of the zip archive to open.
             This can be a fully-qualified or relative pathname.
             </param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages
             during operations on the zip archive.  A console application may wish to
             pass <c>System.Console.Out</c> to get messages on the Console. A graphical
             or headless application may wish to capture the messages in a different
             <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
             </param>
            
             <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
             careful specifying the encoding.  If the value you use here is not the same
             as the Encoding used when the zip archive was created (possibly by a
             different archiver) you will get unexpected results and possibly exceptions.
             </param>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
            
             <returns>The instance read from the zip archive.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
             <summary>
             Reads a zip file archive using the specified text encoding,  the specified
             TextWriter for status messages, and the specified ReadProgress event handler,
             and returns the instance.
             </summary>
            
             <param name="fileName">
             The name of the zip archive to open.
             This can be a fully-qualified or relative pathname.
             </param>
            
             <param name="readProgress">
             An event handler for Read operations.
             </param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages
             during operations on the zip archive.  A console application may wish to
             pass <c>System.Console.Out</c> to get messages on the Console. A graphical
             or headless application may wish to capture the messages in a different
             <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
             </param>
            
             <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
             careful specifying the encoding.  If the value you use here is not the same
             as the Encoding used when the zip archive was created (possibly by a
             different archiver) you will get unexpected results and possibly exceptions.
             </param>
            
             <returns>The instance read from the zip archive.</returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream)">
             <summary>
             Reads a zip archive from a stream.
             </summary>
            
             <remarks>
             <para>
             This is useful when when the zip archive content is available from an
             already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed.
             </para>
            
             <para>
             Using this overload, the stream is read using the default
             <c>System.Text.Encoding</c>, which is the <c>IBM437</c> codepage. If you
             want to specify the encoding to use when reading the zipfile content, check
             out the other overloads of the ZipFile constructor.
             </para>
            
             <para>
             Reading of zip content begins at the current position in the stream.  This
             means if you have a stream that concatenates regular data and zip data, if
             you position the open, readable stream at the start of the zip data, you
             will be able to read the zip archive using this constructor, or any of the
             ZipFile constructors that accept a <see cref="T:System.IO.Stream"/> as
             input. Some examples of where this might be useful: the zip content is
             concatenated at the end of a regular EXE file, as some self-extracting
             archives do.  (Note: SFX files produced by DotNetZip do not work this
             way). Another example might be a stream being read from a database, where
             the zip content is embedded within an aggregate stream of data.
             </para>
             </remarks>
            
             <example>
             <para>
             This example shows how to Read zip content from a stream, and extract one
             entry into a different stream. In this example, the filename
             "NameOfEntryInArchive.doc", refers only to the name of the entry within the
             zip archive.  A file by that name is not created in the filesystem.  The I/O
             is done strictly with the given streams.
             </para>
            
             <code>
             using (ZipFile zip = ZipFile.Read(InputStream))
             {
                zip.Extract("NameOfEntryInArchive.doc", OutputStream);
             }
             </code>
             <code lang="VB">
             Using zip as ZipFile = ZipFile.Read(InputStream)
                zip.Extract("NameOfEntryInArchive.doc", OutputStream)
             End Using
             </code>
             </example>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
             <summary>
             Reads a zip archive from a stream, with a given ReadProgress event handler.
             </summary>
            
             <remarks>
             <para>
             When opening large zip archives, you may want to display a progress bar or
             other indicator of status progress while reading.  This Read() method allows
             you to specify a ReadProgress Event Handler directly.  The stream is read
             using the default encoding (IBM437).
             </para>
            
             <para>
             Reading of zip content begins at the current position in the stream.  This
             means if you have a stream that concatenates regular data and zip data, if
             you position the open, readable stream at the start of the zip data, you
             will be able to read the zip archive using this constructor, or any of the
             ZipFile constructors that accept a <see cref="T:System.IO.Stream"/> as
             input. Some examples of where this might be useful: the zip content is
             concatenated at the end of a regular EXE file, as some self-extracting
             archives do.  (Note: SFX files produced by DotNetZip do not work this
             way). Another example might be a stream being read from a database, where
             the zip content is embedded within an aggregate stream of data.
             </para>
             </remarks>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <param name="readProgress">
             An event handler for Read operations.
             </param>
            
             <returns>an instance of ZipFile corresponding to the stream being read.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter)">
             <summary>
             Reads a zip archive from a stream, using the specified TextWriter for status
             messages.
             </summary>
            
             <remarks>
             <para>
             This method is useful when when the zip archive content is available from
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed.
             </para>
            
             <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is
             the <c>IBM437</c> codepage.  For more information on the encoding, see the
             <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> property.
             </para>
            
             <para>
             Reading of zip content begins at the current position in the stream.  This
             means if you have a stream that concatenates regular data and zip data, if
             you position the open, readable stream at the start of the zip data, you
             will be able to read the zip archive using this constructor, or any of the
             ZipFile constructors that accept a <see cref="T:System.IO.Stream"/> as
             input. Some examples of where this might be useful: the zip content is
             concatenated at the end of a regular EXE file, as some self-extracting
             archives do.  (Note: SFX files produced by DotNetZip do not work this
             way). Another example might be a stream being read from a database, where
             the zip content is embedded within an aggregate stream of data.
             </para>
            
             </remarks>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written
             during operations on the <c>ZipFile</c>.  For example, in a console
             application, System.Console.Out works, and will get a message for each entry
             added to the ZipFile.  If the TextWriter is <c>null</c>, no verbose messages
             are written.
             </param>
            
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
             <summary>
             Reads a zip archive from a stream, using the specified TextWriter for status
             messages, and the specified ReadProgress event handler.
             </summary>
            
             <remarks>
             <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is
             the <c>IBM437</c> codepage.  For more information on the encoding, see the
             <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> property.
             </para>
            
             <para>
             Reading of zip content begins at the current position in the stream.  This
             means if you have a stream that concatenates regular data and zip data, if
             you position the open, readable stream at the start of the zip data, you
             will be able to read the zip archive using this constructor, or any of the
             ZipFile constructors that accept a <see cref="T:System.IO.Stream"/> as
             input. Some examples of where this might be useful: the zip content is
             concatenated at the end of a regular EXE file, as some self-extracting
             archives do.  (Note: SFX files produced by DotNetZip do not work this
             way). Another example might be a stream being read from a database, where
             the zip content is embedded within an aggregate stream of data.
             </para>
             </remarks>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written
             during operations on the <c>ZipFile</c>.  For example, in a console
             application, System.Console.Out works, and will get a message for each entry
             added to the ZipFile.  If the TextWriter is <c>null</c>, no verbose messages
             are written.
             </param>
            
             <param name="readProgress">
             An event handler for Read operations.
             </param>
            
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.Text.Encoding)">
             <summary>
             Reads a zip archive from a stream, using the specified encoding.
             </summary>
            
             <remarks>
             <para>
             This method is useful when when the zip archive content is available from
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed.
             </para>
            
             <para>
             Reading of zip content begins at the current position in the stream.  This
             means if you have a stream that concatenates regular data and zip data, if
             you position the open, readable stream at the start of the zip data, you
             will be able to read the zip archive using this constructor, or any of the
             ZipFile constructors that accept a <see cref="T:System.IO.Stream"/> as
             input. Some examples of where this might be useful: the zip content is
             concatenated at the end of a regular EXE file, as some self-extracting
             archives do.  (Note: SFX files produced by DotNetZip do not work this
             way). Another example might be a stream being read from a database, where
             the zip content is embedded within an aggregate stream of data.
             </para>
             </remarks>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8
             encoding bit set.  Be careful specifying the encoding.  If the value you use
             here is not the same as the Encoding used when the zip archive was created
             (possibly by a different archiver) you will get unexpected results and
             possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
             property for more information.
             </param>
            
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
             <summary>
             Reads a zip archive from a stream, using the specified encoding, and
             and the specified ReadProgress event handler.
             </summary>
            
             <remarks>
             <para>
             Reading of zip content begins at the current position in the stream.  This
             means if you have a stream that concatenates regular data and zip data, if
             you position the open, readable stream at the start of the zip data, you
             will be able to read the zip archive using this constructor, or any of the
             ZipFile constructors that accept a <see cref="T:System.IO.Stream"/> as
             input. Some examples of where this might be useful: the zip content is
             concatenated at the end of a regular EXE file, as some self-extracting
             archives do.  (Note: SFX files produced by DotNetZip do not work this
             way). Another example might be a stream being read from a database, where
             the zip content is embedded within an aggregate stream of data.
             </para>
             </remarks>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8
             encoding bit set.  Be careful specifying the encoding.  If the value you use
             here is not the same as the Encoding used when the zip archive was created
             (possibly by a different archiver) you will get unexpected results and
             possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
             property for more information.
             </param>
            
             <param name="readProgress">
             An event handler for Read operations.
             </param>
            
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.Text.Encoding)">
             <summary>
             Reads a zip archive from a stream, using the specified text Encoding and the
             specified TextWriter for status messages.
             </summary>
            
             <remarks>
             <para>
             This method is useful when when the zip archive content is available from an
             already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed.
             </para>
            
             <para>
             Reading of zip content begins at the current position in the stream.  This
             means if you have a stream that concatenates regular data and zip data, if
             you position the open, readable stream at the start of the zip data, you
             will be able to read the zip archive using this constructor, or any of the
             ZipFile constructors that accept a <see cref="T:System.IO.Stream"/> as
             input. Some examples of where this might be useful: the zip content is
             concatenated at the end of a regular EXE file, as some self-extracting
             archives do.  (Note: SFX files produced by DotNetZip do not work this
             way). Another example might be a stream being read from a database, where
             the zip content is embedded within an aggregate stream of data.
             </para>
            
             </remarks>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written
             during operations on the <c>ZipFile</c>.  For example, in a console
             application, System.Console.Out works, and will get a message for each entry
             added to the ZipFile.  If the TextWriter is <c>null</c>, no verbose messages
             are written.
             </param>
            
             <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8
             encoding bit set.  Be careful specifying the encoding.  If the value you use
             here is not the same as the Encoding used when the zip archive was created
             (possibly by a different archiver) you will get unexpected results and
             possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
             property for more information.
             </param>
            
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
             <summary>
             Reads a zip archive from a stream, using the specified text Encoding, the
             specified TextWriter for status messages,
             and the specified ReadProgress event handler.
             </summary>
            
             <remarks>
             <para>
             Reading of zip content begins at the current position in the stream.  This
             means if you have a stream that concatenates regular data and zip data, if
             you position the open, readable stream at the start of the zip data, you
             will be able to read the zip archive using this constructor, or any of the
             ZipFile constructors that accept a <see cref="T:System.IO.Stream"/> as
             input. Some examples of where this might be useful: the zip content is
             concatenated at the end of a regular EXE file, as some self-extracting
             archives do.  (Note: SFX files produced by DotNetZip do not work this
             way). Another example might be a stream being read from a database, where
             the zip content is embedded within an aggregate stream of data.
             </para>
             </remarks>
            
             <param name="zipStream">the stream containing the zip data.</param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written
             during operations on the <c>ZipFile</c>.  For example, in a console
             application, System.Console.Out works, and will get a message for each entry
             added to the ZipFile.  If the TextWriter is <c>null</c>, no verbose messages
             are written.
             </param>
            
             <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8
             encoding bit set.  Be careful specifying the encoding.  If the value you use
             here is not the same as the Encoding used when the zip archive was created
             (possibly by a different archiver) you will get unexpected results and
             possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
             property for more information.
             </param>
            
             <param name="readProgress">
             An event handler for Read operations.
             </param>
            
             <returns>an instance of ZipFile</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.Byte[])">
             <summary>
             Reads a zip archive from a byte array.
             </summary>
            
             <remarks>
             This is useful when the data for the zipfile is contained in a byte array,
             for example, downloaded from an FTP server without being saved to a
             filesystem.
             </remarks>
            
             <param name="buffer">
             The byte array containing the zip data.
             (I don't know why, but sometimes the compiled helpfile (.chm) indicates a 2d
             array when it is just one-dimensional.  This is a one-dimensional array.)
             </param>
            
             <returns>
             an instance of ZipFile. The name on the <c>ZipFile</c> will be <c>null</c>
             (<c>Nothing</c> in VB).
             </returns>
            
             <seealso cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.Byte[],System.IO.TextWriter)">
             <summary>
             Reads a zip archive from a byte array, using the given StatusMessageWriter.
             </summary>
            
             <remarks>
             <para>
             This method is useful when the data for the zipfile is contained in a byte
             array, for example when retrieving the data from a database or other
             non-filesystem store.  The default Text Encoding (IBM437) is used to read
             the zipfile data.
             </para>
            
             </remarks>
            
             <param name="buffer">the byte array containing the zip data.</param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written
             during operations on the <c>ZipFile</c>.  For example, in a console
             application, System.Console.Out works, and will get a message for each entry
             added to the ZipFile.  If the TextWriter is <c>null</c>, no verbose messages
             are written.
             </param>
            
             <returns>
             an instance of ZipFile. The name is set to <c>null</c> (<c>Nothing</c> in VB).
             </returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Read(System.Byte[],System.IO.TextWriter,System.Text.Encoding)">
             <summary>
             Reads a zip archive from a byte array, using the given StatusMessageWriter and text Encoding.
             </summary>
            
             <remarks>
             <para>
             This method is useful when the data for the zipfile is contained in a byte
             array, for example when retrieving the data from a database or other
             non-filesystem store.
             </para>
            
             </remarks>
            
             <param name="buffer">the byte array containing the zip data.</param>
            
             <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written
             during operations on the <c>ZipFile</c>.  For example, in a console
             application, System.Console.Out works, and will get a message for each entry
             added to the ZipFile.  If the TextWriter is <c>null</c>, no verbose messages
             are written.
             </param>
            
             <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8
             encoding bit set.  Be careful specifying the encoding.  If the value you use
             here is not the same as the Encoding used when the zip archive was created
             (possibly by a different archiver) you will get unexpected results and
             possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
             property for more information.
             </param>
            
             <returns>
             an instance of ZipFile. The name is set to <c>null</c> (<c>Nothing</c> in VB).
             </returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.String)">
             <summary>
             Checks the given file to see if it appears to be a valid zip file.
             </summary>
             <remarks>
            
             <para>
               Calling this method is equivalent to calling <see cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)"/> with the testExtract parameter set to false.
             </para>
             </remarks>
            
             <param name="fileName">The file to check.</param>
             <returns>true if the file appears to be a zip file.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)">
             <summary>
             Checks a file to see if it is a valid zip file.
             </summary>
            
             <remarks>
             <para>
               This method opens the specified zip file, reads in the zip archive,
               verifying the ZIP metadata as it reads.
             </para>
            
             <para>
               If everything succeeds, then the method returns true.  If anything fails -
               for example if an incorrect signature or CRC is found, indicating a
               corrupt file, the the method returns false.  This method also returns
               false for a file that does not exist.
             </para>
            
             <para>
               If <paramref name="testExtract"/> is true, as part of its check, this
               method reads in the content for each entry, expands it, and checks CRCs.
               This provides an additional check beyond verifying the zip header and
               directory data.
             </para>
            
             <para>
               If <paramref name="testExtract"/> is true, and if any of the zip entries
               are protected with a password, this method will return false.  If you want
               to verify a <c>ZipFile</c> that has entries which are protected with a
               password, you will need to do that manually.
             </para>
            
             </remarks>
            
             <param name="fileName">The zip file to check.</param>
             <param name="testExtract">true if the caller wants to extract each entry.</param>
             <returns>true if the file contains a valid zip file.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.IO.Stream,System.Boolean)">
             <summary>
             Checks a stream to see if it contains a valid zip archive.
             </summary>
            
             <remarks>
             <para>
             This method reads the zip archive contained in the specified stream, verifying
             the ZIP metadata as it reads.  If testExtract is true, this method also extracts
             each entry in the archive, dumping all the bits into <see cref="F:System.IO.Stream.Null"/>.
             </para>
            
             <para>
             If everything succeeds, then the method returns true.  If anything fails -
             for example if an incorrect signature or CRC is found, indicating a corrupt
             file, the the method returns false.  This method also returns false for a
             file that does not exist.
             </para>
            
             <para>
             If <c>testExtract</c> is true, this method reads in the content for each
             entry, expands it, and checks CRCs.  This provides an additional check
             beyond verifying the zip header data.
             </para>
            
             <para>
             If <c>testExtract</c> is true, and if any of the zip entries are protected
             with a password, this method will return false.  If you want to verify a
             ZipFile that has entries which are protected with a password, you will need
             to do that manually.
             </para>
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)"/>
            
             <param name="stream">The stream to check.</param>
             <param name="testExtract">true if the caller wants to extract each entry.</param>
             <returns>true if the stream contains a valid zip archive.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Save">
             <summary>
             Saves the Zip archive to a file, specified by the Name property of the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
             The <c>ZipFile</c> instance is written to storage, typically a zip file in a
             filesystem, only when the caller calls <c>Save</c>.  The Save operation writes
             the zip content to a temporary file, and then renames the temporary file
             to the desired name. If necessary, this method will delete a pre-existing file
             before the rename.
             </para>
            
             <para> The <see cref="P:Ionic.Zip.ZipFile.Name"/> property is specified either
             explicitly, or implicitly using one of the parameterized ZipFile
             constructors.  For COM Automation clients, the <c>Name</c> property must be
             set explicitly, because COM Automation clients cannot call parameterized
             constructors.  </para>
            
             <para>
             When using a filesystem file for the Zip output, it is possible to call
             <c>Save</c> multiple times on the <c>ZipFile</c> instance. With each call the zip
             content is re-written to the same output file.
             </para>
            
             <para>
             Data for entries that have been added to the <c>ZipFile</c> instance is written
             to the output when the <c>Save</c> method is called. This means that the input
             streams for those entries must be available at the time the application calls
             <c>Save</c>.  If, for example, the application adds entries with <c>AddEntry</c>
             using a dynamically-allocated <c>MemoryStream</c>, the memory stream must not
             have been disposed before the call to <c>Save</c>. See the <see cref="P:Ionic.Zip.ZipEntry.InputStream"/> property for more discussion of the availability
             requirements of the input stream for an entry, and an approach for providing
             just-in-time stream lifecycle management.
             </para>
            
             </remarks>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/>
            
             <exception cref="T:Ionic.Zip.BadStateException">
             Thrown if you haven't specified a location or stream for saving the zip,
             either in the constructor or by setting the Name property, or if you try to
             save a regular zip archive to a filename with a .exe extension.
             </exception>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.Save(System.String)">
             <summary>
             Save the file to a new zipfile, with the given name.
             </summary>
            
             <remarks>
             <para>
             This method allows the application to explicitly specify the name of the zip
             file when saving. Use this when creating a new zip file, or when
             updating a zip archive.
             </para>
            
             <para>
             An application can also save a zip archive in several places by calling this
             method multiple times in succession, with different filenames.
             </para>
            
             <para>
             The <c>ZipFile</c> instance is written to storage, typically a zip file in a
             filesystem, only when the caller calls <c>Save</c>.  The Save operation writes
             the zip content to a temporary file, and then renames the temporary file
             to the desired name. If necessary, this method will delete a pre-existing file
             before the rename.
             </para>
            
             </remarks>
            
             <exception cref="T:System.ArgumentException">
             Thrown if you specify a directory for the filename.
             </exception>
            
             <param name="fileName">
             The name of the zip archive to save to. Existing files will
             be overwritten with great prejudice.
             </param>
            
             <example>
             This example shows how to create and Save a zip file.
             <code>
             using (ZipFile zip = new ZipFile())
             {
               zip.AddDirectory(@"c:\reports\January");
               zip.Save("January.zip");
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile()
               zip.AddDirectory("c:\reports\January")
               zip.Save("January.zip")
             End Using
             </code>
            
             </example>
            
             <example>
             This example shows how to update a zip file.
             <code>
             using (ZipFile zip = ZipFile.Read("ExistingArchive.zip"))
             {
               zip.AddFile("NewData.csv");
               zip.Save("UpdatedArchive.zip");
             }
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read("ExistingArchive.zip")
               zip.AddFile("NewData.csv")
               zip.Save("UpdatedArchive.zip")
             End Using
             </code>
            
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipFile.Save(System.IO.Stream)">
             <summary>
               Save the zip archive to the specified stream.
             </summary>
            
             <remarks>
             <para>
               The <c>ZipFile</c> instance is written to storage - typically a zip file
               in a filesystem, but using this overload, the storage can be anything
               accessible via a writable stream - only when the caller calls <c>Save</c>.
             </para>
            
             <para>
               Use this method to save the zip content to a stream directly.  A common
               scenario is an ASP.NET application that dynamically generates a zip file
               and allows the browser to download it. The application can call
               <c>Save(Response.OutputStream)</c> to write a zipfile directly to the
               output stream, without creating a zip file on the disk on the ASP.NET
               server.
             </para>
            
             <para>
               Be careful when saving a file to a non-seekable stream, including
               <c>Response.OutputStream</c>. When DotNetZip writes to a non-seekable
               stream, the zip archive is formatted in such a way that may not be
               compatible with all zip tools on all platforms.  It's a perfectly legal
               and compliant zip file, but some people have reported problems opening
               files produced this way using the Mac OS archive utility.
             </para>
            
             </remarks>
            
             <example>
            
               This example saves the zipfile content into a MemoryStream, and
               then gets the array of bytes from that MemoryStream.
            
             <code lang="C#">
             using (var zip = new Ionic.Zip.ZipFile())
             {
                 zip.CompressionLevel= Ionic.Zlib.CompressionLevel.BestCompression;
                 zip.Password = "VerySecret.";
                 zip.Encryption = EncryptionAlgorithm.WinZipAes128;
                 zip.AddFile(sourceFileName);
                 MemoryStream output = new MemoryStream();
                 zip.Save(output);
            
                 byte[] zipbytes = output.ToArray();
             }
             </code>
             </example>
            
             <param name="outputStream">
               The <c>System.IO.Stream</c> to write to. It must be writable.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)">
             <summary>
             Adds to the ZipFile a set of files from the disk that conform to the
             specified criteria.
             </summary>
            
             <remarks>
             <para>
               This method selects files from the the current working directory matching
               the specified criteria, and adds them to the ZipFile.  The selection does
               not recurse into subdirectories.
             </para>
            
             <para>
               Specify the criteria in statements of 3 elements: a noun, an operator, and
               a value.  Consider the string "name != *.doc" .  The noun is "name".  The
               operator is "!=", implying "Not Equal".  The value is "*.doc".  That
               criterion, in English, says "all files with a name that does not end in
               the .doc extension."
             </para>
            
             <para>
               Supported nouns include "name" for the filename; "atime", "mtime", and
               "ctime" for last access time, last modfied time, and created time of the
               file, respectively; "attributes" for the file attributes; and "size" for
               the file length (uncompressed).  The "attributes" and "name" nouns both
               support = and != as operators.  The "size", "atime", "mtime", and "ctime"
               nouns support = and !=, and &gt;, &gt;=, &lt;, &lt;= as well. The times
               are taken to be expressed in "local time".
             </para>
            
             <para>
               Specify values for the file attributes as a string with one or more of the
               characters H,R,S,A in any order, implying Hidden, ReadOnly, System, and
               Archive, respectively.  To specify a time, use YYYY-MM-DD-HH:mm:ss as the
               format.  If you omit the HH:mm:ss portion, it is assumed to be 00:00:00
               (midnight). The value for a size criterion is expressed in integer
               quantities of bytes, kilobytes (use k or kb after the number), megabytes
               (m or mb), or gigabytes (g or gb).  The value for a name is a pattern to
               match against the filename, potentially including wildcards.  The pattern
               follows CMD.exe glob rules: * implies one or more of any character (not
               including dot), while ? implies one character (not including dot).  If the
               name pattern contains any slashes, it is matched to the entire filename,
               including the path; otherwise, it is matched against only the filename
               without the path.  This means a pattern of "*\*.*" matches all files one
               directory level deep, while a pattern of "*.*" matches all files in all
               directories.
             </para>
            
             <para>
               To specify a name pattern that includes spaces, use single quotes around
               the pattern.  A pattern of "'* *.*'" will match all files that have spaces
               in the filename.  The full criteria string for that would be "name = '*
               *.*'" .
             </para>
            
            
             <para>
             Some examples:
             </para>
            
             <list type="table">
               <listheader>
                 <term>criteria</term>
                 <description>Files retrieved</description>
               </listheader>
            
               <item>
                 <term>name != *.xls </term>
                 <description>any file with an extension that is not .xls
                 </description>
               </item>
            
               <item>
                 <term>name = *.mp3 </term>
                 <description>any file with a .mp3 extension.
                 </description>
               </item>
            
               <item>
                 <term>*.mp3</term>
                 <description>(same as above) any file with a .mp3 extension.
                 </description>
               </item>
            
               <item>
                 <term>attributes = A </term>
                 <description>all files whose attributes include the Archive bit.
                 </description>
               </item>
            
               <item>
                 <term>attributes != H </term>
                 <description>all files whose attributes do not include the Hidden bit.
                 </description>
               </item>
            
               <item>
                 <term>mtime > 2009-01-01</term>
                 <description>all files with a last modified time after January 1st, 2009.
                 </description>
               </item>
            
               <item>
                 <term>size > 2gb</term>
                 <description>all files whose uncompressed size is greater than 2gb.
                 </description>
               </item>
            
             </list>
            
             <para>
             You can combine criteria with the conjunctions AND or OR. Using a string like "name
             = *.txt AND size &gt;= 100k" for the selectionCriteria retrieves entries whose names
             end in  .txt, and whose uncompressed size is greater than or equal to
             100 kilobytes.
             </para>
            
             <para>
             For more complex combinations of criteria, you can use parenthesis to group clauses
             in the boolean logic.  Without parenthesis, the precedence of the criterion atoms is
             determined by order of appearance.  Unlike the C# language, the AND conjunction does
             not take precendence over the logical OR.  This is important only in strings that
             contain 3 or more criterion atoms.  In other words, "name = *.txt and size &gt; 1000
             or attributes = H" implies "((name = *.txt AND size &gt; 1000) OR attributes = H)"
             while "attributes = H OR name = *.txt and size &gt; 1000" evaluates to "((attributes
             = H OR name = *.txt) AND size &gt; 1000)".  When in doubt, use parenthesis.
             </para>
            
             <para>
             Using time properties requires some extra care. If you want to retrieve all entries
             that were last updated on 2009 February 14, specify a time range like so:"mtime
             &gt;= 2009-02-14 AND mtime &lt; 2009-02-15".  Read this to say: all files updated
             after 12:00am on February 14th, until 12:00am on February 15th.  You can use the
             same bracketing approach to specify any time period - a year, a month, a week, and
             so on.
             </para>
            
             <para>
             The syntax allows one special case: if you provide a string with no spaces, it is
             treated as a pattern to match for the filename.  Therefore a string like "*.xls"
             will be equivalent to specifying "name = *.xls".
             </para>
            
             <para>
             There is no logic in this method that insures that the file inclusion criteria are
             internally consistent.  For example, it's possible to specify criteria that says
             the file must have a size of less than 100 bytes, as well as a size that is
             greater than 1000 bytes. Obviously no file will ever satisfy such criteria, but
             this method does not detect such logical inconsistencies. The caller is
             responsible for insuring the criteria are sensible.
             </para>
            
             </remarks>
            
             <example>
             This example zips up all *.csv files in the current working directory.
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // To just match on filename wildcards,
                 // use the shorthand form of the selectionCriteria string.
                 zip.AddSelectedFiles("*.csv");
                 zip.Save(PathToZipArchive);
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 zip.AddSelectedFiles("*.csv")
                 zip.Save(PathToZipArchive)
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">The criteria for file selection</param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.Boolean)">
             <summary>
             Adds to the ZipFile a set of files from the disk that conform to the specified criteria.
             </summary>
            
             <remarks>
             <para>
             This method selects files from the the current working directory matching the specified
             criteria, and adds them to the ZipFile.  If <c>recurseDirectories</c> is true, files are also
             selected from subdirectories, and the directory structure in the filesystem is reproduced
             in the zip archive, rooted at the directory specified by <c>directoryOnDisk</c>.
             </para>
            
             <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
             </remarks>
            
             <example>
             This example zips up all *.xml files in the current working directory, or any
             subdirectory, that are larger than 1mb.
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", true);
                 zip.Save(PathToZipArchive);
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 ' Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", true)
                 zip.Save(PathToZipArchive)
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">The criteria for file selection</param>
            
             <param name="recurseDirectories">
             If true, the file selection will recurse into subdirectories.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)">
             <summary>
             Adds to the ZipFile a set of files from the disk that conform to the specified criteria.
             </summary>
            
             <remarks>
             This method selects files from the the specified disk directory matching the specified
             criteria, and adds them to the ZipFile.  The search does not recurse into
             subdirectores.  For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </remarks>
            
             <example>
             This example zips up all *.xml files larger than 1mb in the directory given by "d:\rawdata".
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", "d:\\rawdata");
                 zip.Save(PathToZipArchive);
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 ' Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", "d:\rawdata)
                 zip.Save(PathToZipArchive)
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">The criteria for file selection</param>
            
             <param name="directoryOnDisk">
             The name of the directory on the disk from which to select files.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.Boolean)">
             <summary>
             Adds to the ZipFile a set of files from the disk that conform to the specified criteria.
             </summary>
            
             <remarks>
             This method selects files from the the specified disk directory matching the specified
             selection criteria, and adds them to the ZipFile.  If <c>recurseDirectories</c> is true,
             files are also selected from subdirectories, and the directory structure in the
             filesystem is reproduced in the zip archive, rooted at the directory specified by
             <c>directoryOnDisk</c>. For details on the syntax for the selectionCriteria parameter,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </remarks>
            
             <example>
             This example zips up all *.csv files in the "files" directory, or any subdirectory, that
             have been saved since 2009 February 14th.
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.csv  and  mtime &gt; 2009-02-14", "files", true);
                 zip.Save(PathToZipArchive);
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 ' Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.csv  and  mtime &gt; 2009-02-14", "files", true)
                 zip.Save(PathToZipArchive)
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">The criteria for file selection</param>
            
             <param name="directoryOnDisk">
             The name of the directory on the disk from which to select files.
             </param>
            
             <param name="recurseDirectories">
             If true, the file selection will recurse into subdirectories.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.String)">
             <summary>
             Adds to the ZipFile a selection of files from the disk that conform to the
             specified criteria.
             </summary>
            
             <remarks>
             This method selects files from the specified disk directory matching the specified
             selection criteria, and adds those files to the ZipFile, using the specified directory
             path in the archive.  The search does not recurse into subdirectories.  For details on
             the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </remarks>
            
             <example>
             This example zips up all *.psd files in the "photos" directory that have been saved
             since 2009 February 14th, and puts them all in a zip file, using the directory name of
             "content" in the zip archive itself. When the zip archive is unzipped, the folder
             containing the .psd files will be named "content".
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.psd  and  mtime &gt; 2009-02-14", "photos", "content");
                 zip.Save(PathToZipArchive);
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = New ZipFile
                 zip.AddSelectedFiles("name = *.psd  and  mtime &gt; 2009-02-14", "photos", "content")
                 zip.Save(PathToZipArchive)
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">The criteria for selection of files to Add</param>
            
             <param name="directoryOnDisk">
             The name of the directory on the disk from which to select files.
             </param>
            
             <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the FileName.  This path may,
             or may not, correspond to a real directory in the current filesystem.  If the files
             within the zip are later extracted, this is the path used for the extracted file.
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the
             empty string ("") will insert the item at the root path within the archive.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.String,System.Boolean)">
             <summary>
             Adds to the ZipFile a selection of files from the disk that conform to the specified criteria.
             </summary>
            
             <remarks>
             This method selects files from the specified disk directory that match the specified
             selection criteria, and adds those files to the ZipFile, using the specified directory
             path in the archive. If <c>recurseDirectories</c> is true, files are also selected from
             subdirectories, and the directory structure in the filesystem is reproduced in the zip
             archive, rooted at the directory specified by <c>directoryOnDisk</c>.  For details on the
             syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </remarks>
            
             <example>
             This example zips up all files that are NOT *.pst files, in the current working
             directory and any subdirectories.
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddSelectedFiles("name != *.pst", SourceDirectory, "backup", true);
                 zip.Save(PathToZipArchive);
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = New ZipFile
                 zip.AddSelectedFiles("name != *.pst", SourceDirectory, "backup", true)
                 zip.Save(PathToZipArchive)
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">The criteria for selection of files to Add</param>
            
             <param name="directoryOnDisk">
             The name of the directory on the disk from which to select files.
             </param>
            
             <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the FileName.  This path may,
             or may not, correspond to a real directory in the current filesystem.  If the files
             within the zip are later extracted, this is the path used for the extracted file.
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the
             empty string ("") will insert the item at the root path within the archive.
             </param>
            
             <param name="recurseDirectories">
             If true, the method also scans subdirectories for files matching the criteria.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.UpdateSelectedFiles(System.String,System.String,System.String,System.Boolean)">
             <summary>
             Updates the ZipFile with a selection of files from the disk that conform to
             the specified criteria.
             </summary>
            
             <remarks>
             This method selects files from the specified disk directory that match the
             specified selection criteria, and Updates the <c>ZipFile</c> with those
             files, using the specified directory path in the archive. If
             <c>recurseDirectories</c> is true, files are also selected from
             subdirectories, and the directory structure in the filesystem is reproduced
             in the zip archive, rooted at the directory specified by
             <c>directoryOnDisk</c>.  For details on the syntax for the selectionCriteria
             parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </remarks>
            
             <param name="selectionCriteria">The criteria for selection of files to Add</param>
            
             <param name="directoryOnDisk">
             The name of the directory on the disk from which to select files.
             </param>
            
             <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the FileName.  This path may,
             or may not, correspond to a real directory in the current filesystem.  If the files
             within the zip are later extracted, this is the path used for the extracted file.
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the
             empty string ("") will insert the item at the root path within the archive.
             </param>
            
             <param name="recurseDirectories">
             If true, the method also scans subdirectories for files matching the criteria.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.SelectEntries(System.String)">
             <summary>
             Retrieve entries from the zipfile by specified criteria.
             </summary>
            
             <remarks>
             <para>
             This method allows callers to retrieve the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
            
             <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
            
             <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            
             <example>
             This example selects all the PhotoShop files from within an archive, and extracts them
             to the current working directory.
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 var PhotoShopFiles = zip1.SelectEntries("*.psd");
                 foreach (ZipEntry psd in PhotoShopFiles)
                 {
                     psd.Extract();
                 }
             }
             </code>
             <code lang="VB">
             Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
                 Dim PhotoShopFiles as ICollection(Of ZipEntry)
                 PhotoShopFiles = zip1.SelectEntries("*.psd")
                 Dim psd As ZipEntry
                 For Each psd In PhotoShopFiles
                     psd.Extract
                 Next
             End Using
             </code>
             </example>
             <param name="selectionCriteria">the string that specifies which entries to select</param>
             <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.SelectEntries(System.String,System.String)">
             <summary>
             Retrieve entries from the zipfile by specified criteria.
             </summary>
            
             <remarks>
             <para>
             This method allows callers to retrieve the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
            
             <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
            
             <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            
             <example>
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 var UpdatedPhotoShopFiles = zip1.SelectEntries("*.psd", "UpdatedFiles");
                 foreach (ZipEntry e in UpdatedPhotoShopFiles)
                 {
                     // prompt for extract here
                     if (WantExtract(e.FileName))
                         e.Extract();
                 }
             }
             </code>
             <code lang="VB">
             Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
                 Dim UpdatedPhotoShopFiles As ICollection(Of ZipEntry) = zip1.SelectEntries("*.psd", "UpdatedFiles")
                 Dim e As ZipEntry
                 For Each e In UpdatedPhotoShopFiles
                     ' prompt for extract here
                     If Me.WantExtract(e.FileName) Then
                         e.Extract
                     End If
                 Next
             End Using
             </code>
             </example>
             <param name="selectionCriteria">the string that specifies which entries to select</param>
            
             <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            
             <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)">
             <summary>
             Remove entries from the zipfile by specified criteria.
             </summary>
            
             <remarks>
             <para>
             This method allows callers to remove the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
            
             <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
            
             <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            
             <example>
             This example removes all entries in a zip file that were modified prior to January 1st, 2008.
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 // remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01");
                 // don't forget to save the archive!
                 zip1.Save();
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipFileName)
                 ' remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01")
                 ' do not forget to save the archive!
                 zip1.Save
             End Using
             </code>
             </example>
             <param name="selectionCriteria">the string that specifies which entries to select</param>
             <returns>the number of entries removed</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String,System.String)">
             <summary>
             Remove entries from the zipfile by specified criteria, and within the specified
             path in the archive.
             </summary>
            
             <remarks>
             <para>
             This method allows callers to remove the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
            
             <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
            
             <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
             </remarks>
            
             <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
            
             <example>
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 // remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01", "documents");
                 // a call to ZipFile.Save will make the modifications permanent
                 zip1.Save();
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipFileName)
                 ' remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01", "documents")
                 ' a call to ZipFile.Save will make the modifications permanent
                 zip1.Save
             End Using
             </code>
             </example>
            
             <param name="selectionCriteria">the string that specifies which entries to select</param>
             <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
             <returns>the number of entries removed</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are extracted into the current working directory.
             </para>
            
             <para>
             If any of the files to be extracted already exist, then the action taken is as
             specified in the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/> property on the
             corresponding ZipEntry instance.  By default, the action taken in this case is to
             throw an exception.
             </para>
            
             <para>
             For information on the syntax of the selectionCriteria string,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
             </remarks>
            
             <example>
             This example shows how extract all XML files modified after 15 January 2009.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15");
             }
             </code>
             </example>
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are extracted into the current working directory. When extraction would would
             overwrite an existing filesystem file, the action taken is as specified in the
             <paramref name="extractExistingFile"/> parameter.
             </para>
            
             <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
             </remarks>
            
             <example>
             This example shows how extract all XML files modified after 15 January 2009,
             overwriting any existing files.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15",
                                          ExtractExistingFileAction.OverwriteSilently);
             }
             </code>
             </example>
            
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are selected from the specified directory within the archive, and then
             extracted into the current working directory.
             </para>
            
             <para>
             If any of the files to be extracted already exist, then the action taken is as
             specified in the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/> property on the
             corresponding ZipEntry instance.  By default, the action taken in this case is to
             throw an exception.
             </para>
            
             <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
             </remarks>
            
             <example>
             This example shows how extract all XML files modified after 15 January 2009,
             and writes them to the "unpack" directory.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15","unpack");
             }
             </code>
             </example>
            
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            
             <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String,Ionic.Zip.ExtractExistingFileAction)"/>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are extracted into the specified directory. If any of the files to be
             extracted already exist, an exception will be thrown.
             </para>
             <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
             </remarks>
            
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <param name="directoryInArchive">
             the directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            
             <param name="extractDirectory">
             the directory on the disk into which to extract. It will be created
             if it does not exist.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String,Ionic.Zip.ExtractExistingFileAction)">
             <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
            
             <remarks>
             <para>
             The entries are extracted into the specified directory. When extraction would would
             overwrite an existing filesystem file, the action taken is as specified in the
             <paramref name="extractExistingFile"/> parameter.
             </para>
            
             <para>
             For information on the syntax of the string describing the entry selection criteria,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)"/>.
             </para>
             </remarks>
            
             <example>
             This example shows how extract all files  with an XML extension or with  a size larger than 100,000 bytes,
             and puts them in the unpack directory.  For any files that already exist in
             that destination directory, they will not be overwritten.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  or  size &gt; 100000",
                                          null,
                                          "unpack",
                                          ExtractExistingFileAction.DontOverwrite);
             }
             </code>
             </example>
            
             <param name="selectionCriteria">the selection criteria for entries to extract.</param>
            
             <param name="extractDirectory">
             The directory on the disk into which to extract. It will be created if it does not exist.
             </param>
            
             <param name="directoryPathInArchive">
             The directory in the archive from which to select entries. If null, then
             all directories in the archive are used.
             </param>
            
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
            
        </member>
        <member name="M:Ionic.Zip.ZipFile.GetEnumerator">
             <summary>
             Generic IEnumerator support, for use of a ZipFile in an enumeration.
             </summary>
            
             <remarks>
             You probably do not want to call <c>GetEnumerator</c> explicitly. Instead
             it is implicitly called when you use a <see langword="foreach"/> loop in C#, or a
             <c>For Each</c> loop in VB.NET.
             </remarks>
            
             <example>
             This example reads a zipfile of a given name, then enumerates the
             entries in that zip file, and displays the information about each
             entry on the Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               bool header = true;
               foreach (ZipEntry e in zip)
               {
                 if (header)
                 {
                    System.Console.WriteLine("Zipfile: {0}", zip.Name);
                    System.Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded);
                    System.Console.WriteLine("BitField: 0x{0:X2}", e.BitField);
                    System.Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod);
                    System.Console.WriteLine("\n{1,-22} {2,-6} {3,4}   {4,-8}  {0}",
                                 "Filename", "Modified", "Size", "Ratio", "Packed");
                    System.Console.WriteLine(new System.String('-', 72));
                    header = false;
                 }
            
                 System.Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}",
                             e.FileName,
                             e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                             e.UncompressedSize,
                             e.CompressionRatio,
                             e.CompressedSize);
            
                 e.Extract();
               }
             }
             </code>
            
             <code lang="VB">
               Dim ZipFileToExtract As String = "c:\foo.zip"
               Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                   Dim header As Boolean = True
                   Dim e As ZipEntry
                   For Each e In zip
                       If header Then
                           Console.WriteLine("Zipfile: {0}", zip.Name)
                           Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded)
                           Console.WriteLine("BitField: 0x{0:X2}", e.BitField)
                           Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod)
                           Console.WriteLine(ChrW(10) &amp; "{1,-22} {2,-6} {3,4}   {4,-8}  {0}", _
                             "Filename", "Modified", "Size", "Ratio", "Packed" )
                           Console.WriteLine(New String("-"c, 72))
                           header = False
                       End If
                       Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}", _
                         e.FileName, _
                         e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"), _
                         e.UncompressedSize, _
                         e.CompressionRatio, _
                         e.CompressedSize )
                       e.Extract
                   Next
               End Using
             </code>
             </example>
            
             <returns>A generic enumerator suitable for use  within a foreach loop.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipFile.GetNewEnum">
             <summary>
             An IEnumerator, for use of a ZipFile in a foreach construct.
             </summary>
            
             <remarks>
             This method is included for COM support.  An application generally does not call
             this method directly.  It is called implicitly by COM clients when enumerating
             the entries in the ZipFile instance.  In VBScript, this is done with a <c>For Each</c>
             statement.  In Javascript, this is done with <c>new Enumerator(zipfile)</c>.
             </remarks>
            
             <returns>
             The IEnumerator over the entries in the ZipFile.
             </returns>
        </member>
        <member name="P:Ionic.Zip.ZipFile.FullScan">
             <summary>
             Indicates whether to perform a full scan of the zip file when reading it.
             </summary>
            
             <remarks>
            
             <para>
               You almost never want to use this property.
             </para>
            
             <para>
               When reading a zip file, if this flag is <c>true</c> (<c>True</c> in
               VB), the entire zip archive will be scanned and searched for entries.
               For large archives, this can take a very, long time. The much more
               efficient default behavior is to read the zip directory, which is
               stored at the end of the zip file. But, in some cases the directory is
               corrupted and you need to perform a full scan of the zip file to
               determine the contents of the zip file. This property lets you do
               that, when necessary.
             </para>
            
             <para>
               This flag is effective only when calling <see cref="M:Ionic.Zip.ZipFile.Initialize(System.String)"/>. Normally you would read a ZipFile with the
               static <see cref="M:Ionic.Zip.ZipFile.Read(System.String)">ZipFile.Read</see>
               method. But you can't set the <c>FullScan</c> property on the
               <c>ZipFile</c> instance when you use a static factory method like
               <c>ZipFile.Read</c>.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to read a zip file using the full scan approach,
               and then save it, thereby producing a corrected zip file.
            
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.FullScan = true;
                 zip.Initialize(zipFileName);
                 zip.Save(newName);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 zip.FullScan = True
                 zip.Initialize(zipFileName)
                 zip.Save(newName)
             End Using
             </code>
             </example>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.SortEntriesBeforeSaving">
             <summary>
               Whether to sort the ZipEntries before saving the file.
             </summary>
            
             <remarks>
               The default is false.  If you have a large number of zip entries, the sort
               alone can consume significant time.
             </remarks>
            
             <example>
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.AddFiles(filesToAdd);
                 zip.SortEntriesBeforeSaving = true;
                 zip.Save(name);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 zip.AddFiles(filesToAdd)
                 zip.SortEntriesBeforeSaving = True
                 zip.Save(name)
             End Using
             </code>
             </example>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.AddDirectoryWillTraverseReparsePoints">
             <summary>
               Indicates whether NTFS Reparse Points, like junctions, should be
               traversed during calls to <c>AddDirectory()</c>.
             </summary>
            
             <remarks>
               By default, calls to AddDirectory() will traverse NTFS reparse
               points, like mounted volumes, and directory junctions.  An example
               of a junction is the "My Music" directory in Windows Vista.  In some
               cases you may not want DotNetZip to traverse those directories.  In
               that case, set this property to false.
             </remarks>
            
             <example>
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.AddDirectoryWillTraverseReparsePoints = false;
                 zip.AddDirectory(dirToZip,"fodder");
                 zip.Save(zipFileToCreate);
             }
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.BufferSize">
             <summary>
               Size of the IO buffer used while saving.
             </summary>
            
             <remarks>
            
             <para>
               First, let me say that you really don't need to bother with this.  It is
               here to allow for optimizations that you probably won't make! It will work
               fine if you don't set or get this property at all. Ok?
             </para>
            
             <para>
               Now that we have <em>that</em> out of the way, the fine print: This
               property affects the size of the buffer that is used for I/O for each
               entry contained in the zip file. When a file is read in to be compressed,
               it uses a buffer given by the size here.  When you update a zip file, the
               data for unmodified entries is copied from the first zip file to the
               other, through a buffer given by the size here.
             </para>
            
             <para>
               Changing the buffer size affects a few things: first, for larger buffer
               sizes, the memory used by the <c>ZipFile</c>, obviously, will be larger
               during I/O operations.  This may make operations faster for very much
               larger files.  Last, for any given entry, when you use a larger buffer
               there will be fewer progress events during I/O operations, because there's
               one progress event generated for each time the buffer is filled and then
               emptied.
             </para>
            
             <para>
               The default buffer size is 8k.  Increasing the buffer size may speed
               things up as you compress larger files.  But there are no hard-and-fast
               rules here, eh?  You won't know til you test it.  And there will be a
               limit where ever larger buffers actually slow things down.  So as I said
               in the beginning, it's probably best if you don't set or get this property
               at all.
             </para>
            
             </remarks>
            
             <example>
             This example shows how you might set a large buffer size for efficiency when
             dealing with zip entries that are larger than 1gb.
             <code lang="C#">
             using (ZipFile zip = new ZipFile())
             {
                 zip.SaveProgress += this.zip1_SaveProgress;
                 zip.AddDirectory(directoryToZip, "");
                 zip.UseZip64WhenSaving = Zip64Option.Always;
                 zip.BufferSize = 65536*8; // 65536 * 8 = 512k
                 zip.Save(ZipFileToCreate);
             }
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CodecBufferSize">
             <summary>
               Size of the work buffer to use for the ZLIB codec during compression.
             </summary>
            
             <remarks>
               Setting this affects the performance and memory efficiency of compression
               and decompression.  For larger files, setting this to a larger size may
               improve performance, but the exact numbers vary depending on available
               memory, and a bunch of other variables. I don't have good firm
               recommendations on how to set it.  You'll have to test it yourself. Or
               just leave it alone and accept the default.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.FlattenFoldersOnExtract">
             <summary>
               Indicates whether extracted files should keep their paths as
               stored in the zip archive.
             </summary>
            
             <remarks>
              <para>
                This property affects Extraction.  It is not used when creating zip
                archives.
              </para>
            
              <para>
                With this property set to <c>false</c>, the default, extracting entries
                from a zip file will create files in the filesystem that have the full
                path associated to the entry within the zip file.  With this property set
                to <c>true</c>, extracting entries from the zip file results in files
                with no path: the folders are "flattened."
              </para>
            
              <para>
                An example: suppose the zip file contains entries /directory1/file1.txt and
                /directory2/file2.txt.  With <c>FlattenFoldersOnExtract</c> set to false,
                the files created will be \directory1\file1.txt and \directory2\file2.txt.
                With the property set to true, the files created are file1.txt and file2.txt.
              </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Strategy">
             <summary>
               The compression strategy to use for all entries.
             </summary>
            
             <remarks>
               Set the Strategy used by the ZLIB-compatible compressor, when compressing
               entries. Different compression strategies work better on different sorts
               of data. The strategy parameter can affect the compression ratio and the
               speed of compression but not the correctness of the compresssion.  For
               more information see <see cref="T:Ionic.Zlib.CompressionStrategy">Ionic.Zlib.CompressionStrategy</see>.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Name">
             <summary>
               The name of the <c>ZipFile</c>, on disk.
             </summary>
            
             <remarks>
            
             <para>
               When the <c>ZipFile</c> instance was created by reading an archive using
               one of the <c>ZipFile.Read</c> methods, this property represents the name
               of the zip file that was read.  When the <c>ZipFile</c> instance was
               created by using the no-argument constructor, this value is <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
            
             <para>
               If you use the no-argument constructor, and you then explicitly set this
               property, when you call <see cref="M:Ionic.Zip.ZipFile.Save"/>, this name will
               specify the name of the zip file created.  Doing so is equivalent to
               calling <see cref="M:Ionic.Zip.ZipFile.Save(System.String)"/>.  When instantiating a
               <c>ZipFile</c> by reading from a stream or byte array, the <c>Name</c>
               property remains <c>null</c>.  When saving to a stream, the <c>Name</c>
               property is implicitly set to <c>null</c>.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CompressionLevel">
             <summary>
               Sets the compression level to be used for entries subsequently added to
               the zip archive.
             </summary>
            
             <remarks>
              <para>
                Varying the compression level used on entries can affect the
                size-vs-speed tradeoff when compression and decompressing data streams
                or files.
              </para>
            
              <para>
                As with some other properties on the <c>ZipFile</c> class, like <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, and <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>, setting this property on a <c>ZipFile</c>
                instance will cause the specified <c>CompressionLevel</c> to be used on all
                <see cref="T:Ionic.Zip.ZipEntry"/> items that are subsequently added to the
                <c>ZipFile</c> instance. If you set this property after you have added
                items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
                those items will not use the specified compression level.
              </para>
            
              <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Comment">
             <summary>
               A comment attached to the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               This property is read/write. It allows the application to specify a
               comment for the <c>ZipFile</c>, or read the comment for the
               <c>ZipFile</c>.  After setting this property, changes are only made
               permanent when you call a <c>Save()</c> method.
             </para>
            
             <para>
               According to <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see>, the comment is not encrypted, even if there is a
               password set on the zip file.
             </para>
            
             <para>
               The zip spec does not describe how to encode the comment string in a code
               page other than IBM437.  Therefore, for "compliant" zip tools and
               libraries, comments will use IBM437.  However, there are situations where
               you want an encoded Comment, for example using code page 950 "Big-5
               Chinese".  DotNetZip will encode the comment in the code page specified by
               <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, at the time of the call to
               <c>ZipFile.Save()</c>.
             </para>
            
             <para>
               When creating a zip archive using this library, it is possible to change
               the value of <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> between each
               entry you add, and between adding entries and the call to
               <c>Save()</c>. Don't do this.  It will likely result in a zip file that is
               not readable by any tool or application.  For best interoperability, leave
               <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> alone, or specify it only
               once, before adding any entries to the <c>ZipFile</c> instance.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving">
             <summary>
               Specifies whether the Creation, Access, and Modified times for entries
               added to the zip file will be emitted in "Windows format" when the zip
               archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entries should or should not be stored
               in the zip archive in the format used by Windows. By default this flag is
               <c>true</c>, meaning the Windows-format times are stored in the zip
               archive.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are
               automatically set from the filesystem values. When adding an entry from a
               stream or string, all three values are implicitly set to
               <c>DateTime.Now</c>.  Applications can also explicitly set those times by
               calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
             </para>
            
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since January 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since January 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455, although you probably don't need to know that.
             </para>
            
             <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe <see href="http://www.info-zip.org/">the Infozip
               tools</see> can read the Unix format timestamps. Some tools and libraries
               may be able to read only one or the other. DotNetZip can read or write
               times in either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               The value set here applies to all entries subsequently added to the
               <c>ZipFile</c>.
             </para>
            
             <para>
               This property is not mutually exclusive of the <see cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving"/> property. It is possible and
               legal and valid to produce a zip file that contains timestamps encoded in
               the Unix format as well as in the Windows format, in addition to the <see cref="P:Ionic.Zip.ZipEntry.LastModified">LastModified</see> time attached to each
               entry in the archive, a time that is always stored in "DOS format". And,
               notwithstanding the names PKWare uses for these time formats, any of them
               can be read and written by any computer, on any operating system.  But,
               there are no guarantees that a program running on Mac or Linux will
               gracefully handle a zip file with "Windows" formatted times, or that an
               application that does not use DotNetZip but runs on Windows will be able to
               handle file times in Unix format.
             </para>
            
             <para>
               When in doubt, test.  Sorry, I haven't got a complete list of tools and
               which sort of timestamps they can use and will tolerate.  If you get any
               good information and would like to pass it on, please do so and I will
               include that information in this documentation.
             </para>
             </remarks>
            
             <example>
               This example shows how to save a zip file that contains file timestamps
               in a format normally used by Unix.
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 // produce a zip file the Mac will like
                 zip.EmitTimesInWindowsFormatWhenSaving = false;
                 zip.EmitTimesInUnixFormatWhenSaving = true;
                 zip.AddDirectory(directoryToZip, "files");
                 zip.Save(outputFile);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 '' produce a zip file the Mac will like
                 zip.EmitTimesInWindowsFormatWhenSaving = False
                 zip.EmitTimesInUnixFormatWhenSaving = True
                 zip.AddDirectory(directoryToZip, "files")
                 zip.Save(outputFile)
             End Using
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving">
             <summary>
             Specifies whether the Creation, Access, and Modified times
             for entries added to the zip file will be emitted in "Unix(tm)
             format" when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entries should or should not be stored
               in the zip archive in the format used by Unix. By default this flag is
               <c>false</c>, meaning the Unix-format times are not stored in the zip
               archive.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified (<see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are
               automatically set from the filesystem values. When adding an entry from a
               stream or string, all three values are implicitly set to DateTime.Now.
               Applications can also explicitly set those times by calling <see cref="M:Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
             </para>
            
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since January 1, 1601 UTC.  The other is a format Unix applications
               typically use: seconds since January 1, 1970 UTC.  Each format can be
               stored in an "extra field" in the zip entry when saving the zip
               archive. The former uses an extra field with a Header Id of 0x000A, while
               the latter uses a header ID of 0x5455, although you probably don't need to
               know that.
             </para>
            
             <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Some tools and libraries may be
               able to read only one or the other.  DotNetZip can read or write times in
               either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:Ionic.Zip.ZipEntry.ModifiedTime"/>, <see cref="P:Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               This property is not mutually exclusive of the <see cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving"/> property. It is possible and
               legal and valid to produce a zip file that contains timestamps encoded in
               the Unix format as well as in the Windows format, in addition to the <see cref="P:Ionic.Zip.ZipEntry.LastModified">LastModified</see> time attached to each
               entry in the zip archive, a time that is always stored in "DOS
               format". And, notwithstanding the names PKWare uses for these time
               formats, any of them can be read and written by any computer, on any
               operating system.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle a zip file with "Windows" formatted
               times, or that an application that does not use DotNetZip but runs on
               Windows will be able to handle file times in Unix format.
             </para>
            
             <para>
               When in doubt, test.  Sorry, I haven't got a complete list of tools and
               which sort of timestamps they can use and will tolerate.  If you get any
               good information and would like to pass it on, please do so and I will
               include that information in this documentation.
             </para>
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Verbose">
             <summary>
               Indicates whether verbose output is sent to the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter"/> during <c>AddXxx()</c> and
               <c>ReadXxx()</c> operations.
             </summary>
            
             <remarks>
               This is a <em>synthetic</em> property.  It returns true if the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter"/> is non-null.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval">
             <summary>
               Indicates whether to perform case-sensitive matching on the filename when
               retrieving entries in the zipfile via the string-based indexer.
             </summary>
            
             <remarks>
               The default value is <c>false</c>, which means don't do case-sensitive
               matching. In other words, retrieving zip["ReadMe.Txt"] is the same as
               zip["readme.txt"].  It really makes sense to set this to <c>true</c> only
               if you are not running on Windows, which has case-insensitive
               filenames. But since this library is not built for non-Windows platforms,
               in most cases you should just leave this property alone.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.UseUnicodeAsNecessary">
             <summary>
               Indicates whether to encode entry filenames and entry comments using Unicode
               (UTF-8).
             </summary>
            
             <remarks>
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
               PKWare zip specification</see> provides for encoding file names and file
               comments in either the IBM437 code page, or in UTF-8.  This flag selects
               the encoding according to that specification.  By default, this flag is
               false, and filenames and comments are encoded into the zip file in the
               IBM437 codepage.  Setting this flag to true will specify that filenames
               and comments that cannot be encoded with IBM437 will be encoded with
               UTF-8.
             </para>
            
             <para>
               Zip files created with strict adherence to the PKWare specification with
               respect to UTF-8 encoding can contain entries with filenames containing
               any combination of Unicode characters, including the full range of
               characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other
               alphabets.  However, because at this time, the UTF-8 portion of the PKWare
               specification is not broadly supported by other zip libraries and
               utilities, such zip files may not be readable by your favorite zip tool or
               archiver. In other words, interoperability will decrease if you set this
               flag to true.
             </para>
            
             <para>
               In particular, Zip files created with strict adherence to the PKWare
               specification with respect to UTF-8 encoding will not work well with
               Explorer in Windows XP or Windows Vista, because Windows compressed
               folders, as far as I know, do not support UTF-8 in zip files.  Vista can
               read the zip files, but shows the filenames incorrectly. Unpacking from
               Windows Vista Explorer will result in filenames that have rubbish
               characters in place of the high-order UTF-8 bytes.
             </para>
            
             <para>
               Also, zip files that use UTF-8 encoding will not work well with Java
               applications that use the java.util.zip classes, as of v5.0 of the Java
               runtime. The Java runtime does not correctly implement the PKWare
               specification in this regard.
             </para>
            
             <para>
               As a result, we have the unfortunate situation that "correct" behavior by
               the DotNetZip library with regard to Unicode encoding of filenames during
               zip creation will result in zip files that are readable by strictly
               compliant and current tools (for example the most recent release of the
               commercial WinZip tool); but these zip files will not be readable by
               various other tools or libraries, including Windows Explorer.
             </para>
            
             <para>
               The DotNetZip library can read and write zip files with UTF8-encoded
               entries, according to the PKware spec.  If you use DotNetZip for both
               creating and reading the zip file, and you use UTF-8, there will be no
               loss of information in the filenames. For example, using a self-extractor
               created by this library will allow you to unpack files correctly with no
               loss of information in the filenames.
             </para>
            
             <para>
               If you do not set this flag, it will remain false.  If this flag is false,
               your <c>ZipFile</c> will encode all filenames and comments using the
               IBM437 codepage.  This can cause "loss of information" on some filenames,
               but the resulting zipfile will be more interoperable with other
               utilities. As an example of the loss of information, diacritics can be
               lost.  The o-tilde character will be down-coded to plain o.  The c with a
               cedilla (Unicode 0xE7) used in Portugese will be downcoded to a c.
               Likewise, the O-stroke character (Unicode 248), used in Danish and
               Norwegian, will be down-coded to plain o. Chinese characters cannot be
               represented in codepage IBM437; when using the default encoding, Chinese
               characters in filenames will be represented as ?. These are all examples
               of "information loss".
             </para>
            
             <para>
               The loss of information associated to the use of the IBM437 encoding is
               inconvenient, and can also lead to runtime errors. For example, using
               IBM437, any sequence of 4 Chinese characters will be encoded as ????.  If
               your application creates a <c>ZipFile</c>, then adds two files, each with
               names of four Chinese characters each, this will result in a duplicate
               filename exception.  In the case where you add a single file with a name
               containing four Chinese characters, calling Extract() on the entry that
               has question marks in the filename will result in an exception, because
               the question mark is not legal for use within filenames on Windows.  These
               are just a few examples of the problems associated to loss of information.
             </para>
            
             <para>
               This flag is independent of the encoding of the content within the entries
               in the zip file. Think of the zip file as a container - it supports an
               encoding.  Within the container are other "containers" - the file entries
               themselves.  The encoding within those entries is independent of the
               encoding of the zip archive container for those entries.
             </para>
            
             <para>
               Rather than specify the encoding in a binary fashion using this flag, an
               application can specify an arbitrary encoding via the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> property.  Setting the encoding
               explicitly when creating zip archives will result in non-compliant zip
               files that, curiously, are fairly interoperable.  The challenge is, the
               PKWare specification does not provide for a way to specify that an entry
               in a zip archive uses a code page that is neither IBM437 nor UTF-8.
               Therefore if you set the encoding explicitly when creating a zip archive,
               you must take care upon reading the zip archive to use the same code page.
               If you get it wrong, the behavior is undefined and may result in incorrect
               filenames, exceptions, stomach upset, hair loss, and acne.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.UseZip64WhenSaving">
             <summary>
               Specify whether to use ZIP64 extensions when saving a zip archive.
             </summary>
            
             <remarks>
            
             <para>
               When creating a zip file, the default value for the property is <see cref="F:Ionic.Zip.Zip64Option.Never"/>. <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> is
               safest, in the sense that you will not get an Exception if a pre-ZIP64
               limit is exceeded.
             </para>
            
             <para>
               You may set the property at any time before calling Save().
             </para>
            
             <para>
               When reading a zip file via the <c>Zipfile.Read()</c> method, DotNetZip
               will properly read ZIP64-endowed zip archives, regardless of the value of
               this property.  DotNetZip will always read ZIP64 archives.  This property
               governs only whether DotNetZip will write them. Therefore, when updating
               archives, be careful about setting this property after reading an archive
               that may use ZIP64 extensions.
             </para>
            
             <para>
               An interesting question is, if you have set this property to
               <c>AsNecessary</c>, and then successfully saved, does the resulting
               archive use ZIP64 extensions or not?  To learn this, check the <see cref="P:Ionic.Zip.ZipFile.OutputUsedZip64"/> property, after calling <c>Save()</c>.
             </para>
            
             <para>
               Have you thought about
               <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">donating</see>?
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.RequiresZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.RequiresZip64">
             <summary>
               Indicates whether the archive requires ZIP64 extensions.
             </summary>
            
             <remarks>
            
             <para>
               This property is <c>null</c> (or <c>Nothing</c> in VB) if the archive has
               not been saved, and there are fewer than 65334 <c>ZipEntry</c> items
               contained in the archive.
             </para>
            
             <para>
               The <c>Value</c> is true if any of the following four conditions holds:
               the uncompressed size of any entry is larger than 0xFFFFFFFF; the
               compressed size of any entry is larger than 0xFFFFFFFF; the relative
               offset of any entry within the zip archive is larger than 0xFFFFFFFF; or
               there are more than 65534 entries in the archive.  (0xFFFFFFFF =
               4,294,967,295).  The result may not be known until a <c>Save()</c> is attempted
               on the zip archive.  The Value of this <see cref="T:System.Nullable"/>
               property may be set only AFTER one of the Save() methods has been called.
             </para>
            
             <para>
               If none of the four conditions holds, and the archive has been saved, then
               the <c>Value</c> is false.
             </para>
            
             <para>
               A <c>Value</c> of false does not indicate that the zip archive, as saved,
               does not use ZIP64.  It merely indicates that ZIP64 is not required.  An
               archive may use ZIP64 even when not required if the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property is set to <see cref="F:Ionic.Zip.Zip64Option.Always"/>, or if the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property is set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> and the output stream was not
               seekable. Use the <see cref="P:Ionic.Zip.ZipFile.OutputUsedZip64"/> property to determine if
               the most recent <c>Save()</c> method resulted in an archive that utilized
               the ZIP64 extensions.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.OutputUsedZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.OutputUsedZip64">
             <summary>
               Indicates whether the most recent <c>Save()</c> operation used ZIP64 extensions.
             </summary>
            
             <remarks>
             <para>
               The use of ZIP64 extensions within an archive is not always necessary, and
               for interoperability concerns, it may be desired to NOT use ZIP64 if
               possible.  The <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property can be
               set to use ZIP64 extensions only when necessary.  In those cases,
               Sometimes applications want to know whether a Save() actually used ZIP64
               extensions.  Applications can query this read-only property to learn
               whether ZIP64 has been used in a just-saved <c>ZipFile</c>.
             </para>
            
             <para>
               The value is <c>null</c> (or <c>Nothing</c> in VB) if the archive has not
               been saved.
             </para>
            
             <para>
               Non-null values (<c>HasValue</c> is true) indicate whether ZIP64
               extensions were used during the most recent <c>Save()</c> operation.  The
               ZIP64 extensions may have been used as required by any particular entry
               because of its uncompressed or compressed size, or because the archive is
               larger than 4294967295 bytes, or because there are more than 65534 entries
               in the archive, or because the <c>UseZip64WhenSaving</c> property was set
               to <see cref="F:Ionic.Zip.Zip64Option.Always"/>, or because the
               <c>UseZip64WhenSaving</c> property was set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> and the output stream was not seekable.
               The value of this property does not indicate the reason the ZIP64
               extensions were used.
             </para>
            
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving"/>
             <seealso cref="P:Ionic.Zip.ZipFile.RequiresZip64"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.InputUsesZip64">
             <summary>
               Indicates whether the most recent <c>Read()</c> operation read a zip file that uses
               ZIP64 extensions.
             </summary>
            
             <remarks>
               This property will return null (Nothing in VB) if you've added an entry after reading
               the zip file.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">
             <summary>
               The text encoding to use when writing new entries to the <c>ZipFile</c>,
               for those entries that cannot be encoded with the default (IBM437)
               encoding; or, the text encoding that was used when reading the entries
               from the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
               zip specification</see>, PKWare describes two options for encoding
               filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
               or libraries do not follow the specification, and instead encode
               characters using the system default code page.  For example, WinRAR when
               run on a machine in Shanghai may encode filenames with the Big-5 Chinese
               (950) code page.  This behavior is contrary to the Zip specification, but
               it occurs anyway.
             </para>
            
             <para>
               When using DotNetZip to write zip archives that will be read by one of
               these other archivers, set this property to specify the code page to use
               when encoding the <see cref="P:Ionic.Zip.ZipEntry.FileName"/> and <see cref="P:Ionic.Zip.ZipEntry.Comment"/> for each <c>ZipEntry</c> in the zip file, for
               values that cannot be encoded with the default codepage for zip files,
               IBM437.  This is why this property is "provisional".  In all cases, IBM437
               is used where possible, in other words, where no loss of data would
               result. It is possible, therefore, to have a given entry with a
               <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with the
               specified "provisional" codepage.
             </para>
            
             <para>
               Be aware that a zip file created after you've explicitly set the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> property to a value other than
               IBM437 may not be compliant to the PKWare specification, and may not be
               readable by compliant archivers.  On the other hand, many (most?)
               archivers are non-compliant and can read zip files created in arbitrary
               code pages.  The trick is to use or specify the proper codepage when
               reading the zip.
             </para>
            
             <para>
               When creating a zip archive using this library, it is possible to change
               the value of <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> between each
               entry you add, and between adding entries and the call to
               <c>Save()</c>. Don't do this. It will likely result in a zipfile that is
               not readable.  For best interoperability, either leave <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> alone, or specify it only once,
               before adding any entries to the <c>ZipFile</c> instance.  There is one
               exception to this recommendation, described later.
             </para>
            
             <para>
               When using an arbitrary, non-UTF8 code page for encoding, there is no
               standard way for the creator application - whether DotNetZip, WinZip,
               WinRar, or something else - to formally specify in the zip file which
               codepage has been used for the entries. As a result, readers of zip files
               are not able to inspect the zip file and determine the codepage that was
               used for the entries contained within it.  It is left to the application
               or user to determine the necessary codepage when reading zip files encoded
               this way.  In other words, if you explicitly specify the codepage when you
               create the zipfile, you must explicitly specify the same codepage when
               reading the zipfile.
             </para>
            
             <para>
               The way you specify the code page to use when reading a zip file varies
               depending on the tool or library you use to read the zip.  In DotNetZip,
               you use a ZipFile.Read() method that accepts an encoding parameter.  It
               isn't possible with Windows Explorer, as far as I know, to specify an
               explicit codepage to use when reading a zip.  If you use an incorrect
               codepage when reading a zipfile, you will get entries with filenames that
               are incorrect, and the incorrect filenames may even contain characters
               that are not legal for use within filenames in Windows. Extracting entries
               with illegal characters in the filenames will lead to exceptions. It's too
               bad, but this is just the way things are with code pages in zip
               files. Caveat Emptor.
             </para>
            
             <para>
               Example: Suppose you create a zipfile that contains entries with
               filenames that have Danish characters.  If you use <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/> equal to "iso-8859-1" (cp 28591),
               the filenames will be correctly encoded in the zip.  But, to read that
               zipfile correctly, you have to specify the same codepage at the time you
               read it. If try to read that zip file with Windows Explorer or another
               application that is not flexible with respect to the codepage used to
               decode filenames in zipfiles, you will get a filename like "Inf°.txt".
             </para>
            
             <para>
               When using DotNetZip to read a zip archive, and the zip archive uses an
               arbitrary code page, you must specify the encoding to use before or when
               the <c>Zipfile</c> is READ.  This means you must use a <c>ZipFile.Read()</c>
               method that allows you to specify a System.Text.Encoding parameter.  Setting
               the ProvisionalAlternateEncoding property after your application has read in
               the zip archive will not affect the entry names of entries that have already
               been read in.
             </para>
            
             <para>
               And now, the exception to the rule described above.  One strategy for
               specifying the code page for a given zip file is to describe the code page
               in a human-readable form in the Zip comment. For example, the comment may
               read "Entries in this archive are encoded in the Big5 code page".  For
               maximum interoperability, the zip comment in this case should be encoded
               in the default, IBM437 code page.  In this case, the zip comment is
               encoded using a different page than the filenames.  To do this, Specify
               <c>ProvisionalAlternateEncoding</c> to your desired region-specific code
               page, once before adding any entries, and then reset
               <c>ProvisionalAlternateEncoding</c> to IBM437 before setting the <see cref="P:Ionic.Zip.ZipFile.Comment"/> property and calling Save().
             </para>
             </remarks>
            
             <example>
             This example shows how to read a zip file using the Big-5 Chinese code page
             (950), and extract each entry in the zip file.  For this code to work as
             desired, the <c>Zipfile</c> must have been created using the big5 code page
             (CP950). This is typical, for example, when using WinRar on a machine with
             CP950 set as the default code page.  In that case, the names of entries
             within the Zip archive will be stored in that code page, and reading the zip
             archive must be done using that code page.  If the application did not use
             the correct code page in <c>ZipFile.Read()</c>, then names of entries within the
             zip archive would not be correctly retrieved.
             <code>
             using (var zip = ZipFile.Read(zipFileName, System.Text.Encoding.GetEncoding("big5")))
             {
                 // retrieve and extract an entry using a name encoded with CP950
                 zip[MyDesiredEntry].Extract("unpack");
             }
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipToExtract, System.Text.Encoding.GetEncoding("big5"))
                 ' retrieve and extract an entry using a name encoded with CP950
                 zip(MyDesiredEntry).Extract("unpack")
             End Using
             </code>
             </example>
            
             <seealso cref="F:Ionic.Zip.ZipFile.DefaultEncoding">DefaultEncoding</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.StatusMessageTextWriter">
             <summary>
             Gets or sets the <c>TextWriter</c> to which status messages are delivered
             for the instance.
             </summary>
            
             <remarks>
               If the TextWriter is set to a non-null value, then verbose output is sent
               to the <c>TextWriter</c> during <c>Add</c><c>, Read</c><c>, Save</c> and
               <c>Extract</c> operations.  Typically, console applications might use
               <c>Console.Out</c> and graphical or headless applications might use a
               <c>System.IO.StringWriter</c>. The output of this is suitable for viewing
               by humans.
             </remarks>
            
             <example>
             <para>
               In this example, a console application instantiates a <c>ZipFile</c>, then
               sets the <c>StatusMessageTextWriter</c> to <c>Console.Out</c>.  At that
               point, all verbose status messages for that <c>ZipFile</c> are sent to the
               console.
             </para>
            
             <code lang="C#">
             using (ZipFile zip= ZipFile.Read(FilePath))
             {
               zip.StatusMessageTextWriter= System.Console.Out;
               // messages are sent to the console during extraction
               zip.ExtractAll();
             }
             </code>
            
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(FilePath)
               zip.StatusMessageTextWriter= System.Console.Out
               'Status Messages will be sent to the console during extraction
               zip.ExtractAll()
             End Using
             </code>
            
             <para>
               In this example, a Windows Forms application instantiates a
               <c>ZipFile</c>, then sets the <c>StatusMessageTextWriter</c> to a
               <c>StringWriter</c>.  At that point, all verbose status messages for that
               <c>ZipFile</c> are sent to the <c>StringWriter</c>.
             </para>
            
             <code lang="C#">
             var sw = new System.IO.StringWriter();
             using (ZipFile zip= ZipFile.Read(FilePath))
             {
               zip.StatusMessageTextWriter= sw;
               zip.ExtractAll();
             }
             Console.WriteLine("{0}", sw.ToString());
             </code>
            
             <code lang="VB">
             Dim sw as New System.IO.StringWriter
             Using zip As ZipFile = ZipFile.Read(FilePath)
               zip.StatusMessageTextWriter= sw
               zip.ExtractAll()
             End Using
             'Status Messages are now available in sw
            
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipFile.TempFileFolder">
             <summary>
               Gets or sets the name for the folder to store the temporary file
               this library writes when saving a zip archive.
             </summary>
            
             <remarks>
             <para>
               This library will create a temporary file when saving a Zip archive to a
               file.  This file is written when calling one of the <c>Save()</c> methods
               that does not save to a stream, or one of the <c>SaveSelfExtractor()</c>
               methods.
             </para>
            
             <para>
               By default, the library will create the temporary file in the directory
               specified for the file itself, via the <see cref="P:Ionic.Zip.ZipFile.Name"/> property or via
               the <see cref="M:Ionic.Zip.ZipFile.Save(System.String)"/> method.
             </para>
            
             <para>
               Setting this property allows applications to override this default
               behavior, so that the library will create the temporary file in the
               specified folder. For example, to have the library create the temporary
               file in the current working directory, regardless where the <c>ZipFile</c>
               is saved, specfy ".".  To revert to the default behavior, set this
               property to <c>null</c> (<c>Nothing</c> in VB).
             </para>
            
             <para>
               When setting the property to a non-null value, the folder specified must
               exist; if it does not an exception is thrown.  The application should have
               write and delete permissions on the folder.  The permissions are not
               explicitly checked ahead of time; if the application does not have the
               appropriate rights, an exception will be thrown at the time <c>Save()</c>
               is called.
             </para>
            
             <para>
               There is no temporary file created when reading a zip archive.  When
               saving to a Stream, there is no temporary file created.  For example, if
               the application is an ASP.NET application and calls <c>Save()</c>
               specifying the <c>Response.OutputStream</c> as the output stream, there is
               no temporary file created.
             </para>
             </remarks>
            
             <exception cref="T:System.IO.FileNotFoundException">
             Thrown when setting the property if the directory does not exist.
             </exception>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.Password">
             <summary>
             Sets the password to be used on the <c>ZipFile</c> instance.
             </summary>
            
             <remarks>
            
             <para>
               When writing a zip archive, this password is applied to the entries, not
               to the zip archive itself. It applies to any <c>ZipEntry</c> subsequently
               added to the <c>ZipFile</c>, using one of the <c>AddFile</c>,
               <c>AddDirectory</c>, <c>AddEntry</c>, or <c>AddItem</c> methods, etc.
               When reading a zip archive, this property applies to any entry
               subsequently extracted from the <c>ZipFile</c> using one of the Extract
               methods on the <c>ZipFile</c> class.
             </para>
            
             <para>
               When writing a zip archive, keep this in mind: though the password is set
               on the ZipFile object, according to the Zip spec, the "directory" of the
               archive - in other words the list of entries or files contained in the archive - is
               not encrypted with the password, or protected in any way.  If you set the
               Password property, the password actually applies to individual entries
               that are added to the archive, subsequent to the setting of this property.
               The list of filenames in the archive that is eventually created will
               appear in clear text, but the contents of the individual files are
               encrypted.  This is how Zip encryption works.
             </para>
            
             <para>
               One simple way around this limitation is to simply double-wrap sensitive
               filenames: Store the files in a zip file, and then store that zip file
               within a second, "outer" zip file.  If you apply a password to the outer
               zip file, then readers will be able to see that the outer zip file
               contains an inner zip file.  But readers will not be able to read the
               directory or file list of the inner zip file.
             </para>
            
             <para>
               If you set the password on the <c>ZipFile</c>, and then add a set of files
               to the archive, then each entry is encrypted with that password.  You may
               also want to change the password between adding different entries. If you
               set the password, add an entry, then set the password to <c>null</c>
               (<c>Nothing</c> in VB), and add another entry, the first entry is
               encrypted and the second is not.  If you call <c>AddFile()</c>, then set
               the <c>Password</c> property, then call <c>ZipFile.Save</c>, the file
               added will not be password-protected, and no warning will be generated.
             </para>
            
             <para>
               When setting the Password, you may also want to explicitly set the <see cref="P:Ionic.Zip.ZipFile.Encryption"/> property, to specify how to encrypt the entries added
               to the ZipFile.  If you set the Password to a non-null value and do not
               set <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, then PKZip 2.0 ("Weak") encryption is used.
               This encryption is relatively weak but is very interoperable. If you set
               the password to a <c>null</c> value (<c>Nothing</c> in VB), Encryption is
               reset to None.
             </para>
            
             <para>
               All of the preceding applies to writing zip archives, in other words when
               you use one of the Save methods.  To use this property when reading or an
               existing ZipFile, do the following: set the Password property on the
               <c>ZipFile</c>, then call one of the Extract() overloads on the <see cref="T:Ionic.Zip.ZipEntry"/>. In this case, the entry is extracted using the
               <c>Password</c> that is specified on the <c>ZipFile</c> instance. If you
               have not set the <c>Password</c> property, then the password is
               <c>null</c>, and the entry is extracted with no password.
             </para>
            
             <para>
               If you set the Password property on the <c>ZipFile</c>, then call
               <c>Extract()</c> an entry that has not been encrypted with a password, the
               password is not used for that entry, and the <c>ZipEntry</c> is extracted
               as normal. In other words, the password is used only if necessary.
             </para>
            
             <para>
               The <see cref="T:Ionic.Zip.ZipEntry"/> class also has a <see cref="P:Ionic.Zip.ZipEntry.Password">Password</see> property.  It takes precedence
               over this property on the <c>ZipFile</c>.  Typically, you would use the
               per-entry Password when most entries in the zip archive use one password,
               and a few entries use a different password.  If all entries in the zip
               file use the same password, then it is simpler to just set this property
               on the <c>ZipFile</c> itself, whether creating a zip archive or extracting
               a zip archive.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example creates a zip file, using password protection for the
               entries, and then extracts the entries from the zip file.  When creating
               the zip file, the Readme.txt file is not protected with a password, but
               the other two are password-protected as they are saved. During extraction,
               each file is extracted with the appropriate password.
             </para>
             <code>
             // create a file with encryption
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt");
                 zip.Password= "!Secret1";
                 zip.AddFile("MapToTheSite-7440-N49th.png");
                 zip.AddFile("2008-Regional-Sales-Report.pdf");
                 zip.Save("EncryptedArchive.zip");
             }
            
             // extract entries that use encryption
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 zip.Password= "!Secret1";
                 zip.ExtractAll("extractDir");
             }
            
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 zip.AddFile("ReadMe.txt")
                 zip.Password = "123456!"
                 zip.AddFile("MapToTheSite-7440-N49th.png")
                 zip.Password= "!Secret1";
                 zip.AddFile("2008-Regional-Sales-Report.pdf")
                 zip.Save("EncryptedArchive.zip")
             End Using
            
            
             ' extract entries that use encryption
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 zip.Password= "!Secret1"
                 zip.ExtractAll("extractDir")
             End Using
            
             </code>
            
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Encryption">ZipFile.Encryption</seealso>
             <seealso cref="P:Ionic.Zip.ZipEntry.Password">ZipEntry.Password</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ExtractExistingFile">
             <summary>
               The action the library should take when extracting a file that already
               exists.
             </summary>
            
             <remarks>
             <para>
               This property affects the behavior of the Extract methods (one of the
               <c>Extract()</c> or <c>ExtractWithPassword()</c> overloads), when
               extraction would would overwrite an existing filesystem file. If you do
               not set this property, the library throws an exception when extracting an
               entry would overwrite an existing file.
             </para>
            
             <para>
               This property has no effect when extracting to a stream, or when the file
               to be extracted does not already exist.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ZipErrorAction">
             <summary>
               The action the library should take when an error is encountered while
               opening or reading files as they are saved into a zip archive.
             </summary>
            
             <remarks>
              <para>
                Errors can occur as a file is being saved to the zip archive.  For
                example, the File.Open may fail, or a File.Read may fail, because of
                lock conflicts or other reasons.
              </para>
            
              <para>
                The first problem might occur after having called AddDirectory() on a
                directory that contains a Clipper .dbf file; the file is locked by
                Clipper and cannot be opened for read by another process. An example of
                the second problem might occur when trying to zip a .pst file that is in
                use by Microsoft Outlook. Outlook locks a range on the file, which allows
                other processes to open the file, but not read it in its entirety.
              </para>
            
              <para>
                This property tells DotNetZip what you would like to do in the case of
                these errors.  The primary options are: <c>ZipErrorAction.Throw</c> to
                throw an exception (this is the default behavior if you don't set this
                property); <c>ZipErrorAction.Skip</c> to Skip the file for which there
                was an error and continue saving; <c>ZipErrorAction.Retry</c> to Retry
                the entry that caused the problem; or
                <c>ZipErrorAction.InvokeErrorEvent</c> to invoke an event handler.
              </para>
            
              <para>
                This property is implicitly set to <c>ZipErrorAction.InvokeErrorEvent</c>
                if you add a handler to the <see cref="E:Ionic.Zip.ZipFile.ZipError"/> event.  If you set
                this property to something other than
                <c>ZipErrorAction.InvokeErrorEvent</c>, then the <c>ZipError</c>
                event is implicitly cleared.  What it means is you can set one or the
                other (or neither), depending on what you want, but you never need to set
                both.
              </para>
            
              <para>
                As with some other properties on the <c>ZipFile</c> class, like <see cref="P:Ionic.Zip.ZipFile.Password"/>, <see cref="P:Ionic.Zip.ZipFile.Encryption"/>, and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, setting this property on a <c>ZipFile</c>
                instance will cause the specified <c>ZipErrorAction</c> to be used on all
                <see cref="T:Ionic.Zip.ZipEntry"/> items that are subsequently added to the
                <c>ZipFile</c> instance. If you set this property after you have added
                items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
                those items will not use the specified error handling action.
              </para>
            
              <para>
                If you want to handle any errors that occur with any entry in the zip
                file in the same way, then set this property once, before adding any
                entries to the zip archive.
              </para>
            
              <para>
                If you set this property to <c>ZipErrorAction.Skip</c> and you'd like to
                learn which files may have been skipped after a <c>Save()</c>, you can
                set the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter"/> on the ZipFile before
                calling <c>Save()</c>. A message will be emitted into that writer for
                each skipped file, if any.
              </para>
            
             </remarks>
            
             <example>
               This example shows how to tell DotNetZip to skip any files for which an
               error is generated during the Save().
             <code lang="VB">
             Public Sub SaveZipFile()
                 Dim SourceFolder As String = "fodder"
                 Dim DestFile As String =  "eHandler.zip"
                 Dim sw as New StringWriter
                 Using zipArchive As ZipFile = New ZipFile
                     ' Tell DotNetZip to skip any files for which it encounters an error
                     zipArchive.ZipErrorAction = ZipErrorAction.Skip
                     zipArchive.StatusMessageTextWriter = sw
                     zipArchive.AddDirectory(SourceFolder)
                     zipArchive.Save(DestFile)
                 End Using
                 ' examine sw here to see any messages
             End Sub
            
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipEntry.ZipErrorAction"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ZipError"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Encryption">
             <summary>
               The Encryption to use for entries added to the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               Set this when creating a zip archive, or when updating a zip archive. The
               specified Encryption is applied to the entries subsequently added to the
               <c>ZipFile</c> instance.  Applications do not need to set the
               <c>Encryption</c> property when reading or extracting a zip archive.
             </para>
            
             <para>
               If you set this to something other than EncryptionAlgorithm.None, you
               will also need to set the <see cref="P:Ionic.Zip.ZipFile.Password"/>.
             </para>
            
             <para>
               As with some other properties on the <c>ZipFile</c> class, like <see cref="P:Ionic.Zip.ZipFile.Password"/> and <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/>, setting this
               property on a <c>ZipFile</c> instance will cause the specified
               <c>EncryptionAlgorithm</c> to be used on all <see cref="T:Ionic.Zip.ZipEntry"/> items
               that are subsequently added to the <c>ZipFile</c> instance. In other
               words, if you set this property after you have added items to the
               <c>ZipFile</c>, but before you have called <c>Save()</c>, those items will
               not be encrypted or protected with a password in the resulting zip
               archive. To get a zip archive with encrypted entries, set this property,
               along with the <see cref="P:Ionic.Zip.ZipFile.Password"/> property, before calling
               <c>AddFile</c>, <c>AddItem</c>, or <c>AddDirectory</c> (etc.) on the
               <c>ZipFile</c> instance.
             </para>
            
             <para>
               If you read a <c>ZipFile</c>, you can modify the <c>Encryption</c> on an
               encrypted entry, only by setting the <c>Encryption</c> property on the
               <c>ZipEntry</c> itself.  Setting the <c>Encryption</c> property on the
               <c>ZipFile</c>, once it has been created via a call to
               <c>ZipFile.Read()</c>, does not affect entries that were previously read.
             </para>
            
             <para>
               For example, suppose you read a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the <c>Encryption</c> property on that <c>ZipFile</c> and
               then calling <c>Save()</c> on the <c>ZipFile</c> does not update the
               <c>Encryption</c> used for the entries in the archive.  Neither is an
               exception thrown. Instead, what happens during the <c>Save()</c> is that
               all previously existing entries are copied through to the new zip archive,
               with whatever encryption and password that was used when originally
               creating the zip archive. Upon re-reading that archive, to extract
               entries, applications should use the original password or passwords, if
               any.
             </para>
            
             <para>
               Suppose an application reads a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the <c>Encryption</c> property on that <c>ZipFile</c> and
               then adding new entries (via <c>AddFile()</c>, <c>AddEntry()</c>, etc)
               and then calling <c>Save()</c> on the <c>ZipFile</c> does not update the
               <c>Encryption</c> on any of the entries that had previously been in the
               <c>ZipFile</c>.  The <c>Encryption</c> property applies only to the
               newly-added entries.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example creates a zip archive that uses encryption, and then extracts
               entries from the archive.  When creating the zip archive, the ReadMe.txt
               file is zipped without using a password or encryption.  The other files
               use encryption.
             </para>
            
             <code>
             // Create a zip archive with AES Encryption.
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt");
                 zip.Encryption= EncryptionAlgorithm.WinZipAes256;
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.AddFile("7440-N49th.png");
                 zip.AddFile("2008-Regional-Sales-Report.pdf");
                 zip.Save("EncryptedArchive.zip");
             }
            
             // Extract a zip archive that uses AES Encryption.
             // You do not need to specify the algorithm during extraction.
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.ExtractAll("extractDirectory");
             }
             </code>
            
             <code lang="VB">
             ' Create a zip that uses Encryption.
             Using zip As New ZipFile()
                 zip.Encryption= EncryptionAlgorithm.WinZipAes256
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.AddFile("ReadMe.txt")
                 zip.AddFile("7440-N49th.png")
                 zip.AddFile("2008-Regional-Sales-Report.pdf")
                 zip.Save("EncryptedArchive.zip")
             End Using
            
             ' Extract a zip archive that uses AES Encryption.
             ' You do not need to specify the algorithm during extraction.
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.ExtractAll("extractDirectory")
             End Using
             </code>
            
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Password">ZipFile.Password</seealso>
             <seealso cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipFile.SetCompression">
             <summary>
               A callback that allows the application to specify the compression level
               to use for entries subsequently added to the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               With this callback, the DotNetZip library allows the application to
               determine whether compression will be used, at the time of the <c>Save</c>. This
               may be useful if the application wants to favor speed over size, and wants
               to defer the decision until the time of <c>Save</c>.
             </para>
            
             <para>
               Typically applications set the <see cref="P:Ionic.Zip.ZipFile.CompressionLevel"/> property on
               the <c>ZipFile</c> or on each <c>ZipEntry</c> to determine the level of
               compression used. This is done at the time the entry is added to the
               <c>ZipFile</c>. Setting the property to
               <c>Ionic.Zlib.CompressionLevel.None</c> means no compression will be used.
             </para>
            
             <para>
               This callback allows the application to defer the decision on the
               <c>CompressionLevel</c> to use, until the time of the call to
               <c>ZipFile.Save()</c>. The callback is invoked once per <c>ZipEntry</c>,
               at the time the data for the entry is being written out as part of a
               <c>Save()</c> operation. The application can use whatever criteria it
               likes in determining the level to return.  For example, an application may
               wish that no .mp3 files should be compressed, because they are already
               compressed and the extra compression is not worth the CPU time incurred,
               and so can return <c>None</c> for all .mp3 entries.
             </para>
            
             <para>
               The library determines whether compression will be attempted for an entry
               this way: If the entry is a zero length file, or a directory, no
               compression is used.  Otherwise, if this callback is set, it is invoked
               and the <c>CompressionLevel</c> is set to the return value. If this
               callback has not been set, then the previously set value for
               <c>CompressionLevel</c> is used.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize">
             <summary>
             The maximum size of an output segment, when saving a split Zip file.
             </summary>
             <remarks>
               <para>
                 Set this to a non-zero value before calling <see cref="M:Ionic.Zip.ZipFile.Save"/> or <see cref="M:Ionic.Zip.ZipFile.Save(System.String)"/> to specify that the ZipFile should be saved as a
                 split archive, also sometimes called a spanned archive. Some also
                 call them multi-file archives.
               </para>
            
               <para>
                 A split zip archive is saved in a set of discrete filesystem files,
                 rather than in a single file. This is handy when transmitting the
                 archive in email or some other mechanism that has file size limits.  The
                 first file in a split archive will be named <c>basename.z01</c>, the
                 second will be named <c>basename.z02</c>, and so on. The final file is
                 named <c>basename.zip</c>.
               </para>
            
               <para>
                 The value of this property determines the maximum size of a split
                 segment when writing a split archive.  According to the zip
                 specification from PKWare, the minimum value is 65536, for a 64k segment
                 size.  For example, suppose you have a <c>ZipFile</c> that would save to
                 a single file of 200k. If you set the <c>MaxOutputSegmentSize</c> to
                 65536 before calling <c>Save()</c>, you will get four distinct output
                 files. On the other hand if you set this property to 256k, then you will
                 get a single-file archive for that <c>ZipFile</c>.
               </para>
            
               <para>
                 The size of each split output file will often but not always be exactly
                 the maximum size set here. The zip specification requires that some data
                 fields in a zip archive may not span a split boundary. An output segment
                 may be not completely filled if necessary to avoid that problem. Also,
                 obviously the final segment of the archive may be smaller than the
                 maximum segment size.  Segments will never be larger than the value set
                 with this property.
               </para>
            
               <para>
                 You can save a split Zip file only when saving to a regular filesystem
                 file. It's not possible to save a split zip file as a self-extracting
                 archive, nor is it possible to save a split zip file to a stream. When
                 saving to a SFX or to a Stream, this property is ignored.
               </para>
            
               <para>
                 About interoperability: Split or spanned zip files produced by DotNetZip
                 can be read by WinZip or PKZip, and vice-versa. Segmented zip files may
                 not be readable by other tools, if those other tools don't support zip
                 spanning or splitting.  When in doubt, test.  I don't believe Windows
                 Explorer can extract a split archive.
               </para>
            
               <para>
                 This property has no effect when reading a split archive. You can read
                 a split archive in the normal way with DotNetZip.
               </para>
            
               <para>
                 When saving a zip file, if you want a regular zip file rather than a
                 split zip file, don't set this property, or set it to Zero.
               </para>
            
               <para>
                 If you read a split archive, with <see cref="M:Ionic.Zip.ZipFile.Read(System.String)"/> and
                 then subsequently call <c>ZipFile.Save()</c>, unless you set this
                 property before calling <c>Save()</c>, you will get a normal,
                 single-file archive.
               </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.NumberOfSegmentsForMostRecentSave"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.NumberOfSegmentsForMostRecentSave">
            <summary>
              Returns the number of segments used in the most recent Save() operation.
            </summary>
            <remarks>
              <para>
                This is normally zero, unless you have set the <see cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize"/> property.  If you have set <see cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize"/>, and then you save a file, after the call to
                Save() completes, you can read this value to learn the number of segments that
                were created.
              </para>
              <para>
                If you call Save("Archive.zip"), and it creates 5 segments, then you
                will have filesystem files named Archive.z01, Archive.z02, Archive.z03,
                Archive.z04, and Archive.zip, and the value of this property will be 5.
              </para>
            </remarks>
            <seealso cref="P:Ionic.Zip.ZipFile.MaxOutputSegmentSize"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.ParallelDeflateThreshold">
             <summary>
               The size threshold for an entry, above which a parallel deflate is used.
             </summary>
            
             <remarks>
            
               <para>
                 DotNetZip will use multiple threads to compress any ZipEntry,
                 if the entry is larger than the given size.  Zero means "always
                 use parallel deflate", while -1 means "never use parallel
                 deflate". The default value for this property is 512k. Aside
                 from the special values of 0 and 1, the minimum value is 65536.
               </para>
            
               <para>
                 If the entry size cannot be known before compression, as with a
                 read-forward stream, then Parallel deflate will never be
                 performed, unless the value of this property is zero.
               </para>
            
               <para>
                 A parallel deflate operations will speed up the compression of
                 large files, on computers with multiple CPUs or multiple CPU
                 cores.  For files above 1mb, on a dual core or dual-cpu (2p)
                 machine, the time required to compress the file can be 70% of the
                 single-threaded deflate.  For very large files on 4p machines the
                 compression can be done in 30% of the normal time.  The downside
                 is that parallel deflate consumes extra memory during the deflate,
                 and the deflation is not as effective.
               </para>
            
               <para>
                 Parallel deflate tends to not be as effective as single-threaded deflate
                 because the original data stream is split into multiple independent
                 buffers, each of which is compressed in parallel.  But because they are
                 treated independently, there is no opportunity to share compression
                 dictionaries.  For that reason, a deflated stream may be slightly larger
                 when compressed using parallel deflate, as compared to a traditional
                 single-threaded deflate. Sometimes the increase over the normal deflate
                 is as much as 5% of the total compressed size. For larger files it can
                 be as small as 0.1%.
               </para>
            
               <para>
                 Multi-threaded compression does not give as much an advantage when using
                 Encryption. This is primarily because encryption tends to slow down
                 the entire pipeline. Also, multi-threaded compression gives less of an
                 advantage when using lower compression levels, for example <see cref="F:Ionic.Zlib.CompressionLevel.BestSpeed"/>.  You may have to perform
                 some tests to determine the best approach for your situation.
               </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.LibraryVersion">
             <summary>
             Returns the version number on the DotNetZip assembly.
             </summary>
            
             <remarks>
               <para>
                 This property is exposed as a convenience.  Callers could also get the
                 version value by retrieving GetName().Version on the
                 System.Reflection.Assembly object pointing to the DotNetZip
                 assembly. But sometimes it is not clear which assembly is being loaded.
                 This property makes it clear.
               </para>
               <para>
                 This static property is primarily useful for diagnostic purposes.
               </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Item(System.Int32)">
             <summary>
               This is an integer indexer into the Zip archive.
             </summary>
            
             <remarks>
             <para>
               This property is read-only.
             </para>
            
             <para>
               Internally, the <c>ZipEntry</c> instances that belong to the
               <c>ZipFile</c> are stored in a Dictionary.  When you use this
               indexer the first time, it creates a read-only
               <c>List&lt;ZipEntry&gt;</c> from the Dictionary.Values Collection.
               If at any time you modify the set of entries in the <c>ZipFile</c>,
               either by adding an entry, removing an entry, or renaming an
               entry, a new List will be created, and the numeric indexes for the
               remaining entries may be different.
             </para>
            
             <para>
               This means you cannot rename any ZipEntry from
               inside an enumeration of the zip file.
             </para>
            
             <param name="ix">
               The index value.
             </param>
            
             </remarks>
            
             <returns>
               The <c>ZipEntry</c> within the Zip archive at the specified index. If the
               entry does not exist in the archive, this indexer throws.
             </returns>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.Item(System.String)">
             <summary>
               This is a name-based indexer into the Zip archive.
             </summary>
            
             <remarks>
             <para>
               This property is read-only.
             </para>
            
             <para>
               The <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval"/> property on the <c>ZipFile</c>
               determines whether retrieval via this indexer is done via case-sensitive
               comparisons. By default, retrieval is not case sensitive.  This makes
               sense on Windows, in which filesystems are not case sensitive.
             </para>
            
             <para>
               Regardless of case-sensitivity, it is not always the case that
               <c>this[value].FileName == value</c>. In other words, the <c>FileName</c>
               property of the <c>ZipEntry</c> retrieved with this indexer, may or may
               not be equal to the index value.
             </para>
            
             <para>
               This is because DotNetZip performs a normalization of filenames passed to
               this indexer, before attempting to retrieve the item.  That normalization
               includes: removal of a volume letter and colon, swapping backward slashes
               for forward slashes.  So, <c>zip["dir1\\entry1.txt"].FileName ==
               "dir1/entry.txt"</c>.
             </para>
            
             <para>
               Directory entries in the zip file may be retrieved via this indexer only
               with names that have a trailing slash. DotNetZip automatically appends a
               trailing slash to the names of any directory entries added to a zip.
             </para>
            
             </remarks>
            
             <example>
             This example extracts only the entries in a zip file that are .txt files.
             <code>
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                   zip[s1].Extract("textfiles");
               }
             }
             </code>
             <code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code>
             </example>
             <seealso cref="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)"/>
            
             <exception cref="T:System.ArgumentException">
               Thrown if the caller attempts to assign a non-null value to the indexer.
             </exception>
            
             <param name="fileName">
               The name of the file, including any directory path, to retrieve from the
               zip.  The filename match is not case-sensitive by default; you can use the
               <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval"/> property to change this behavior. The
               pathname can use forward-slashes or backward slashes.
             </param>
            
             <returns>
               The <c>ZipEntry</c> within the Zip archive, given by the specified
               filename. If the named entry does not exist in the archive, this indexer
               returns <c>null</c> (<c>Nothing</c> in VB).
             </returns>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.EntryFileNames">
             <summary>
               The list of filenames for the entries contained within the zip archive.
             </summary>
            
             <remarks>
               According to the ZIP specification, the names of the entries use forward
               slashes in pathnames.  If you are scanning through the list, you may have
               to swap forward slashes for backslashes.
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Item(System.String)"/>
            
             <example>
               This example shows one way to test if a filename is already contained
               within a zip archive.
             <code>
             String zipFileToRead= "PackedDocuments.zip";
             string candidate = "DatedMaterial.xps";
             using (ZipFile zip = new ZipFile(zipFileToRead))
             {
               if (zip.EntryFilenames.Contains(candidate))
                 Console.WriteLine("The file '{0}' exists in the zip archive '{1}'",
                                   candidate,
                                   zipFileName);
               else
                 Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'",
                                   candidate,
                                   zipFileName);
               Console.WriteLine();
             }
             </code>
             <code lang="VB">
               Dim zipFileToRead As String = "PackedDocuments.zip"
               Dim candidate As String = "DatedMaterial.xps"
               Using zip As ZipFile.Read(ZipFileToRead)
                   If zip.EntryFilenames.Contains(candidate) Then
                       Console.WriteLine("The file '{0}' exists in the zip archive '{1}'", _
                                   candidate, _
                                   zipFileName)
                   Else
                     Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'", _
                                   candidate, _
                                   zipFileName)
                   End If
                   Console.WriteLine
               End Using
             </code>
             </example>
            
             <returns>
               The list of strings for the filenames contained within the Zip archive.
             </returns>
            
        </member>
        <member name="P:Ionic.Zip.ZipFile.Entries">
             <summary>
               Returns the readonly collection of entries in the Zip archive.
             </summary>
            
             <remarks>
            
             <para>
               If there are no entries in the current <c>ZipFile</c>, the value returned is a
               non-null zero-element collection.  If there are entries in the zip file,
               the elements are returned in no particular order.
             </para>
             <para>
               This is the implied enumerator on the <c>ZipFile</c> class.  If you use a
               <c>ZipFile</c> instance in a context that expects an enumerator, you will
               get this collection.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipFile.EntriesSorted"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.EntriesSorted">
             <summary>
               Returns a readonly collection of entries in the Zip archive, sorted by FileName.
             </summary>
            
             <remarks>
               If there are no entries in the current <c>ZipFile</c>, the value returned
               is a non-null zero-element collection.  If there are entries in the zip
               file, the elements are returned sorted by the name of the entry.
             </remarks>
            
             <example>
            
               This example fills a Windows Forms ListView with the entries in a zip file.
            
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read(zipFile))
             {
                 foreach (ZipEntry entry in zip.EntriesSorted)
                 {
                     ListViewItem item = new ListViewItem(n.ToString());
                     n++;
                     string[] subitems = new string[] {
                         entry.FileName.Replace("/","\\"),
                         entry.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                         entry.UncompressedSize.ToString(),
                         String.Format("{0,5:F0}%", entry.CompressionRatio),
                         entry.CompressedSize.ToString(),
                         (entry.UsesEncryption) ? "Y" : "N",
                         String.Format("{0:X8}", entry.Crc)};
            
                     foreach (String s in subitems)
                     {
                         ListViewItem.ListViewSubItem subitem = new ListViewItem.ListViewSubItem();
                         subitem.Text = s;
                         item.SubItems.Add(subitem);
                     }
            
                     this.listView1.Items.Add(item);
                 }
             }
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.Entries"/>
        </member>
        <member name="P:Ionic.Zip.ZipFile.Count">
            <summary>
            Returns the number of entries in the Zip archive.
            </summary>
        </member>
        <member name="E:Ionic.Zip.ZipFile.SaveProgress">
             <summary>
             An event handler invoked when a Save() starts, before and after each entry has been
             written to the archive, when a Save() completes, and during other Save events.
             </summary>
            
             <remarks>
             <para>
             Depending on the particular event, different properties on the
             <see cref="T:Ionic.Zip.SaveProgressEventArgs"/> parameter are set.  The following table
             summarizes the available EventTypes and the conditions under which this
             event handler is invoked with a <c>SaveProgressEventArgs</c> with the given EventType.
             </para>
            
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
            
             <item>
             <term>ZipProgressEventType.Saving_Started</term>
             <description>Fired when ZipFile.Save() begins.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_BeforeSaveEntry</term>
             <description>Fired within ZipFile.Save(), just before writing data for each particular entry.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterSaveEntry</term>
             <description>Fired within ZipFile.Save(), just after having finished writing data for each
             particular entry.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_Completed</term>
             <description>Fired when ZipFile.Save() has completed.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterSaveTempArchive</term>
             <description>Fired after the temporary file has been created.  This happens only
             when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_BeforeRenameTempArchive</term>
             <description>Fired just before renaming the temporary file to the permanent location.  This
             happens only when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterRenameTempArchive</term>
             <description>Fired just after renaming the temporary file to the permanent location.  This
             happens only when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_AfterCompileSelfExtractor</term>
             <description>Fired after a self-extracting archive has finished compiling.
             This EventType is used only within SaveSelfExtractor().
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Saving_BytesRead</term>
             <description>Set during the save of a particular entry, to update progress of the Save().
             When this EventType is set, the BytesTransferred is the number of bytes that have been read from the
             source stream.  The TotalBytesToTransfer is the number of bytes in the uncompressed file.
             </description>
             </item>
            
             </list>
             </remarks>
            
             <example>
            
                This example uses an anonymous method to handle the
                SaveProgress event, by updating a progress bar.
            
             <code lang="C#">
             progressBar1.Value = 0;
             progressBar1.Max = listbox1.Items.Count;
             using (ZipFile zip = new ZipFile())
             {
                // listbox1 contains a list of filenames
                zip.AddFiles(listbox1.Items);
            
                // do the progress bar:
                zip.SaveProgress += (sender, e) =&gt; {
                   if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry) {
                      progressBar1.PerformStep();
                   }
                };
            
                zip.Save(fs);
             }
             </code>
             </example>
            
             <example>
               This example uses a named method as the
               <c>SaveProgress</c> event handler, to update the user, in a
               console-based application.
            
             <code lang="C#">
             static bool justHadByteUpdate= false;
             public static void SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.Saving_Started)
                     Console.WriteLine("Saving: {0}", e.ArchiveName);
            
                 else if (e.EventType == ZipProgressEventType.Saving_Completed)
                 {
                     justHadByteUpdate= false;
                     Console.WriteLine();
                     Console.WriteLine("Done: {0}", e.ArchiveName);
                 }
            
                 else if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry)
                 {
                     if (justHadByteUpdate)
                         Console.WriteLine();
                     Console.WriteLine("  Writing: {0} ({1}/{2})",
                                       e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal);
                     justHadByteUpdate= false;
                 }
            
                 else if (e.EventType == ZipProgressEventType.Saving_EntryBytesRead)
                 {
                     if (justHadByteUpdate)
                         Console.SetCursorPosition(0, Console.CursorTop);
                      Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
                                   e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
                     justHadByteUpdate= true;
                 }
             }
            
             public static ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile()) {
                 zip.SaveProgress += SaveProgress;
                 zip.AddDirectory(directory);
                 zip.Save(targetZip);
               }
             }
            
             </code>
            
             <code lang="VB">
             Public Sub ZipUp(ByVal targetZip As String, ByVal directory As String)
                 Using zip As ZipFile = New ZipFile
                     AddHandler zip.SaveProgress, AddressOf MySaveProgress
                     zip.AddDirectory(directory)
                     zip.Save(targetZip)
                 End Using
             End Sub
            
             Private Shared justHadByteUpdate As Boolean = False
            
             Public Shared Sub MySaveProgress(ByVal sender As Object, ByVal e As SaveProgressEventArgs)
                 If (e.EventType Is ZipProgressEventType.Saving_Started) Then
                     Console.WriteLine("Saving: {0}", e.ArchiveName)
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_Completed) Then
                     justHadByteUpdate = False
                     Console.WriteLine
                     Console.WriteLine("Done: {0}", e.ArchiveName)
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_BeforeWriteEntry) Then
                     If justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("  Writing: {0} ({1}/{2})", e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal)
                     justHadByteUpdate = False
            
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_EntryBytesRead) Then
                     If justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, _
                                   e.TotalBytesToTransfer, _
                                   (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
                     justHadByteUpdate = True
                 End If
             End Sub
             </code>
             </example>
            
             <example>
            
             This is a more complete example of using the SaveProgress
             events in a Windows Forms application, with a
             Thread object.
            
             <code lang="C#">
             delegate void SaveEntryProgress(SaveProgressEventArgs e);
             delegate void ButtonClick(object sender, EventArgs e);
            
             public class WorkerOptions
             {
                 public string ZipName;
                 public string Folder;
                 public string Encoding;
                 public string Comment;
                 public int ZipFlavor;
                 public Zip64Option Zip64;
             }
            
             private int _progress2MaxFactor;
             private bool _saveCanceled;
             private long _totalBytesBeforeCompress;
             private long _totalBytesAfterCompress;
             private Thread _workerThread;
            
            
             private void btnZipup_Click(object sender, EventArgs e)
             {
                 KickoffZipup();
             }
            
             private void btnCancel_Click(object sender, EventArgs e)
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new ButtonClick(this.btnCancel_Click), new object[] { sender, e });
                 }
                 else
                 {
                     _saveCanceled = true;
                     lblStatus.Text = "Canceled...";
                     ResetState();
                 }
             }
            
             private void KickoffZipup()
             {
                 _folderName = tbDirName.Text;
            
                 if (_folderName == null || _folderName == "") return;
                 if (this.tbZipName.Text == null || this.tbZipName.Text == "") return;
            
                 // check for existence of the zip file:
                 if (System.IO.File.Exists(this.tbZipName.Text))
                 {
                     var dlgResult = MessageBox.Show(String.Format("The file you have specified ({0}) already exists." +
                                                                   "  Do you want to overwrite this file?", this.tbZipName.Text),
                                                     "Confirmation is Required", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
                     if (dlgResult != DialogResult.Yes) return;
                     System.IO.File.Delete(this.tbZipName.Text);
                 }
            
                  _saveCanceled = false;
                 _nFilesCompleted = 0;
                 _totalBytesAfterCompress = 0;
                 _totalBytesBeforeCompress = 0;
                 this.btnOk.Enabled = false;
                 this.btnOk.Text = "Zipping...";
                 this.btnCancel.Enabled = true;
                 lblStatus.Text = "Zipping...";
            
                 var options = new WorkerOptions
                 {
                     ZipName = this.tbZipName.Text,
                     Folder = _folderName,
                     Encoding = "ibm437"
                 };
            
                 if (this.comboBox1.SelectedIndex != 0)
                 {
                     options.Encoding = this.comboBox1.SelectedItem.ToString();
                 }
            
                 if (this.radioFlavorSfxCmd.Checked)
                     options.ZipFlavor = 2;
                 else if (this.radioFlavorSfxGui.Checked)
                     options.ZipFlavor = 1;
                 else options.ZipFlavor = 0;
            
                 if (this.radioZip64AsNecessary.Checked)
                     options.Zip64 = Zip64Option.AsNecessary;
                 else if (this.radioZip64Always.Checked)
                     options.Zip64 = Zip64Option.Always;
                 else options.Zip64 = Zip64Option.Never;
            
                 options.Comment = String.Format("Encoding:{0} || Flavor:{1} || ZIP64:{2}\r\nCreated at {3} || {4}\r\n",
                             options.Encoding,
                             FlavorToString(options.ZipFlavor),
                             options.Zip64.ToString(),
                             System.DateTime.Now.ToString("yyyy-MMM-dd HH:mm:ss"),
                             this.Text);
            
                 if (this.tbComment.Text != TB_COMMENT_NOTE)
                     options.Comment += this.tbComment.Text;
            
                 _workerThread = new Thread(this.DoSave);
                 _workerThread.Name = "Zip Saver thread";
                 _workerThread.Start(options);
                 this.Cursor = Cursors.WaitCursor;
              }
            
            
             private void DoSave(Object p)
             {
                 WorkerOptions options = p as WorkerOptions;
                 try
                 {
                     using (var zip1 = new ZipFile())
                     {
                         zip1.ProvisionalAlternateEncoding = System.Text.Encoding.GetEncoding(options.Encoding);
                         zip1.Comment = options.Comment;
                         zip1.AddDirectory(options.Folder);
                         _entriesToZip = zip1.EntryFileNames.Count;
                         SetProgressBars();
                         zip1.SaveProgress += this.zip1_SaveProgress;
            
                         zip1.UseZip64WhenSaving = options.Zip64;
            
                         if (options.ZipFlavor == 1)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.WinFormsApplication);
                         else if (options.ZipFlavor == 2)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.ConsoleApplication);
                         else
                             zip1.Save(options.ZipName);
                     }
                 }
                 catch (System.Exception exc1)
                 {
                     MessageBox.Show(String.Format("Exception while zipping: {0}", exc1.Message));
                     btnCancel_Click(null, null);
                 }
             }
            
            
            
             void zip1_SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.Saving_AfterWriteEntry:
                         StepArchiveProgress(e);
                         break;
                     case ZipProgressEventType.Saving_EntryBytesRead:
                         StepEntryProgress(e);
                         break;
                     case ZipProgressEventType.Saving_Completed:
                         SaveCompleted();
                         break;
                     case ZipProgressEventType.Saving_AfterSaveTempArchive:
                         // this event only occurs when saving an SFX file
                         TempArchiveSaved();
                         break;
                 }
                 if (_saveCanceled)
                     e.Cancel = true;
             }
            
            
            
             private void StepArchiveProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar1.InvokeRequired)
                 {
                     this.progressBar1.Invoke(new SaveEntryProgress(this.StepArchiveProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         _nFilesCompleted++;
                         this.progressBar1.PerformStep();
                         _totalBytesAfterCompress += e.CurrentEntry.CompressedSize;
                         _totalBytesBeforeCompress += e.CurrentEntry.UncompressedSize;
            
                         // reset the progress bar for the entry:
                         this.progressBar2.Value = this.progressBar2.Maximum = 1;
            
                         this.Update();
                     }
                 }
             }
            
            
             private void StepEntryProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar2.InvokeRequired)
                 {
                     this.progressBar2.Invoke(new SaveEntryProgress(this.StepEntryProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         if (this.progressBar2.Maximum == 1)
                         {
                             // reset
                             Int64 max = e.TotalBytesToTransfer;
                             _progress2MaxFactor = 0;
                             while (max &gt; System.Int32.MaxValue)
                             {
                                 max /= 2;
                                 _progress2MaxFactor++;
                             }
                             this.progressBar2.Maximum = (int)max;
                             lblStatus.Text = String.Format("{0} of {1} files...({2})",
                                 _nFilesCompleted + 1, _entriesToZip, e.CurrentEntry.FileName);
                         }
            
                          int xferred = e.BytesTransferred &gt;&gt; _progress2MaxFactor;
            
                          this.progressBar2.Value = (xferred &gt;= this.progressBar2.Maximum)
                             ? this.progressBar2.Maximum
                             : xferred;
            
                          this.Update();
                     }
                 }
             }
            
             private void SaveCompleted()
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new MethodInvoker(this.SaveCompleted));
                 }
                 else
                 {
                     lblStatus.Text = String.Format("Done, Compressed {0} files, {1:N0}% of original.",
                         _nFilesCompleted, (100.00 * _totalBytesAfterCompress) / _totalBytesBeforeCompress);
                      ResetState();
                 }
             }
            
             private void ResetState()
             {
                 this.btnCancel.Enabled = false;
                 this.btnOk.Enabled = true;
                 this.btnOk.Text = "Zip it!";
                 this.progressBar1.Value = 0;
                 this.progressBar2.Value = 0;
                 this.Cursor = Cursors.Default;
                 if (!_workerThread.IsAlive)
                     _workerThread.Join();
             }
             </code>
            
             </example>
            
             <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.AddProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.ReadProgress">
             <summary>
             An event handler invoked before, during, and after the reading of a zip archive.
             </summary>
            
             <remarks>
             <para>
             Depending on the particular event being signaled, different properties on the
             <see cref="T:Ionic.Zip.ReadProgressEventArgs"/> parameter are set.  The following table
             summarizes the available EventTypes and the conditions under which this
             event handler is invoked with a <c>ReadProgressEventArgs</c> with the given EventType.
             </para>
            
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
            
             <item>
             <term>ZipProgressEventType.Reading_Started</term>
             <description>Fired just as ZipFile.Read() begins. Meaningful properties: ArchiveName.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_Completed</term>
             <description>Fired when ZipFile.Read() has completed. Meaningful properties: ArchiveName.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_ArchiveBytesRead</term>
             <description>Fired while reading, updates the number of bytes read for the entire archive.
             Meaningful properties: ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_BeforeReadEntry</term>
             <description>Indicates an entry is about to be read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Reading_AfterReadEntry</term>
             <description>Indicates an entry has just been read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal, CurrentEntry.
             </description>
             </item>
            
             </list>
             </remarks>
            
             <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.AddProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.ExtractProgress">
             <summary>
             An event handler invoked before, during, and after extraction of entries
             in the zip archive.
             </summary>
            
             <remarks>
             <para>
             Depending on the particular event, different properties on the
             <see cref="T:Ionic.Zip.ExtractProgressEventArgs"/> parameter are set.  The following table
             summarizes the available EventTypes and the conditions under which this
             event handler is invoked with a <c>ExtractProgressEventArgs</c> with the given EventType.
             </para>
            
             <list type="table">
             <listheader>
             <term>value of EntryType</term>
             <description>Meaning and conditions</description>
             </listheader>
            
             <item>
             <term>ZipProgressEventType.Extracting_BeforeExtractAll</term>
             <description>Set when ExtractAll() begins.  The ArchiveName, Overwrite,
             and ExtractLocation properties are meaningful.</description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_AfterExtractAll</term>
             <description>Set when ExtractAll() has completed.  The ArchiveName,
             Overwrite, and ExtractLocation properties are meaningful.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_BeforeExtractEntry</term>
             <description>Set when an Extract() on an entry in the ZipFile has begun.
             Properties that are meaningful:  ArchiveName, EntriesTotal, CurrentEntry, Overwrite,
             ExtractLocation, EntriesExtracted.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_AfterExtractEntry</term>
             <description>Set when an Extract() on an entry in the ZipFile has completed.
             Properties that are meaningful:  ArchiveName, EntriesTotal, CurrentEntry, Overwrite,
             ExtractLocation, EntriesExtracted.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_EntryBytesWritten</term>
             <description>Set within a call to Extract() on an entry in the ZipFile, as
             data is extracted for the entry.  Properties that are meaningful:  ArchiveName,
             CurrentEntry, BytesTransferred, TotalBytesToTransfer.
             </description>
             </item>
            
             <item>
             <term>ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite</term>
             <description>Set within a call to Extract() on an entry in the ZipFile, when the
             extraction would overwrite an existing file. This event type is used only when
             <c>ExtractExistingFileAction</c> on the <c>ZipFile</c> or <c>ZipEntry</c> is set
             to <c>InvokeExtractProgressEvent</c>.
             </description>
             </item>
            
             </list>
            
             </remarks>
            
             <example>
             <code>
             private static bool justHadByteUpdate = false;
             public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
             {
               if(e.EventType == ZipProgressEventType.Extracting_EntryBytesWritten)
               {
                 if (justHadByteUpdate)
                   Console.SetCursorPosition(0, Console.CursorTop);
            
                 Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
                               e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
                 justHadByteUpdate = true;
               }
               else if(e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
               {
                 if (justHadByteUpdate)
                   Console.WriteLine();
                 Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName);
                 justHadByteUpdate= false;
               }
             }
            
             public static ExtractZip(string zipToExtract, string directory)
             {
               string TargetDirectory= "extract";
               using (var zip = ZipFile.Read(zipToExtract)) {
                 zip.ExtractProgress += ExtractProgress;
                 foreach (var e in zip1)
                 {
                   e.Extract(TargetDirectory, true);
                 }
               }
             }
            
             </code>
             <code lang="VB">
             Public Shared Sub Main(ByVal args As String())
                 Dim ZipToUnpack As String = "C1P3SML.zip"
                 Dim TargetDir As String = "ExtractTest_Extract"
                 Console.WriteLine("Extracting file {0} to {1}", ZipToUnpack, TargetDir)
                 Using zip1 As ZipFile = ZipFile.Read(ZipToUnpack)
                     AddHandler zip1.ExtractProgress, AddressOf MyExtractProgress
                     Dim e As ZipEntry
                     For Each e In zip1
                         e.Extract(TargetDir, True)
                     Next
                 End Using
             End Sub
            
             Private Shared justHadByteUpdate As Boolean = False
            
             Public Shared Sub MyExtractProgress(ByVal sender As Object, ByVal e As ExtractProgressEventArgs)
                 If (e.EventType = ZipProgressEventType.Extracting_EntryBytesWritten) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer, (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
                     ExtractTest.justHadByteUpdate = True
                 ElseIf (e.EventType = ZipProgressEventType.Extracting_BeforeExtractEntry) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName)
                     ExtractTest.justHadByteUpdate = False
                 End If
             End Sub
             </code>
             </example>
            
             <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.AddProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.AddProgress">
             <summary>
             An event handler invoked before, during, and after Adding entries to a zip archive.
             </summary>
            
             <remarks>
                 Adding a large number of entries to a zip file can take a long
                 time.  For example, when calling <see cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)"/> on a
                 directory that contains 50,000 files, it could take 3 minutes or so.
                 This event handler allws an application to track the progress of the Add
                 operation.
             </remarks>
            
             <example>
             <code lang="C#">
            
             int _numEntriesToAdd= 0;
             int _numEntriesAdded= 0;
             void AddProgressHandler(object sender, AddProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.Adding_Started:
                         Console.WriteLine("Adding files to the zip...");
                         break;
                     case ZipProgressEventType.Adding_AfterAddEntry:
                         _numEntriesAdded++;
                         Console.WriteLine(String.Format("Adding file {0}/{1} :: {2}",
                                                  _numEntriesAdded, _numEntriesToAdd, e.CurrentEntry.FileName));
                         break;
                     case ZipProgressEventType.Adding_Completed:
                         Console.WriteLine("Added all files");
                         break;
                 }
             }
            
             void CreateTheZip()
             {
                 using (ZipFile zip = new ZipFile())
                 {
                     zip.AddProgress += AddProgressHandler;
                     zip.AddDirectory(System.IO.Path.GetFileName(DirToZip));
                     zip.Save(ZipFileToCreate);
                 }
             }
            
             </code>
            
             <code lang="VB">
            
             Private Sub AddProgressHandler(ByVal sender As Object, ByVal e As AddProgressEventArgs)
                 Select Case e.EventType
                     Case ZipProgressEventType.Adding_Started
                         Console.WriteLine("Adding files to the zip...")
                         Exit Select
                     Case ZipProgressEventType.Adding_AfterAddEntry
                         Console.WriteLine(String.Format("Adding file {0}", e.CurrentEntry.FileName))
                         Exit Select
                     Case ZipProgressEventType.Adding_Completed
                         Console.WriteLine("Added all files")
                         Exit Select
                 End Select
             End Sub
            
             Sub CreateTheZip()
                 Using zip as ZipFile = New ZipFile
                     AddHandler zip.AddProgress, AddressOf AddProgressHandler
                     zip.AddDirectory(System.IO.Path.GetFileName(DirToZip))
                     zip.Save(ZipFileToCreate);
                 End Using
             End Sub
            
             </code>
            
             </example>
            
             <seealso cref="E:Ionic.Zip.ZipFile.SaveProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ReadProgress"/>
             <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress"/>
        </member>
        <member name="E:Ionic.Zip.ZipFile.ZipError">
             <summary>
             An event that is raised when an error occurs during open or read of files
             while saving a zip archive.
             </summary>
            
             <remarks>
              <para>
                 Errors can occur as a file is being saved to the zip archive.  For
                 example, the File.Open may fail, or a File.Read may fail, because of
                 lock conflicts or other reasons.  If you add a handler to this event,
                 you can handle such errors in your own code.  If you don't add a
                 handler, the library will throw an exception if it encounters an I/O
                 error during a call to <c>Save()</c>.
              </para>
            
              <para>
                Setting a handler implicitly sets <see cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/> to
                <c>ZipErrorAction.InvokeErrorEvent</c>.
              </para>
            
              <para>
                The handler you add applies to all <see cref="T:Ionic.Zip.ZipEntry"/> items that are
                subsequently added to the <c>ZipFile</c> instance. If you set this
                property after you have added items to the <c>ZipFile</c>, but before you
                have called <c>Save()</c>, errors that occur while saving those items
                will not cause the error handler to be invoked.
              </para>
            
              <para>
                If you want to handle any errors that occur with any entry in the zip
                file using the same error handler, then add your error handler once,
                before adding any entries to the zip archive.
              </para>
            
              <para>
                In the error handler method, you need to set the <see cref="P:Ionic.Zip.ZipEntry.ZipErrorAction"/> property on the
                <c>ZipErrorEventArgs.CurrentEntry</c>.  This communicates back to
                DotNetZip what you would like to do with this particular error.  Within
                an error handler, if you set the <c>ZipEntry.ZipErrorAction</c> property
                on the <c>ZipEntry</c> to <c>ZipErrorAction.InvokeErrorEvent</c> or if
                you don't set it at all, the library will throw the exception. (It is the
                same as if you had set the <c>ZipEntry.ZipErrorAction</c> property on the
                <c>ZipEntry</c> to <c>ZipErrorAction.Throw</c>.) If you set the
                <c>ZipErrorEventArgs.Cancel</c> to true, the entire <c>Save()</c> will be
                canceled.
              </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use an event handler to handle
             errors during save of the zip file.
             <code lang="C#">
            
             public static void MyZipError(object sender, ZipErrorEventArgs e)
             {
                 Console.WriteLine("Error saving {0}...", e.FileName);
                 Console.WriteLine("   Exception: {0}", e.exception);
                 ZipEntry entry = e.CurrentEntry;
                 string response = null;
                 // Ask the user whether he wants to skip this error or not
                 do
                 {
                     Console.Write("Retry, Skip, Throw, or Cancel ? (R/S/T/C) ");
                     response = Console.ReadLine();
                     Console.WriteLine();
            
                 } while (response != null &amp;&amp;
                          response[0]!='S' &amp;&amp; response[0]!='s' &amp;&amp;
                          response[0]!='R' &amp;&amp; response[0]!='r' &amp;&amp;
                          response[0]!='T' &amp;&amp; response[0]!='t' &amp;&amp;
                          response[0]!='C' &amp;&amp; response[0]!='c');
            
                 e.Cancel = (response[0]=='C' || response[0]=='c');
            
                 if (response[0]=='S' || response[0]=='s')
                     entry.ZipErrorAction = ZipErrorAction.Skip;
                 else if (response[0]=='R' || response[0]=='r')
                     entry.ZipErrorAction = ZipErrorAction.Retry;
                 else if (response[0]=='T' || response[0]=='t')
                     entry.ZipErrorAction = ZipErrorAction.Throw;
             }
            
             public void SaveTheFile()
             {
               string directoryToZip = "fodder";
               string directoryInArchive = "files";
               string zipFileToCreate = "Archive.zip";
               using (var zip = new ZipFile())
               {
                 // set the event handler before adding any entries
                 zip.ZipError += MyZipError;
                 zip.AddDirectory(directoryToZip, directoryInArchive);
                 zip.Save(zipFileToCreate);
               }
             }
             </code>
            
             <code lang="VB">
             Private Sub MyZipError(ByVal sender As Object, ByVal e As Ionic.Zip.ZipErrorEventArgs)
                 ' At this point, the application could prompt the user for an action to take.
                 ' But in this case, this application will simply automatically skip the file, in case of error.
                 Console.WriteLine("Zip Error,  entry {0}", e.CurrentEntry.FileName)
                 Console.WriteLine("   Exception: {0}", e.exception)
                 ' set the desired ZipErrorAction on the CurrentEntry to communicate that to DotNetZip
                 e.CurrentEntry.ZipErrorAction = Zip.ZipErrorAction.Skip
             End Sub
            
             Public Sub SaveTheFile()
                 Dim directoryToZip As String = "fodder"
                 Dim directoryInArchive As String = "files"
                 Dim zipFileToCreate as String = "Archive.zip"
                 Using zipArchive As ZipFile = New ZipFile
                     ' set the event handler before adding any entries
                     AddHandler zipArchive.ZipError, AddressOf MyZipError
                     zipArchive.AddDirectory(directoryToZip, directoryInArchive)
                     zipArchive.Save(zipFileToCreate)
                 End Using
             End Sub
            
             </code>
             </example>
            
             <seealso cref="P:Ionic.Zip.ZipFile.ZipErrorAction"/>
        </member>
        <member name="T:Ionic.Zip.Zip64Option">
             <summary>
               Options for using ZIP64 extensions when saving zip archives.
             </summary>
            
             <remarks>
            
             <para>
               Designed many years ago, the <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">original zip
               specification from PKWARE</see> allowed for 32-bit quantities for the
               compressed and uncompressed sizes of zip entries, as well as a 32-bit quantity
               for specifying the length of the zip archive itself, and a maximum of 65535
               entries.  These limits are now regularly exceeded in many backup and archival
               scenarios.  Recently, PKWare added extensions to the original zip spec, called
               "ZIP64 extensions", to raise those limitations.  This property governs whether
               DotNetZip will use those extensions when writing zip archives. The use of
               these extensions is optional and explicit in DotNetZip because, despite the
               status of ZIP64 as a bona fide standard, many other zip tools and libraries do
               not support ZIP64, and therefore a zip file with ZIP64 extensions may be
               unreadable by some of those other tools.
             </para>
            
             <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.Always"/> to always use ZIP64
               extensions when saving, regardless of whether your zip archive needs it.
               Suppose you add 5 files, each under 100k, to a ZipFile. If you specify Always
               for this flag, you will get a ZIP64 archive, though the archive does not need
               to use ZIP64 because none of the original zip limits had been exceeded.
             </para>
            
             <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.Never"/> to tell the DotNetZip
               library to never use ZIP64 extensions.  This is useful for maximum
               compatibility and interoperability, at the expense of the capability of
               handling large files or large archives.  NB: Windows Explorer in Windows XP
               and Windows Vista cannot currently extract files from a zip64 archive, so if
               you want to guarantee that a zip archive produced by this library will work in
               Windows Explorer, use <c>Never</c>. If you set this property to <see cref="F:Ionic.Zip.Zip64Option.Never"/>, and your application creates a zip that would
               exceed one of the Zip limits, the library will throw an exception while saving
               the zip file.
             </para>
            
             <para>
               Set this property to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> to tell the
               DotNetZip library to use the ZIP64 extensions when required by the
               entry. After the file is compressed, the original and compressed sizes are
               checked, and if they exceed the limits described above, then zip64 can be
               used. That is the general idea, but there is an additional wrinkle when saving
               to a non-seekable device, like the ASP.NET <c>Response.OutputStream</c>, or
               <c>Console.Out</c>.  When using non-seekable streams for output, the entry
               header - which indicates whether zip64 is in use - is emitted before it is
               known if zip64 is necessary.  It is only after all entries have been saved
               that it can be known if ZIP64 will be required.  On seekable output streams,
               after saving all entries, the library can seek backward and re-emit the zip
               file header to be consistent with the actual ZIP64 requirement.  But using a
               non-seekable output stream, the library cannot seek backward, so the header
               can never be changed. In other words, the archive's use of ZIP64 extensions is
               not alterable after the header is emitted.  Therefore, when saving to
               non-seekable streams, using <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> is the same
               as using <see cref="F:Ionic.Zip.Zip64Option.Always"/>: it will always produce a zip
               archive that uses ZIP64 extensions.
             </para>
            
             </remarks>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Default">
            <summary>
            The default behavior, which is "Never".
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Never">
            <summary>
            Do not use ZIP64 extensions when writing zip archives.
            (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.AsNecessary">
            <summary>
            Use ZIP64 extensions when writing zip archives, as necessary.
            For example, when a single entry exceeds 0xFFFFFFFF in size, or when the archive as a whole
            exceeds 0xFFFFFFFF in size, or when there are more than 65535 entries in an archive.
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:Ionic.Zip.Zip64Option.Always">
            <summary>
            Always use ZIP64 extensions when writing zip archives, even when unnecessary.
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="T:Ionic.Zip.ZipInputStream">
             <summary>
               Provides a stream metaphor for reading zip files.
             </summary>
            
             <remarks>
             <para>
               This class provides an alternative programming model for reading zip files to
               the one enabled by the <see cref="T:Ionic.Zip.ZipFile"/> class.  Use this when reading zip
               files, as an alternative to the <see cref="T:Ionic.Zip.ZipFile"/> class, when you would
               like to use a Stream class to read the file.
             </para>
            
             <para>
               Some application designs require a readable stream for input. This stream can
               be used to read a zip file, and extract entries.
             </para>
            
             <para>
               Both the <c>ZipInputStream</c> class and the <c>ZipFile</c> class can be used
               to read and extract zip files.  Both of them support many of the common zip
               features, including Unicode, different compression levels, and ZIP64.  The
               programming models differ. For example, when extracting entries via calls to
               the <c>GetNextEntry()</c> and <c>Read()</c> methods on the
               <c>ZipInputStream</c> class, the caller is responsible for creating the file,
               writing the bytes into the file, setting the attributes on the file, and
               setting the created, last modified, and last accessed timestamps on the
               file. All of these things are done automatically by a call to <see cref="M:Ionic.Zip.ZipEntry.Extract">ZipEntry.Extract()</see>.  For this reason, the
               <c>ZipInputStream</c> is generally recommended for when your application wants
               to extract the data, without storing that data into a file.
             </para>
            
             <para>
               Aside from the obvious differences in programming model, there are some
               differences in capability between the <c>ZipFile</c> class and the
               <c>ZipInputStream</c> class.
             </para>
            
             <list type="bullet">
               <item>
                 <c>ZipFile</c> can be used to create or update zip files, or read and
                 extract zip files. <c>ZipInputStream</c> can be used only to read and
                 extract zip files. If you want to use a stream to create zip files, check
                 out the <see cref="T:Ionic.Zip.ZipOutputStream"/>.
               </item>
            
               <item>
                 <c>ZipInputStream</c> cannot read segmented or spanned
                 zip files.
               </item>
            
               <item>
                 <c>ZipInputStream</c> will not read Zip file comments.
               </item>
            
               <item>
                 When reading larger files, <c>ZipInputStream</c> will always underperform
                 <c>ZipFile</c>. This is because the <c>ZipInputStream</c> does a full scan on the
                 zip file, while the <c>ZipFile</c> class reads the central directory of the
                 zip file.
               </item>
            
             </list>
            
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream)">
             <summary>
               Create a <c>ZipInputStream</c>, wrapping it around an existing stream.
             </summary>
            
             <remarks>
            
             <para>
               While the <see cref="T:Ionic.Zip.ZipFile"/> class is generally easier
               to use, this class provides an alternative to those
               applications that want to read from a zipfile directly,
               using a <see cref="T:System.IO.Stream"/>.
             </para>
            
             <para>
               Both the <c>ZipInputStream</c> class and the <c>ZipFile</c> class can be used
               to read and extract zip files.  Both of them support many of the common zip
               features, including Unicode, different compression levels, and ZIP64.  The
               programming models differ. For example, when extracting entries via calls to
               the <c>GetNextEntry()</c> and <c>Read()</c> methods on the
               <c>ZipInputStream</c> class, the caller is responsible for creating the file,
               writing the bytes into the file, setting the attributes on the file, and
               setting the created, last modified, and last accessed timestamps on the
               file. All of these things are done automatically by a call to <see cref="M:Ionic.Zip.ZipEntry.Extract">ZipEntry.Extract()</see>.  For this reason, the
               <c>ZipInputStream</c> is generally recommended for when your application wants
               to extract the data, without storing that data into a file.
             </para>
            
             <para>
               Aside from the obvious differences in programming model, there are some
               differences in capability between the <c>ZipFile</c> class and the
               <c>ZipInputStream</c> class.
             </para>
            
             <list type="bullet">
               <item>
               <c>ZipFile</c> can be used to create or update zip files, or read and extract
               zip files. <c>ZipInputStream</c> can be used only to read and extract zip
                 files. If you want to use a stream to create zip files, check out the <see cref="T:Ionic.Zip.ZipOutputStream"/>.
               </item>
            
               <item>
                 <c>ZipInputStream</c> cannot read segmented or spanned
                 zip files.
               </item>
            
               <item>
                 <c>ZipInputStream</c> will not read Zip file comments.
               </item>
            
               <item>
                 When reading larger files, <c>ZipInputStream</c> will always underperform
                 <c>ZipFile</c>. This is because the <c>ZipInputStream</c> does a full scan on the
                 zip file, while the <c>ZipFile</c> class reads the central directory of the
                 zip file.
               </item>
            
             </list>
            
             </remarks>
            
             <param name="stream">
               The stream to read. It must be readable. This stream will be closed at
               the time the <c>ZipInputStream</c> is closed.
             </param>
            
             <example>
            
               This example shows how to read a zip file, and extract entries, using the
               <c>ZipInputStream</c> class.
            
             <code lang="C#">
             private void Unzip()
             {
                 byte[] buffer= new byte[2048];
                 int n;
                 using (var raw = File.Open(inputFileName, FileMode.Open, FileAccess.Read))
                 {
                     using (var input= new ZipInputStream(raw))
                     {
                         ZipEntry e;
                         while (( e = input.GetNextEntry()) != null)
                         {
                             if (e.IsDirectory) continue;
                             string outputPath = Path.Combine(extractDir, e.FileName);
                             using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
                             {
                                 while ((n= input.Read(buffer, 0, buffer.Length)) &gt; 0)
                                 {
                                     output.Write(buffer,0,n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub UnZip()
                 Dim inputFileName As String = "MyArchive.zip"
                 Dim extractDir As String = "extract"
                 Dim buffer As Byte() = New Byte(2048) {}
                 Using raw As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read)
                     Using input As ZipInputStream = New ZipInputStream(raw)
                         Dim e As ZipEntry
                         Do While (Not e = input.GetNextEntry Is Nothing)
                             If Not e.IsDirectory Then
                                 Using output As FileStream = File.Open(Path.Combine(extractDir, e.FileName), _
                                                                        FileMode.Create, FileAccess.ReadWrite)
                                     Dim n As Integer
                                     Do While (n = input.Read(buffer, 0, buffer.Length) &gt; 0)
                                         output.Write(buffer, 0, n)
                                     Loop
                                 End Using
                             End If
                         Loop
                     End Using
                 End Using
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.#ctor(System.String)">
             <summary>
               Create a <c>ZipInputStream</c>, given the name of an existing zip file.
             </summary>
            
             <remarks>
            
             <para>
               This constructor opens a <c>FileStream</c> for the given zipfile, and
               wraps a <c>ZipInputStream</c> around that.  See the documentation for the
               <see cref="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream)"/> constructor for full details.
             </para>
            
             <para>
               While the <see cref="T:Ionic.Zip.ZipFile"/> class is generally easier
               to use, this class provides an alternative to those
               applications that want to read from a zipfile directly,
               using a <see cref="T:System.IO.Stream"/>.
             </para>
            
             </remarks>
            
             <param name="fileName">
               The name of the filesystem file to read.
             </param>
            
             <example>
            
               This example shows how to read a zip file, and extract entries, using the
               <c>ZipInputStream</c> class.
            
             <code lang="C#">
             private void Unzip()
             {
                 byte[] buffer= new byte[2048];
                 int n;
                 using (var input= new ZipInputStream(inputFileName))
                 {
                     ZipEntry e;
                     while (( e = input.GetNextEntry()) != null)
                     {
                         if (e.IsDirectory) continue;
                         string outputPath = Path.Combine(extractDir, e.FileName);
                         using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
                         {
                             while ((n= input.Read(buffer, 0, buffer.Length)) &gt; 0)
                             {
                                 output.Write(buffer,0,n);
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub UnZip()
                 Dim inputFileName As String = "MyArchive.zip"
                 Dim extractDir As String = "extract"
                 Dim buffer As Byte() = New Byte(2048) {}
                 Using input As ZipInputStream = New ZipInputStream(inputFileName)
                     Dim e As ZipEntry
                     Do While (Not e = input.GetNextEntry Is Nothing)
                         If Not e.IsDirectory Then
                             Using output As FileStream = File.Open(Path.Combine(extractDir, e.FileName), _
                                                                    FileMode.Create, FileAccess.ReadWrite)
                                 Dim n As Integer
                                 Do While (n = input.Read(buffer, 0, buffer.Length) &gt; 0)
                                     output.Write(buffer, 0, n)
                                 Loop
                             End Using
                         End If
                     Loop
                 End Using
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream,System.Boolean)">
             <summary>
               Create a <c>ZipInputStream</c>, explicitly specifying whether to
               keep the underlying stream open.
             </summary>
            
             <remarks>
               See the documentation for the <see cref="M:Ionic.Zip.ZipInputStream.#ctor(System.IO.Stream)">ZipInputStream(Stream)</see>
               constructor for a discussion of the class, and an example of how to use the class.
             </remarks>
            
             <param name="stream">
               The stream to read from. It must be readable.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the stream
               to remain open after the <c>ZipInputStream</c> has been closed.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <remarks>
              <para>
                This can be useful for debugging purposes.
              </para>
            </remarks>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read the data from the stream into the buffer.
             </summary>
            
             <remarks>
             <para>
               The data for the zipentry will be decrypted and uncompressed, as
               necessary, before being copied into the buffer.
             </para>
            
             <para>
               You must set the <see cref="P:Ionic.Zip.ZipInputStream.Password"/> property before calling
               <c>Read()</c> the first time for an encrypted entry.  To determine if an
               entry is encrypted and requires a password, check the <see cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</see> property.
             </para>
             </remarks>
            
             <param name="buffer">The buffer to hold the data read from the stream.</param>
             <param name="offset">the offset within the buffer to copy the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes read, after decryption and decompression.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.GetNextEntry">
             <summary>
               Read the next entry from the zip file.
             </summary>
            
             <remarks>
             <para>
               Call this method just before calling <see cref="M:Ionic.Zip.ZipInputStream.Read(System.Byte[],System.Int32,System.Int32)"/>,
               to position the pointer in the zip file to the next entry that can be
               read.  Subsequent calls to <c>Read()</c>, will decrypt and decompress the
               data in the zip file, until <c>Read()</c> returns 0.
             </para>
            
             <para>
               Each time you call <c>GetNextEntry()</c>, the pointer in the wrapped
               stream is moved to the next entry in the zip file.  If you call <see cref="M:Ionic.Zip.ZipInputStream.Seek(System.Int64,System.IO.SeekOrigin)"/>, and thus re-position the pointer within
               the file, you will need to call <c>GetNextEntry()</c> again, to insure
               that the file pointer is positioned at the beginning of a zip entry.
             </para>
            
             <para>
               This method returns the <c>ZipEntry</c>. Using a stream approach, you will
               read the raw bytes for an entry in a zip file via calls to <c>Read()</c>.
               Alternatively, you can extract an entry into a file, or a stream, by
               calling <see cref="M:Ionic.Zip.ZipEntry.Extract"/>, or one of its siblings.
             </para>
            
             </remarks>
            
             <returns>
               The <c>ZipEntry</c> read. Returns null (or Nothing in VB) if there are no more
               entries in the zip file.
             </returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Dispose(System.Boolean)">
             <summary>
               Dispose the stream.
             </summary>
            
             <remarks>
             <para>
               This method disposes the ZipInputStream.  It may also close the underlying
               stream, depending on which constructor was used.
             </para>
            
             <para>
               Typically the application will call <c>Dispose()</c> implicitly, via a <c>using</c>
               statement in C#, or a <c>Using</c> statement in VB.
             </para>
            
             </remarks>
            
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Flush">
            <summary>
            This is a no-op.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="buffer">ignored</param>
            <param name="offset">ignored</param>
            <param name="count">ignored</param>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
             <summary>
               This method seeks in the underlying stream.
             </summary>
            
             <remarks>
             <para>
               Call this method if you want to seek around within the zip file for random access.
             </para>
            
             <para>
               Applications can intermix calls to <c>Seek()</c> with calls to <see cref="M:Ionic.Zip.ZipInputStream.GetNextEntry"/>.  After a call to <c>Seek()</c>,
               <c>GetNextEntry()</c> will get the next <c>ZipEntry</c> that falls after
               the current position in the input stream. You're on your own for finding
               out just where to seek in the stream, to get to the various entries.
             </para>
            
             </remarks>
            
             <param name="offset">the offset point to seek to</param>
             <param name="origin">the reference point from which to seek</param>
             <returns>The new position</returns>
        </member>
        <member name="M:Ionic.Zip.ZipInputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="value">ignored</param>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.ProvisionalAlternateEncoding">
             <summary>
               The text encoding to use when reading entries into the zip archive, for
               those entries whose filenames or comments cannot be encoded with the
               default (IBM437) encoding.
             </summary>
            
             <remarks>
             <para>
               In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
               zip specification</see>, PKWare describes two options for encoding
               filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
               or libraries do not follow the specification, and instead encode
               characters using the system default code page.  For example, WinRAR when
               run on a machine in Shanghai may encode filenames with the Big-5 Chinese
               (950) code page.  This behavior is contrary to the Zip specification, but
               it occurs anyway.
             </para>
            
             <para>
               When using DotNetZip to read zip archives that use something other than
               UTF-8 or IBM437, set this property to specify the code page to use when
               reading encoded filenames and comments for each <c>ZipEntry</c> in the zip
               file.
             </para>
            
             <para>
               This property is "provisional". When the entry in the zip archive is not
               explicitly marked as using UTF-8, then IBM437 is used to decode filenames
               and comments. If a loss of data would result from using IBM436 -
               specifically when encoding and decoding is not reflexive - the codepage
               specified here is used. It is possible, therefore, to have a given entry
               with a <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with
               the specified "provisional" codepage.
             </para>
            
             <para>
               When a zip file uses an arbitrary, non-UTF8 code page for encoding, there
               is no standard way for the reader application - whether DotNetZip, WinZip,
               WinRar, or something else - to know which codepage has been used for the
               entries. Readers of zip files are not able to inspect the zip file and
               determine the codepage that was used for the entries contained within it.
               It is left to the application or user to determine the necessary codepage
               when reading zip files encoded this way.  If you use an incorrect codepage
               when reading a zipfile, you will get entries with filenames that are
               incorrect, and the incorrect filenames may even contain characters that
               are not legal for use within filenames in Windows. Extracting entries with
               illegal characters in the filenames will lead to exceptions. It's too bad,
               but this is just the way things are with code pages in zip files. Caveat
               Emptor.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CodecBufferSize">
             <summary>
               Size of the work buffer to use for the ZLIB codec during decompression.
             </summary>
            
             <remarks>
               Setting this affects the performance and memory efficiency of compression
               and decompression.  For larger files, setting this to a larger size may
               improve performance, but the exact numbers vary depending on available
               memory, and a bunch of other variables. I don't have good firm
               recommendations on how to set it.  You'll have to test it yourself. Or
               just leave it alone and accept the default.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.Password">
             <summary>
               Sets the password to be used on the <c>ZipInputStream</c> instance.
             </summary>
            
             <remarks>
            
             <para>
               When reading a zip archive, this password is used to read and decrypt the
               entries that are encrypted within the zip file. When entries within a zip
               file use different passwords, set the appropriate password for the entry
               before the first call to <c>Read()</c> for each entry.
             </para>
            
             <para>
               When reading an entry that is not encrypted, the value of this property is
               ignored.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses the ZipInputStream to read and extract entries from a
               zip file, using a potentially different password for each entry.
            
             <code lang="C#">
             byte[] buffer= new byte[2048];
             int n;
             using (var raw = File.Open(_inputFileName, FileMode.Open, FileAccess.Read ))
             {
                 using (var input= new ZipInputStream(raw))
                 {
                     ZipEntry e;
                     while (( e = input.GetNextEntry()) != null)
                     {
                         input.Password = PasswordForEntry(e.FileName);
                         if (e.IsDirectory) continue;
                         string outputPath = Path.Combine(_extractDir, e.FileName);
                         using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
                         {
                             while ((n= input.Read(buffer,0,buffer.Length)) > 0)
                             {
                                 output.Write(buffer,0,n);
                             }
                         }
                     }
                 }
             }
            
             </code>
             </example>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CanRead">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CanSeek">
            <summary>
            Returns the value of <c>CanSeek</c> for the underlying (wrapped) stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.CanWrite">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.Length">
            <summary>
            Returns the length of the underlying stream.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipInputStream.Position">
            <summary>
            Gets or sets the position of the underlying stream.
            </summary>
            <remarks>
            Setting the position is equivalent to calling <c>Seek(value, SeekOrigin.Begin)</c>.
            </remarks>
        </member>
        <member name="T:Ionic.Zip.ZipOutputStream">
             <summary>
               Provides a stream metaphor for generating zip files.
             </summary>
            
             <remarks>
             <para>
               This class provides an alternative programming model to the one enabled by the
               <see cref="T:Ionic.Zip.ZipFile"/> class. Use this when creating zip files, as an
               alternative to the <see cref="T:Ionic.Zip.ZipFile"/> class, when you would like to use a
               Stream class to write the zip file.
             </para>
            
             <para>
               Some designs require a writable stream for output.  This stream can be used to
               produce a zip file, as it is written.
             </para>
            
             <para>
               Both the <c>ZipOutputStream</c> class and the <c>ZipFile</c> class can be used
               to create zip files. Both of them support many of the common zip features,
               including Unicode, different compression levels, and ZIP64.  For example, when
               creating a zip file via calls to the <c>PutNextEntry()</c> and <c>Write()</c>
               methods on the <c>ZipOutputStream</c> class, the caller is responsible for
               opening the file, reading the bytes from the file, writing those bytes into
               the <c>ZipOutputStream</c>, setting the attributes on the <c>ZipEntry</c>, and
               setting the created, last modified, and last accessed timestamps on the zip
               entry. All of these things are done automatically by a call to <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">ZipFile.AddFile()</see>.  For this
               reason, the <c>ZipOutputStream</c> is generally recommended for when your
               application wants to emit the arbitrary data, not necessarily data from a
               filesystem file, directly into a zip file.
             </para>
            
             <para>
               Aside from the differences in programming model, there are other
               differences in capability between the two classes.
             </para>
            
             <list type="bullet">
               <item>
                 <c>ZipFile</c> can be used to read and extract zip files, in addition to
                 creating zip files. <c>ZipOutputStream</c> cannot read zip files. If you want
                 to use a stream to read zip files, check out the <see cref="T:Ionic.Zip.ZipInputStream"/> class.
               </item>
            
               <item>
                 <c>ZipOutputStream</c> does not support the creation of segmented or spanned
                 zip files.
               </item>
            
               <item>
                 <c>ZipOutputStream</c> cannot produce a self-extracting archive.
               </item>
             </list>
            
             </remarks>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.#ctor(System.IO.Stream)">
             <summary>
               Create a ZipOutputStream, wrapping an existing stream.
             </summary>
            
             <remarks>
             <para>
               The <see cref="T:Ionic.Zip.ZipFile"/> class is generally easier to use when creating
               zip files. The ZipOutputStream offers a different metaphor for creating a
               zip file, based on the <see cref="T:System.IO.Stream"/> class.
             </para>
            
             <para>
               On the desktop .NET Framework, DotNetZip can use a multi-threaded
               compression implementation that provides significant speed increases on
               large files, over 300k or so, at the cost of increased memory use at
               runtime.  (The output of the compression is almost exactly the same size).
               But, the multi-threaded approach incurs a performance hit on smaller
               files. There's no way for the ZipOutputStream to know whether parallel
               compression will be beneficial, because the ZipOutputStream does not know
               how much data you will write through the stream.  you may wish to set the
               <see cref="P:Ionic.Zip.ZipOutputStream.ParallelDeflateThreshold"/> property to zero, if you are
               compressing large files through <c>ZipOutputStream</c>.  This will cause
               parallel compression to be used, always.
             </para>
             </remarks>
            
             <param name="stream">
             The stream to wrap. It must be writable. This stream will be closed at
             the time the ZipOutputStream is closed.
             </param>
            
             <example>
            
               This example shows how to create a zip file, using the
               ZipOutputStream class.
            
             <code lang="C#">
             private void Zipup()
             {
                 if (filesToZip.Count == 0)
                 {
                     System.Console.WriteLine("Nothing to do.");
                     return;
                 }
            
                 using (var raw = File.Open(_outputFileName, FileMode.Create, FileAccess.ReadWrite ))
                 {
                     using (var output= new ZipOutputStream(raw))
                     {
                         output.Password = "VerySecret!";
                         output.Encryption = EncryptionAlgorithm.WinZipAes256;
            
                         foreach (string inputFileName in filesToZip)
                         {
                             System.Console.WriteLine("file: {0}", inputFileName);
            
                             output.PutNextEntry(inputFileName);
                             using (var input = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Write ))
                             {
                                 byte[] buffer= new byte[2048];
                                 int n;
                                 while ((n= input.Read(buffer,0,buffer.Length)) &gt; 0)
                                 {
                                     output.Write(buffer,0,n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub Zipup()
                 Dim outputFileName As String = "XmlData.zip"
                 Dim filesToZip As String() = Directory.GetFiles(".", "*.xml")
                 If (filesToZip.Length = 0) Then
                     Console.WriteLine("Nothing to do.")
                 Else
                     Using raw As FileStream = File.Open(outputFileName, FileMode.Create, FileAccess.ReadWrite)
                         Using output As ZipOutputStream = New ZipOutputStream(raw)
                             output.Password = "VerySecret!"
                             output.Encryption = EncryptionAlgorithm.WinZipAes256
                             Dim inputFileName As String
                             For Each inputFileName In filesToZip
                                 Console.WriteLine("file: {0}", inputFileName)
                                 output.PutNextEntry(inputFileName)
                                 Using input As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                                     Dim n As Integer
                                     Dim buffer As Byte() = New Byte(2048) {}
                                     Do While (n = input.Read(buffer, 0, buffer.Length) &gt; 0)
                                         output.Write(buffer, 0, n)
                                     Loop
                                 End Using
                             Next
                         End Using
                     End Using
                 End If
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.#ctor(System.String)">
             <summary>
               Create a ZipOutputStream that writes to a filesystem file.
             </summary>
            
             <remarks>
               The <see cref="T:Ionic.Zip.ZipFile"/> class is generally easier to use when creating
               zip files. The ZipOutputStream offers a different metaphor for creating a
               zip file, based on the <see cref="T:System.IO.Stream"/> class.
             </remarks>
            
             <param name="fileName">
               The name of the zip file to create.
             </param>
            
             <example>
            
               This example shows how to create a zip file, using the
               ZipOutputStream class.
            
             <code lang="C#">
             private void Zipup()
             {
                 if (filesToZip.Count == 0)
                 {
                     System.Console.WriteLine("Nothing to do.");
                     return;
                 }
            
                 using (var output= new ZipOutputStream(outputFileName))
                 {
                     output.Password = "VerySecret!";
                     output.Encryption = EncryptionAlgorithm.WinZipAes256;
            
                     foreach (string inputFileName in filesToZip)
                     {
                         System.Console.WriteLine("file: {0}", inputFileName);
            
                         output.PutNextEntry(inputFileName);
                         using (var input = File.Open(inputFileName, FileMode.Open, FileAccess.Read,
                                                      FileShare.Read | FileShare.Write ))
                         {
                             byte[] buffer= new byte[2048];
                             int n;
                             while ((n= input.Read(buffer,0,buffer.Length)) &gt; 0)
                             {
                                 output.Write(buffer,0,n);
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub Zipup()
                 Dim outputFileName As String = "XmlData.zip"
                 Dim filesToZip As String() = Directory.GetFiles(".", "*.xml")
                 If (filesToZip.Length = 0) Then
                     Console.WriteLine("Nothing to do.")
                 Else
                     Using output As ZipOutputStream = New ZipOutputStream(outputFileName)
                         output.Password = "VerySecret!"
                         output.Encryption = EncryptionAlgorithm.WinZipAes256
                         Dim inputFileName As String
                         For Each inputFileName In filesToZip
                             Console.WriteLine("file: {0}", inputFileName)
                             output.PutNextEntry(inputFileName)
                             Using input As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                                 Dim n As Integer
                                 Dim buffer As Byte() = New Byte(2048) {}
                                 Do While (n = input.Read(buffer, 0, buffer.Length) &gt; 0)
                                     output.Write(buffer, 0, n)
                                 Loop
                             End Using
                         Next
                     End Using
                 End If
             End Sub
             </code>
             </example>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.#ctor(System.IO.Stream,System.Boolean)">
             <summary>
               Create a ZipOutputStream.
             </summary>
            
             <remarks>
               See the documentation for the <see cref="M:Ionic.Zip.ZipOutputStream.#ctor(System.IO.Stream)">ZipOutputStream(Stream)</see>
               constructor for an example.
             </remarks>
            
             <param name="stream">
               The stream to wrap. It must be writable.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the stream
               to remain open after the <c>ZipOutputStream</c> has been closed.
             </param>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <remarks>
              <para>
                This can be useful for debugging purposes.
              </para>
            </remarks>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.ContainsEntry(System.String)">
             <summary>
               Returns true if an entry by the given name has already been written
               to the ZipOutputStream.
             </summary>
            
             <param name="name">
               The name of the entry to scan for.
             </param>
            
             <returns>
             true if an entry by the given name has already been written.
             </returns>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write the data from the buffer to the stream.
             </summary>
            
             <remarks>
               As the application writes data into this stream, the data may be
               compressed and encrypted before being written out to the underlying
               stream, depending on the settings of the <see cref="P:Ionic.Zip.ZipOutputStream.CompressionLevel"/>
               and the <see cref="P:Ionic.Zip.ZipOutputStream.Encryption"/> properties.
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.PutNextEntry(System.String)">
             <summary>
               Specify the name of the next entry that will be written to the zip file.
             </summary>
            
             <remarks>
             <para>
               Call this method just before calling <see cref="M:Ionic.Zip.ZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)"/>, to
               specify the name of the entry that the next set of bytes written to
               the <c>ZipOutputStream</c> belongs to. All subsequent calls to <c>Write</c>,
               until the next call to <c>PutNextEntry</c>,
               will be inserted into the named entry in the zip file.
             </para>
            
             <para>
               If the <paramref name="entryName"/> used in <c>PutNextEntry()</c> ends in
               a slash, then the entry added is marked as a directory. Because directory
               entries do not contain data, a call to <c>Write()</c>, before an
               intervening additional call to <c>PutNextEntry()</c>, will throw an
               exception.
             </para>
            
             <para>
               If you don't call <c>Write()</c> between two calls to
               <c>PutNextEntry()</c>, the first entry is inserted into the zip file as a
               file of zero size.  This may be what you want.
             </para>
            
             <para>
               Because <c>PutNextEntry()</c> closes out the prior entry, if any, this
               method may throw if there is a problem with the prior entry.
             </para>
            
             <para>
               This method returns the <c>ZipEntry</c>.  You can modify public properties
               on the <c>ZipEntry</c>, such as <see cref="P:Ionic.Zip.ZipEntry.Encryption"/>, <see cref="P:Ionic.Zip.ZipEntry.Password"/>, and so on, until the first call to
               <c>ZipOutputStream.Write()</c>, or until the next call to
               <c>PutNextEntry()</c>.  If you modify the <c>ZipEntry</c> <em>after</em>
               having called <c>Write()</c>, you may get a runtime exception, or you may
               silently get an invalid zip archive.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to create a zip file, using the
               <c>ZipOutputStream</c> class.
            
             <code>
             private void Zipup()
             {
                 using (FileStream fs raw = File.Open(_outputFileName, FileMode.Create, FileAccess.ReadWrite ))
                 {
                     using (var output= new ZipOutputStream(fs))
                     {
                         output.Password = "VerySecret!";
                         output.Encryption = EncryptionAlgorithm.WinZipAes256;
                         output.PutNextEntry("entry1.txt");
                         byte[] buffer= System.Text.Encoding.ASCII.GetBytes("This is the content for entry #1.");
                         output.Write(buffer,0,buffer.Length);
                         output.PutNextEntry("entry2.txt");  // this will be zero length
                         output.PutNextEntry("entry3.txt");
                         buffer= System.Text.Encoding.ASCII.GetBytes("This is the content for entry #3.");
                         output.Write(buffer,0,buffer.Length);
                     }
                 }
             }
             </code>
             </example>
            
             <param name="entryName">
               The name of the entry to be added, including any path to be used
               within the zip file.
             </param>
            
             <returns>
               The ZipEntry created.
             </returns>
            
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Dispose(System.Boolean)">
             <summary>
             Dispose the stream
             </summary>
            
             <remarks>
             <para>
               This method writes the Zip Central directory, then closes the stream.  The
               application must call Dispose() (or Close) in order to produce a valid zip file.
             </para>
            
             <para>
               Typically the application will call <c>Dispose()</c> implicitly, via a <c>using</c>
               statement in C#, or a <c>Using</c> statement in VB.
             </para>
            
             </remarks>
            
             <param name="notCalledFromFinalizer">set this to true, always.</param>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Flush">
            <summary>
            This is a no-op.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="buffer">ignored</param>
            <param name="offset">ignored</param>
            <param name="count">ignored</param>
            <returns>nothing</returns>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="offset">ignored</param>
            <param name="origin">ignored</param>
            <returns>nothing</returns>
        </member>
        <member name="M:Ionic.Zip.ZipOutputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="value">ignored</param>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Password">
             <summary>
               Sets the password to be used on the <c>ZipOutputStream</c> instance.
             </summary>
            
             <remarks>
            
             <para>
               When writing a zip archive, this password is applied to the entries, not
               to the zip archive itself. It applies to any <c>ZipEntry</c> subsequently
               written to the <c>ZipOutputStream</c>.
             </para>
            
             <para>
               Using a password does not encrypt or protect the "directory" of the
               archive - the list of entries contained in the archive.  If you set the
               <c>Password</c> property, the password actually applies to individual
               entries that are added to the archive, subsequent to the setting of this
               property.  The list of filenames in the archive that is eventually created
               will appear in clear text, but the contents of the individual files are
               encrypted.  This is how Zip encryption works.
             </para>
            
             <para>
               If you set this property, and then add a set of entries to the archive via
               calls to <c>PutNextEntry</c>, then each entry is encrypted with that
               password.  You may also want to change the password between adding
               different entries. If you set the password, add an entry, then set the
               password to <c>null</c> (<c>Nothing</c> in VB), and add another entry, the
               first entry is encrypted and the second is not.
             </para>
            
             <para>
               When setting the <c>Password</c>, you may also want to explicitly set the <see cref="P:Ionic.Zip.ZipOutputStream.Encryption"/> property, to specify how to encrypt the entries added
               to the ZipFile.  If you set the <c>Password</c> to a non-null value and do not
               set <see cref="P:Ionic.Zip.ZipOutputStream.Encryption"/>, then PKZip 2.0 ("Weak") encryption is used.
               This encryption is relatively weak but is very interoperable. If
               you set the password to a <c>null</c> value (<c>Nothing</c> in VB),
               <c>Encryption</c> is reset to None.
             </para>
            
             <para>
               Special case: if you wrap a ZipOutputStream around a non-seekable stream,
               and use encryption, and emit an entry of zero bytes, the <c>Close()</c> or
               <c>PutNextEntry()</c> following the entry will throw an exception.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Encryption">
             <summary>
               The Encryption to use for entries added to the <c>ZipOutputStream</c>.
             </summary>
            
             <remarks>
             <para>
               The specified Encryption is applied to the entries subsequently
               written to the <c>ZipOutputStream</c> instance.
             </para>
            
             <para>
               If you set this to something other than
               EncryptionAlgorithm.None, you will also need to set the
               <see cref="P:Ionic.Zip.ZipOutputStream.Password"/> to a non-null, non-empty value in
               order to actually get encryption on the entry.
             </para>
            
             </remarks>
            
             <seealso cref="P:Ionic.Zip.ZipOutputStream.Password">ZipOutputStream.Password</seealso>
             <seealso cref="P:Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</seealso>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CodecBufferSize">
             <summary>
               Size of the work buffer to use for the ZLIB codec during compression.
             </summary>
            
             <remarks>
               Setting this may affect performance.  For larger files, setting this to a
               larger size may improve performance, but I'm not sure.  Sorry, I don't
               currently have good recommendations on how to set it.  You can test it if
               you like.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Strategy">
             <summary>
               The compression strategy to use for all entries.
             </summary>
            
             <remarks>
               Set the Strategy used by the ZLIB-compatible compressor, when compressing
               data for the entries in the zip archive. Different compression strategies
               work better on different sorts of data. The strategy parameter can affect
               the compression ratio and the speed of compression but not the correctness
               of the compresssion.  For more information see <see cref="T:Ionic.Zlib.CompressionStrategy"/>.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Timestamp">
             <summary>
               The type of timestamp attached to the ZipEntry.
             </summary>
            
             <remarks>
               Set this in order to specify the kind of timestamp that should be emitted
               into the zip file for each entry.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CompressionLevel">
             <summary>
               Sets the compression level to be used for entries subsequently added to
               the zip archive.
             </summary>
            
             <remarks>
              <para>
                Varying the compression level used on entries can affect the
                size-vs-speed tradeoff when compression and decompressing data streams
                or files.
              </para>
            
              <para>
                As with some other properties on the <c>ZipOutputStream</c> class, like <see cref="P:Ionic.Zip.ZipOutputStream.Password"/>, and <see cref="P:Ionic.Zip.ZipOutputStream.Encryption"/>,
                setting this property on a <c>ZipOutputStream</c>
                instance will cause the specified <c>CompressionLevel</c> to be used on all
                <see cref="T:Ionic.Zip.ZipEntry"/> items that are subsequently added to the
                <c>ZipOutputStream</c> instance.
              </para>
            
              <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Comment">
             <summary>
               A comment attached to the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               The application sets this property to specify a comment to be embedded
               into the generated zip archive.
             </para>
            
             <para>
               According to <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see>, the comment is not encrypted, even if there is a
               password set on the zip file.
             </para>
            
             <para>
               The zip specification does not describe how to encode the comment string
               in a code page other than IBM437. Therefore, for "compliant" zip tools and
               libraries, comments will use IBM437. However, there are situations where
               you want an encoded Comment, for example using code page 950 "Big-5
               Chinese".  DotNetZip will encode the comment in the code page specified by
               <see cref="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding"/>, at the time of the call to
               <c>Close()</c> or <c>Dispose</c>.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.EnableZip64">
             <summary>
               Specify whether to use ZIP64 extensions when saving a zip archive.
             </summary>
            
             <remarks>
             <para>
               The default value for the property is <see cref="F:Ionic.Zip.Zip64Option.Never"/>. <see cref="F:Ionic.Zip.Zip64Option.AsNecessary"/> is
               safest, in the sense that you will not get an Exception if a
               pre-ZIP64 limit is exceeded.
             </para>
            
             <para>
               You must set this property before calling <c>Write()</c>.
             </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.OutputUsedZip64">
             <summary>
               Indicates whether ZIP64 extensions were used when saving the zip archive.
             </summary>
            
             <remarks>
               The value is defined only after the <c>ZipOutputStream</c> has been closed.
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.IgnoreCase">
             <summary>
               Whether the ZipOutputStream should use case-insensitive comparisons when
               checking for uniqueness of zip entries.
             </summary>
            
             <remarks>
               <para>
               Though the zip specification doesn't prohibit zipfiles with duplicate
               entries, Sane zip files have no duplicates, and the DotNetZip library
               cannot create zip files with duplicate entries. If an application attempts
               to call <see cref="M:Ionic.Zip.ZipOutputStream.PutNextEntry(System.String)"/> with a name that duplicates one
               already used within the archive, the library will throw an Exception.
               </para>
               <para>
               This property allows the application to specify whether the
               ZipOutputStream instance considers ordinal case when checking for
               uniqueness of zip entries.
               </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.UseUnicodeAsNecessary">
             <summary>
               Indicates whether to encode entry filenames and entry comments using
               Unicode (UTF-8).
             </summary>
            
             <remarks>
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
               PKWare zip specification</see> provides for encoding file names and file
               comments in either the IBM437 code page, or in UTF-8.  This flag selects
               the encoding according to that specification.  By default, this flag is
               false, and filenames and comments are encoded into the zip file in the
               IBM437 codepage.  Setting this flag to true will specify that filenames
               and comments that cannot be encoded with IBM437 will be encoded with
               UTF-8.
             </para>
            
             <para>
               Zip files created with strict adherence to the PKWare specification with
               respect to UTF-8 encoding can contain entries with filenames containing
               any combination of Unicode characters, including the full range of
               characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other
               alphabets.  However, because at this time, the UTF-8 portion of the PKWare
               specification is not broadly supported by other zip libraries and
               utilities, such zip files may not be readable by your favorite zip tool or
               archiver. In other words, interoperability will decrease if you set this
               flag to true.
             </para>
            
             <para>
               In particular, Zip files created with strict adherence to the PKWare
               specification with respect to UTF-8 encoding will not work well with
               Explorer in Windows XP or Windows Vista, because Windows compressed
               folders, as far as I know, do not support UTF-8 in zip files.  Vista can
               read the zip files, but shows the filenames incorrectly. Unpacking from
               Windows Vista Explorer will result in filenames that have rubbish
               characters in place of the high-order UTF-8 bytes.
             </para>
            
             <para>
               Also, zip files that use UTF-8 encoding will not work well with Java
               applications that use the java.util.zip classes, as of v5.0 of the Java
               runtime. The Java runtime does not correctly implement the PKWare
               specification in this regard.
             </para>
            
             <para>
               As a result, we have the unfortunate situation that "correct" behavior by
               the DotNetZip library with regard to Unicode encoding of filenames during
               zip creation will result in zip files that are readable by strictly
               compliant and current tools (for example the most recent release of the
               commercial WinZip tool); but these zip files will not be readable by
               various other tools or libraries, including Windows Explorer.
             </para>
            
             <para>
               The DotNetZip library can read and write zip files with UTF8-encoded
               entries, according to the PKware spec.  If you use DotNetZip for both
               creating and reading the zip file, and you use UTF-8, there will be no
               loss of information in the filenames. For example, using a self-extractor
               created by this library will allow you to unpack files correctly with no
               loss of information in the filenames.
             </para>
            
             <para>
               If you do not set this flag, it will remain false.  If this flag is false,
               the <c>ZipOutputStream</c> will encode all filenames and comments using
               the IBM437 codepage.  This can cause "loss of information" on some
               filenames, but the resulting zipfile will be more interoperable with other
               utilities. As an example of the loss of information, diacritics can be
               lost.  The o-tilde character will be down-coded to plain o.  The c with a
               cedilla (Unicode 0xE7) used in Portugese will be downcoded to a c.
               Likewise, the O-stroke character (Unicode 248), used in Danish and
               Norwegian, will be down-coded to plain o. Chinese characters cannot be
               represented in codepage IBM437; when using the default encoding, Chinese
               characters in filenames will be represented as ?. These are all examples
               of "information loss".
             </para>
            
             <para>
               The loss of information associated to the use of the IBM437 encoding is
               inconvenient, and can also lead to runtime errors. For example, using
               IBM437, any sequence of 4 Chinese characters will be encoded as ????.  If
               your application creates a <c>ZipOutputStream</c>, does not set the
               encoding, then adds two files, each with names of four Chinese characters
               each, this will result in a duplicate filename exception.  In the case
               where you add a single file with a name containing four Chinese
               characters, the zipfile will save properly, but extracting that file
               later, with any zip tool, will result in an error, because the question
               mark is not legal for use within filenames on Windows.  These are just a
               few examples of the problems associated to loss of information.
             </para>
            
             <para>
               This flag is independent of the encoding of the content within the entries
               in the zip file. Think of the zip file as a container - it supports an
               encoding.  Within the container are other "containers" - the file entries
               themselves.  The encoding within those entries is independent of the
               encoding of the zip archive container for those entries.
             </para>
            
             <para>
               Rather than specify the encoding in a binary fashion using this flag, an
               application can specify an arbitrary encoding via the <see cref="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding"/> property.  Setting the encoding
               explicitly when creating zip archives will result in non-compliant zip
               files that, curiously, are fairly interoperable.  The challenge is, the
               PKWare specification does not provide for a way to specify that an entry
               in a zip archive uses a code page that is neither IBM437 nor UTF-8.
               Therefore if you set the encoding explicitly when creating a zip archive,
               you must take care upon reading the zip archive to use the same code page.
               If you get it wrong, the behavior is undefined and may result in incorrect
               filenames, exceptions, stomach upset, hair loss, and acne.
             </para>
             </remarks>
             <seealso cref="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding"/>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.ProvisionalAlternateEncoding">
             <summary>
               The text encoding to use when emitting entries into the zip archive, for
               those entries whose filenames or comments cannot be encoded with the
               default (IBM437) encoding.
             </summary>
            
             <remarks>
             <para>
               In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
               zip specification</see>, PKWare describes two options for encoding
               filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
               or libraries do not follow the specification, and instead encode
               characters using the system default code page.  For example, WinRAR when
               run on a machine in Shanghai may encode filenames with the Big-5 Chinese
               (950) code page.  This behavior is contrary to the Zip specification, but
               it occurs anyway.
             </para>
            
             <para>
               When using DotNetZip to write zip archives that will be read by one of
               these other archivers, set this property to specify the code page to use
               when encoding the <see cref="P:Ionic.Zip.ZipEntry.FileName"/> and <see cref="P:Ionic.Zip.ZipEntry.Comment"/> for each <c>ZipEntry</c> in the zip file, for
               values that cannot be encoded with the default codepage for zip files,
               IBM437.  This is why this property is "provisional".  In all cases, IBM437
               is used where possible, in other words, where no loss of data would
               result. It is possible, therefore, to have a given entry with a
               <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with the
               specified "provisional" codepage.
             </para>
            
             <para>
               Be aware that a zip file created after you've explicitly set the
               <c>ProvisionalAlternateEncoding</c> property to a value other than
               IBM437 may not be compliant to the PKWare specification, and may not be
               readable by compliant archivers.  On the other hand, many (most?)
               archivers are non-compliant and can read zip files created in arbitrary
               code pages.  The trick is to use or specify the proper codepage when
               reading the zip.
             </para>
            
             <para>
               When creating a zip archive using this library, it is possible to change
               the value of <c>ProvisionalAlternateEncoding</c> between each
               entry you add, and between adding entries and the call to
               <c>Close()</c>. Don't do this. It will likely result in a zipfile that is
               not readable.  For best interoperability, either leave
               <c>ProvisionalAlternateEncoding</c> alone, or specify it only once,
               before adding any entries to the <c>ZipOutputStream</c> instance.  There is one
               exception to this recommendation, described later.
             </para>
            
             <para>
               When using an arbitrary, non-UTF8 code page for encoding, there is no
               standard way for the creator application - whether DotNetZip, WinZip,
               WinRar, or something else - to formally specify in the zip file which
               codepage has been used for the entries. As a result, readers of zip files
               are not able to inspect the zip file and determine the codepage that was
               used for the entries contained within it.  It is left to the application
               or user to determine the necessary codepage when reading zip files encoded
               this way.  If you use an incorrect codepage when reading a zipfile, you
               will get entries with filenames that are incorrect, and the incorrect
               filenames may even contain characters that are not legal for use within
               filenames in Windows. Extracting entries with illegal characters in the
               filenames will lead to exceptions. It's too bad, but this is just the way
               things are with code pages in zip files. Caveat Emptor.
             </para>
            
             <para>
               One possible approach for specifying the code page for a given zip file is
               to describe the code page in a human-readable form in the Zip comment. For
               example, the comment may read "Entries in this archive are encoded in the
               Big5 code page".  For maximum interoperability, the zip comment in this
               case should be encoded in the default, IBM437 code page.  In this case,
               the zip comment is encoded using a different page than the filenames.  To
               do this, Specify <c>ProvisionalAlternateEncoding</c> to your desired
               region-specific code page, once before adding any entries, and then set
               the <see cref="P:Ionic.Zip.ZipOutputStream.Comment"/> property and reset
               <c>ProvisionalAlternateEncoding</c> to IBM437 before calling <c>Close()</c>.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.ParallelDeflateThreshold">
             <summary>
               The size threshold for an entry, above which a parallel deflate is used.
             </summary>
            
             <remarks>
            
               <para>
                 DotNetZip will use multiple threads to compress any ZipEntry,
                 if the entry is larger than the given size.  Zero means "always
                 use parallel deflate", while -1 means "never use parallel
                 deflate".
               </para>
            
               <para>
                 If the entry size cannot be known before compression, as with any entry
                 added via a ZipOutputStream, then Parallel deflate will never be
                 performed, unless the value of this property is zero.
               </para>
            
               <para>
                 A parallel deflate operations will speed up the compression of
                 large files, on computers with multiple CPUs or multiple CPU
                 cores.  For files above 1mb, on a dual core or dual-cpu (2p)
                 machine, the time required to compress the file can be 70% of the
                 single-threaded deflate.  For very large files on 4p machines the
                 compression can be done in 30% of the normal time.  The downside
                 is that parallel deflate consumes extra memory during the deflate,
                 and the deflation is slightly less effective.
               </para>
            
               <para>
                 Parallel deflate tends to not be as effective as single-threaded deflate
                 because the original data stream is split into multiple independent
                 buffers, each of which is compressed in parallel.  But because they are
                 treated independently, there is no opportunity to share compression
                 dictionaries, and additional framing bytes must be added to the output
                 stream.  For that reason, a deflated stream may be slightly larger when
                 compressed using parallel deflate, as compared to a traditional
                 single-threaded deflate. For files of about 512k, the increase over the
                 normal deflate is as much as 5% of the total compressed size. For larger
                 files, the difference can be as small as 0.1%.
               </para>
            
               <para>
                 Multi-threaded compression does not give as much an advantage when using
                 Encryption. This is primarily because encryption tends to slow down
                 the entire pipeline. Also, multi-threaded compression gives less of an
                 advantage when using lower compression levels, for example <see cref="F:Ionic.Zlib.CompressionLevel.BestSpeed"/>.  You may have to perform
                 some tests to determine the best approach for your situation.
               </para>
            
               <para>
                 The default value for this property is -1, which means parallel
                 compression will not be performed unless you set it to zero.
               </para>
            
             </remarks>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CanRead">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CanSeek">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.CanWrite">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Length">
            <summary>
            Always returns a NotSupportedException.
            </summary>
        </member>
        <member name="P:Ionic.Zip.ZipOutputStream.Position">
            <summary>
            Setting this property always returns a NotSupportedException. Getting it
            returns the value of the Position on the underlying stream.
            </summary>
        </member>
        <member name="M:Ionic.Zip.ZipSegmentedStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Ionic.Zip.ZipSegmentedStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream.
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="T:Ionic.Zlib.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.None">
            <summary>
            None means that the data will be simply stored, with no change at all.
            If you are producing ZIPs for use on Mac OSX, be aware that archives produced with CompressionLevel.None
            cannot be opened with the default zip reader. Use a different CompressionLevel.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level0">
            <summary>
            Same as None.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.BestSpeed">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level1">
            <summary>
            A synonym for BestSpeed.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level5">
            <summary>
            A little slower than level 4, but with better compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Default">
            <summary>
            The default compression level, with a good balance of speed and compression efficiency.   
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level6">
            <summary>
            A synonym for Default.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level8">
            <summary>
             Better compression than Level7!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.BestCompression">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream. 
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionLevel.Level9">
            <summary>
            A synonym for BestCompression.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionStrategy">
            <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compresssion.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.Default">
            <summary>
            The default strategy is probably the best for normal data. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.Filtered">
            <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-step between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionStrategy.HuffmanOnly">
            <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.CompressionMode">
            <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionMode.Compress">
            <summary>
            Used to specify that the stream should compress the data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.CompressionMode.Decompress">
            <summary>
            Used to specify that the stream should decompress the data.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library. 
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:Ionic.Zlib.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Ionic.Zlib.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
             <summary>
               Reads a number of characters from the current source TextReader and writes
               the data to the target array at the specified index.
             </summary>
            
             <param name="sourceTextReader">The source TextReader to read from</param>
             <param name="target">Contains the array of characteres read from the source TextReader.</param>
             <param name="start">The starting index of the target array.</param>
             <param name="count">The maximum number of characters to read from the source TextReader.</param>
             
             <returns>
               The number of characters read. The number will be less than or equal to
               count depending on the data available in the source TextReader. Returns -1
               if the end of the stream is reached.
             </returns>
        </member>
        <member name="T:Ionic.Zlib.Adler">
            <summary>
            Computes an Adler-32 checksum. 
            </summary>
            <remarks>
            The Adler checksum is similar to a CRC checksum, but faster to compute, though less
            reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
            is a required part of the "ZLIB" standard.  Applications will almost never need to
            use this class directly.
            </remarks>
        </member>
        <member name="T:Ionic.Zlib.ZlibCodec">
             <summary>
             Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
             </summary>
            
             <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the ZLIB format, as documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see
             href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
             </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.NextIn">
            <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.NextOut">
            <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.CompressLevel">
            <summary>
            The compression level to use in this codec.  Useful only in compression mode.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.WindowBits">
            <summary>
            The number of Window Bits to use.  
            </summary>
            <remarks>
            This gauges the size of the sliding window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k window.  
            </remarks>
        </member>
        <member name="F:Ionic.Zlib.ZlibCodec.Strategy">
            <summary>
            The compression strategy to use.
            </summary>
            <remarks>
            This is only effective in compression.  The theory offered by ZLIB is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.#ctor(Ionic.Zlib.CompressionMode)">
            <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
            <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate">
            <summary>
            Initialize the inflation state. 
            </summary>
            <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
            
             <remarks>
             By default, the ZLIB header defined in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
            
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32)">
            <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
            
             <remarks>
             If you want to read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a ZLIB
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
             GZIP stream, which does not have such a header, you will want to specify
             false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
             <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.Inflate(Ionic.Zlib.FlushType)">
             <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
             <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
             <example>
             <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.None);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.Finish);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
             </example>
             <param name="flush">The flush to use when inflating.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SyncInflate">
            <summary>
            I don't know what this does!
            </summary>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate">
            <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
            <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
            <example>
            <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(FlushType.None);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(FlushType.Finish);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
            </example>
            <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified
            CompressionLevel.  It will emit a ZLIB stream as it compresses.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a ZLIB
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
            <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32,System.Boolean)">
             <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
            
             <param name="level">The compression level for the codec.</param>
             <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
             <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
             <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.Deflate(Ionic.Zlib.FlushType)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
            <example>
            <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.None);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.Finish);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.ResetDeflate">
            <summary>
            Reset a codec for another deflation session.
            </summary>
            <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SetDeflateParams(Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy)">
            <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
            <param name="level">the level of compression to use.</param>
            <param name="strategy">the strategy to use for compression.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibCodec.SetDictionary(System.Byte[])">
            <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
            <param name="dictionary">The dictionary bytes to use.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="P:Ionic.Zlib.ZlibCodec.Adler32">
            <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsMax">
            <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsDefault">
            <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_OK">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_END">
            <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_NEED_DICT">
            <summary>
            The operation ended in need of a dictionary. 
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_ERROR">
            <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_DATA_ERROR">
            <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.Z_BUF_ERROR">
            <summary>
            There was an error with the working buffer.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeDefault">
            <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
        </member>
        <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeMin">
            <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
        </member>
        <member name="T:Ionic.Zlib.ZlibStream">
             <summary>
             Represents a Zlib stream for compression or decompression.
             </summary>
             <remarks>
            
             <para>
             The ZlibStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream"/>.  It adds ZLIB compression or decompression to any
             stream.
             </para>
            
             <para> Using this stream, applications can compress or decompress data via
             stream <c>Read()</c> and <c>Write()</c> operations.  Either compresssion or
             decompression can occur through either reading or writing. The compression
             format used is ZLIB, which is documented in <see href="http://www.ietf.org/rfc/rfc1950.txt">IETF RFC 1950</see>, "ZLIB Compressed
             Data Format Specification version 3.3". This implementation of ZLIB always uses
             DEFLATE as the compression method.  (see <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
             Compressed Data Format Specification version 1.3.") </para>
            
             <para>
             The ZLIB format allows for varying compression methods, window sizes, and dictionaries.
             This implementation always uses the DEFLATE compression method, a preset dictionary,
             and 15 window bits by default.
             </para>
            
             <para>
             This class is similar to <see cref="T:Ionic.Zlib.DeflateStream"/>, except that it adds the
             RFC1950 header and trailer bytes to a compressed stream when compressing, or expects
             the RFC1950 header and trailer bytes when decompressing.  It is also similar to the
             <see cref="T:Ionic.Zlib.GZipStream"/>.
             </para>
             </remarks>
             <seealso cref="T:Ionic.Zlib.DeflateStream"/>
             <seealso cref="T:Ionic.Zlib.GZipStream"/>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
             <summary>
             Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c> will use the
               default compression level. The "captive" stream will be closed when the
               <c>ZlibStream</c> is closed.
             </para>
            
             </remarks>
            
             <example>
             This example uses a <c>ZlibStream</c> to compress a file, and writes the compressed
             data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
               The "captive" stream will be closed when the <c>ZlibStream</c> is closed.
             </para>
            
             </remarks>
            
             <example>
               This example uses a <c>ZlibStream</c> to compress data from a file, and writes the
               compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                     Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
            
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the captive stream should be left open after
               Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c> will use
               the default compression level.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter to leave the stream
               open.
             </para>
            
             <para>
             See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">The stream which will be read or written. This is called the
             "captive" stream in other places in this documentation.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain
             open after inflation/deflation.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also closed. In
               some cases this is not desired, for example if the stream is a <see cref="T:System.IO.MemoryStream"/> that will be re-read after compression.
               Specify true for the <paramref name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             </para>
            
             </remarks>
            
             <example>
             This example shows how to use a ZlibStream to compress the data from a file,
             and store the result into another file. The filestream remains open to allow
             additional data to be written to it.
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".zlib"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
            
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
            
             <param name="leaveOpen">
             true if the application would like the stream to remain open after inflation/deflation.
             </param>
            
             <param name="level">
             A tuning knob to trade speed for effectiveness. This parameter is effective only when
             mode is <c>CompressionMode.Compress</c>.
             </param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Dispose(System.Boolean)">
            <summary>
            Dispose the stream.
            </summary>
            <remarks>
            This may or may not result in a <c>Close()</c> call on the captive stream.
            See the constructors that have a  <c>leaveOpen</c> parameter for more information.
            </remarks>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
            
             <remarks>
            
             <para>
               If you wish to use the <c>ZlibStream</c> to compress data while reading,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               providing an uncompressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data read will be compressed.  If you wish to
               use the <c>ZlibStream</c> to decompress data while reading, you can create
               a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, providing a
               readable compressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data will be decompressed as it is read.
             </para>
            
             <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but
               not both.
             </para>
            
             </remarks>
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Write data to the stream.
             </summary>
            
             <remarks>
            
             <para>
               If you wish to use the <c>ZlibStream</c> to compress data while writing,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               and a writable output stream.  Then call <c>Write()</c> on that
               <c>ZlibStream</c>, providing uncompressed data as input.  The data sent to
               the output stream will be the compressed form of the data written.  If you
               wish to use the <c>ZlibStream</c> to decompress data while writing, you
               can create a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that stream,
               providing previously compressed data. The data sent to the output stream
               will be the decompressed form of the data written.
             </para>
            
             <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using ZLIB.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])"/>
            
             <param name="s">
               A string to compress.  The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using ZLIB.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
             A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a ZLIB-compressed byte array into a single string.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressString(System.String)"/>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing ZLIB-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a ZLIB-compressed byte array into a byte array.
             </summary>
            
             <seealso cref="M:Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing ZLIB-compressed data.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            Sorry, though, not sure exactly how to describe all the various settings.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes. The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Ionic.Zlib.ZlibStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
    </members>
</doc>
